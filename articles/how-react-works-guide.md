---
title: "Reactの内部の仕組み読み解きガイド (執筆中)"
emoji: "⚛️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["React"]
published: true
---

# はじめに

こんにちは、calloc134 です。毎日「React なんもわからん」を繰り返していたところ、ソースコードを読み始めていました

React は今や、フロントエンド開発においてデファクトスタンダートなライブラリとなっています。
しかし、どのような考え方・仕組みで実装されているのか、気付かないうちに勘違いしている人も多いのではないでしょうか。
今回は、そんな React の内部の仕組みを、必要があればソースコードを参照しながら解説していきたいと思います。

なお、参考にするソースコードは React 18.2.0 のものを使用します。
当該バージョンは参考文献のバージョンと揃えるために選択しました。基本的な動作はおおよそ同じものと考えていますが、最新のバージョンにおける変更点があれば後ほどまとめて追記していきたいと思います。
加えて、クラスコンポーネントに関する内容は一切解説しない方針で進めていきます。ご了承ください。

# 前提として

## React は何を成し遂げるもの？

React とは、UI を宣言的に記述するためのライブラリです。
宣言的とは、「どのように達成するか (How)」ではなく、「何を達成するか (What)」に焦点を当て、処理を記述することを意味します。
命令的 (Imperative) という言葉があります。こちらは従来のプログラミングスタイルで、どのように処理を行うかを詳細に記述することを指します。
この 2 つは何が違うのでしょうか？

例えば、白いキャンバスに四角形を描くことを考えてみましょう。

命令的なアプローチでは、以下のように UI を記述します。

- まずペンを下ろす
- 右に線をひく
- 下に線をひく
- 左に線をひく
- 上に線をひく

このような具合に、一つ一つの操作手順を細かく記述します。

対して宣言的なアプローチでは、

- キャンバス上に四角形を描く

というやりたいことを宣言するだけで、やりたいことが達成されます。魔法のようですね。
重要なのは、「どのように四角形を描くか」という How ではなく、「四角形を描く」という What=目的そのものに焦点を当てていることです。
目的のみを記述することで、実装の詳細をすべてライブラリが担当してくれるため、開発者は UI を記述する効率を大幅に向上させることができます。
このライブラリこそが、React というわけです。

## 宣言的 UI の実装

宣言的な UI を実装するために、React はどのようなアプローチをとっているのでしょうか？
React では、仮想 DOM (Virtual DOM) と呼ばれる概念を用いて UI の状態を管理します。

:::message
後述しますが、仮想 DOM という言葉は React ドキュメントでは使われておらず、不適切な表現であるという指摘があります。
このセクションでは簡単のために仮想 DOM という言葉を使いますが、正確には「React の内部で管理される状態」と考えてください。
:::

仮想 DOM とは、UI の状態を表現するための JavaScript オブジェクトのことです。
React がレンダリングを行うたび、仮想 DOM オブジェクトが新しく作成されます。
続けて前回の仮想 DOM の状態と新規作成された仮想 DOM の状態を比較し、変更があった部分のみを実際の DOM に反映します。

具体的に例え話をしてみましょう。
まずここに、タコのイラストがあるとします。このイラストについて、最後の足だけ上に上げて、手のようにしたいと思います。
これを命令的に行いたいとき、二通りの方法があります。

1 つ目は、イラストを一旦全部消して、最後の足を手のように描き直す方法です。

- イラストを全部消す
- 最後の足を手のようにし、手を上げたタコを描く

2 つ目は、イラストの一部を変更する方法です。

- 最後の足だけを消す
- 最後の足だけ、手のようにして上げたタコに変更する

この 2 つの方法はどちらも同じ結果を得ることができますが、2 つ目の方法はより効率的です。しかし 2 つ目の手法を自力で行うのは労力がかかります。
React であれば、仮想 DOM を用いて差分を検出し、変更箇所のみを実際の DOM に反映することで、2 つ目の方法を自動的に行うことができます。

- 軽量なキャンバス (仮想 DOM) 上にタコのイラストを描く
- 新しく、軽量なキャンバス (仮想 DOM) 上に手を上げたタコのイラストを描く
- 2 つのキャンバスを比較し、差分を洗い出す (\*)
  - 今回は、最後の足のみ差異
- 実際のキャンバス (実際の DOM) 上のタコのイラストを、最後の足のみ手のように上げたタコに変更する (\*)

ここで(\*) の部分が、React が担ってくれる差分検出&適用の部分です。
ユーザはすべての見た目を描き直す必要なしに、宣言的に「手を上げたタコ」を描くことができます。

# フェーズ

では前提もできたところで、React の内部の仕組みを詳しく見ていきましょう。

React のレンダリングは、主に 四つのフェーズに分かれています。

- トリガーフェーズ
- スケジューリングフェーズ
- レンダーフェーズ
- コミットフェーズ

トリガーフェーズは、React のレンダリング作業を開始するきっかけとなるフェーズです。
スケジューリングフェーズは、レンダリングの優先度などを参考にしながらタスクの実行をスケジューリングするフェーズです。
レンダーフェーズでは、先程の例で挙げたように仮想 DOM の状態を更新し、差分を検出するフェーズです。この処理は中断可能になっており、React が適切なタイミングで中断・再開することができます。
コミットフェーズでは、レンダーフェーズで検出された差分を実際の DOM に反映するフェーズです。このフェーズは中断されることがなく、短い期間で確実に実行される必要があります。

この四つのフェーズを通して React は宣言的な UI の実装を効率的に行うことができます。
React 公式ドキュメントでは下の 2 つについてのみ解説されています。四つのフェーズの定義については以下のドキュメントより引用しています。
https://jser.dev/2023-07-11-overall-of-react-internals

日本語訳はこちらを参照してください。
https://calloc134.github.io/how-react-works/docs/react-internals-deep-dive/overall-of-react-internals

# Fiber ノード構造

先程、React は仮想 DOM を利用して UI の状態を管理すると説明しました。この「仮想 DOM」という呼称についてですが、本質的な理解ではないことをここで明確にしておきます。

React が内部で管理しているのは、仮想 DOM ではなく「Fiber ノード」と呼ばれるオブジェクトを木構造とした状態、「Fiber ツリー」と呼ばれるものです。

Fiber ノードは、React のコンポーネントの状態を表現するためのオブジェクトであり、以下のような情報を持っています。

## 基本的なプロパティ

- key: コンポーネントの一意な識別子
- tag: コンポーネントのタイプ
- stateNode: コンポーネントのインスタンス (実際に対応する DOM ノードなど)
- ref: 開発者が Ref で渡したオブジェクト等

## Fiber ツリーにおける参照のプロパティ

- child: 子に当たる Fiber ノード
- sibling: 同じ親を持つ兄弟の Fiber ノード
- return: 親に当たる Fiber ノード
- alternate: 2 つある Fiber ノードのうち、相対するもう一方のノードへの参照 (ない場合は null)
- index: 同じ親に属する子ノードの中でのインデックス

## レンダリングに関するプロパティ

- memoizedProps: 前回のレンダリングで適用されたプロパティ
- pendingProps: 次のレンダリングで適用されるプロパティ
- memoizedState: 前回のレンダリングで適用された状態
- dependencies: フックの依存関係を表すオブジェクト (useContext などでコンテキストに依存している場合など)

## 更新の際に指標となるプロパティ

- lanes: 更新に対応する優先度 (Lanes)
- childLanes: 子コンポーネントの優先度を集約した優先度
- flags: 更新に関するフラグ (例: 属性の追加や削除など)
- subtreeFlags: 子から渡されたフラグを集約したフラグ
- deletions: 削除されるべき Fiber ノードのリスト

## 副作用に関するプロパティ

- firstEffect: サブツリー内で最初に副作用フラグを持つ Fiber ノード
- nextEffect: サブツリー内で次に副作用フラグを持つ Fiber ノード
- lastEffect: サブツリー内で最後に副作用フラグを持つ Fiber ノード
- updateQueue: 副作用のための update オブジェクトを保持するキュー

# Fiber ノードの相互関連

Fiber ノードは、親子関係や兄弟関係を持つ木構造で表現されます。

# レンダリング手法の歴史

レンダリング手法の歴史についても触れておきましょう。
React のレンダリング手法は、バージョン 15 から 16 にかけて大きく変更されました。

バージョン 15 までは、React は「スタックベースのレンダリング手法」を採用していました。
簡単に解説すると、それぞれのコンポーネント毎にインスタンスを生成し、それを単一のツリー構造で管理していました。
レンダリングの際、ツリーの根本から末端までを再帰的に処理し、子ツリーまですべてのコンポーネントを一度にレンダリングしていました。この過程で JavaScript のコールスタックを大量に消費し、UI が固まるようなパフォーマンスの問題が発生していました。

バージョン 16 からは、React は「Fiber ベースのレンダリング手法」を採用しました。
Fiber ベースのレンダリング手法では、各コンポーネントを「Fiber ノード」として表現し、Fiber ノードが他の Fiber ノードを参照する形でツリー構造を形成します。
この構造にすることによるメリットとして、スタックベースではすべてのツリーを走査し終わるまで処理が止まってしまうのに対し、Fiber ベースではレンダリングの作業を分割し、、レンダーの処理の途中で一時停止・再開・中止が可能になります。

レンダリングの作業を分割する単位は「Unit of Work (作業単位)」と呼ばれており、これを小さなチャンクとしてブラウザのイベントループや一定時間内に合わせてそのチャンクを徐々に実行することでスムーズな UI 描画が実現できるようになりました。
またこの変更により、ユーザ入力などの緊急度の高い更新を優先して処理したり、不要になった作業を中止したりすることも可能となります。

また、Fiber では内部で優先度を管理するための「Lanes (レーン)」と呼ばれる概念が導入されました。React が更新の優先度を管理するための仕組みであり、異なる優先度を持つ更新を同時に処理することができます。後ほど詳しく解説します。

# React における優先度の扱い

React では、優先度を「Lanes (レーン)」と呼ばれる概念で管理しています。
内部で 32 ビットのビットマスクとして定義されており、各ビットが異なる優先度を表現します。
この表現を利用することで、タスクについてあたかも「車線 (レーン)」を分けて走る車のように、優先度に応じた分け方を行うことができるのです。

タスクによって優先度が異なり、例えばユーザの入力に対する更新は高い優先度を持ち、アニメーションや非同期処理に対する更新は低い優先度を持つことが一般的です。
二進数で表現され、数値が小さいほど優先度が高いとされます。

二進数で表現することのメリットとして、二進数で OR 演算を行うことで複数の優先度を同時に表現できることが挙げられます。フラグをそれぞれ変数で持たせるより二進数で管理する方がメモリ効率が良くなるという決定があったのでしょう。
この優先度の概念は、React のレンダリングのスケジューリングにおいて重要な役割を果たします。是非覚えておいてください。

# トリガーフェーズ

# スケジューリングフェーズ

## 優先度付きキュー

# レンダーフェーズ

## 深さ優先探索

## 関数コンポーネントの実行

##

## フラグの設定

# コミットフェーズ

##

# フックの動作

# 今回解説をスキップしたところ

# 終わりに
