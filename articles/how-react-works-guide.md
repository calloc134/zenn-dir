---
title: "Reactの内部の仕組み読み解きガイド (執筆中)"
emoji: "⚛️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["React"]
published: true
---

# はじめに

こんにちは、calloc134 です。毎日「React なんもわからん」を繰り返していたところ、ソースコードを読み始めていました

React は今や、フロントエンド開発においてデファクトスタンダートなライブラリとなっています。
しかし、どのような考え方・仕組みで実装されているのか、気付かないうちに勘違いしている人も多いのではないでしょうか。
今回は、そんな React の内部の仕組みを、必要があればソースコードを参照しながら解説していきたいと思います。

なお、参考にするソースコードは React 18.2.0 のものを使用します。
当該バージョンは参考文献のバージョンと揃えるために選択しました。基本的な動作はおおよそ同じものと考えていますが、最新のバージョンにおける変更点があれば後ほどまとめて追記していきたいと思います。
加えて、クラスコンポーネントに関する内容は一切解説しない方針で進めていきます。ご了承ください。
また簡単のため、非同期で処理が行われる部分・処理が中断されると思われる部分についても解説を省略することがあります。

# 前提として

## React は何を成し遂げるもの？

React とは、UI を宣言的に記述するためのライブラリです。
宣言的とは、「どのように達成するか (How)」ではなく、「何を達成するか (What)」に焦点を当て、処理を記述することを意味します。
命令的 (Imperative) という言葉があります。こちらは従来のプログラミングスタイルで、どのように処理を行うかを詳細に記述することを指します。

![](/images/how-react-works-guide/2025-06-16-14-52-28.png)

この 2 つは何が違うのでしょうか？

例えば、白いキャンバスに四角形を描くことを考えてみましょう。

命令的なアプローチでは、以下のように UI を記述します。

- まずペンを下ろす
- 右に線をひく
- 下に線をひく
- 左に線をひく
- 上に線をひく

このような具合に、一つ一つの操作手順を細かく記述します。

![](/images/how-react-works-guide/2025-06-16-14-53-08.png)

対して宣言的なアプローチでは、

- キャンバス上に四角形を描く

というやりたいことを宣言するだけで、やりたいことが達成されます。魔法のようですね。

![](/images/how-react-works-guide/2025-06-16-14-54-25.png)

重要なのは、「どのように四角形を描くか」という How ではなく、「四角形を描く」という What=目的そのものに焦点を当てていることです。
目的のみを記述することで、実装の詳細をすべてライブラリが担当してくれるため、開発者は UI を記述する効率を大幅に向上させることができます。
このライブラリこそが、React というわけです。

## 宣言的 UI の実装

宣言的な UI を実装するために、React はどのようなアプローチをとっているのでしょうか？
React では、仮想 DOM (Virtual DOM) と呼ばれる概念を用いて UI の状態を管理します。

:::message
後述しますが、仮想 DOM という言葉は React ドキュメントでは使われておらず、不適切な表現であるという指摘があります。
このセクションでは簡単のために仮想 DOM という言葉を使いますが、正確には「React の内部で管理される状態」と考えてください。
:::

仮想 DOM とは、UI の状態を表現するための JavaScript オブジェクトのことです。React がレンダリングを行うたび、仮想 DOM オブジェクトが新しく作成されます。
続けて前回の仮想 DOM の状態と新規作成された仮想 DOM の状態を比較し、変更があった部分のみを実際の DOM に反映します。

具体的に例え話をしてみましょう。
仮想 DOM を下書き用紙、実際の DOM を本番のキャンバスと考えてください。

まずここに、タコのイラストがあるとします。このイラストについて、最後の足だけ上に上げて、手のようにしたいと思います。

![](/images/how-react-works-guide/2025-06-16-14-58-16.png)

これを命令的に行いたいとき、二通りの方法があります。

1 つ目は、イラストを一旦全部消して、最後の足を手のように描き直す方法です。

- イラストを全部消す
- 最後の足を手のようにし、手を上げたタコを描く

2 つ目は、イラストの一部を変更する方法です。

- 最後の足だけを消す
- 最後の足だけ、手のようにして上げたタコに変更する

![](/images/how-react-works-guide/2025-06-16-15-01-38.png)

この 2 つの方法はどちらも同じ結果を得ることができますが、2 つ目の方法はより効率的です。しかし 2 つ目の手法を自力で行うのは労力がかかります。

React であれば、仮想 DOM を用いて差分を検出し、変更箇所のみを実際の DOM に反映することで、2 つ目の方法を自動的に行うことができます。下書き用紙を使い、本番のキャンバスには原則として直接描かず、代わりに本番用のキャンバスへの描き込みを React におまかせする形ですすめます。

- 軽量な下書き用紙 (仮想 DOM) 上にタコのイラストを描く
- 新しく、軽量な下書き用紙 (仮想 DOM) 上に手を上げたタコのイラストを描く
- 2 つのキャンバスを比較し、差分を洗い出す (\*)
  - 今回は、最後の足のみ差異
- 実際のキャンバス (実際の DOM) 上のタコのイラストを、最後の足のみ手のように上げたタコに変更する (\*)

![](/images/how-react-works-guide/2025-06-16-15-12-20.png)
![](/images/how-react-works-guide/2025-06-16-15-12-31.png)

ここで(\*) の部分が、React が担ってくれる差分検出&適用の部分です。
ユーザはすべての見た目を描き直す必要がなくなり、効率的かつ宣言的に「手を上げたタコ」を描くことができます。

見た目が動的に変わる UI を実装する場合、宣言的に実装できるということは開発者の負担を大幅に軽減させることにつながるのです。

## React が関数型アプローチと言われる理由

React は、宣言的な UI の実装を行うために関数型プログラミングの考え方を取り入れています。
前提として、React のコンポーネントは現在の UI の状態を与えられたとき、そこから UI を導出するという性質を持っています。
数式的に表現すれば、

```
見た目 = f(状態)
```

という形になります。同じ状態が与えられたときに同じ見た目が導出されるという性質は、関数型プログラミングの特徴の一つです。

![](/images/how-react-works-guide/2025-06-16-15-26-32.png)

また、関数型アプローチといえばイミュータブルなデータ形式が特徴として挙げられます。React も同じく、UI をイミュータブルに記述していくことになります。
先程、二つの仮想 DOM の状態を比較して差分を検出すると説明しました。直接実際の DOM を書き換えるのではなく、仮想 DOM をまた新しく作成する形で UI を記述していきます。この仮想 DOM はその都度新しく作成されるため、関数型アプローチの特徴であるイミュータブルなデータ形式を持つことになります。
このイミュータブルな特性を利用することで、ユーザは DOM の状態をミュータブルにしなくて良くなり、予期しないバグを避けることができます。

![](/images/how-react-works-guide/2025-06-16-15-30-11.png)

この二つの事例より、React が関数型のアプローチを積極的に採用していることがわかります。

余談ですが、React のように「理想形のイミュータブルな記述 & フレームワークによる差分検出・現実世界への反映」を行う実装は宣言的なフレームワークでよく見られます。例として「kubernetes」というコンテナ宣言的管理ツールも同じようなアプローチをとっています。こちらも理想形を記述し、フレームワークが差分検出を行い、理想形になるまで実際の状態を変更していくというアプローチをとっています。

![](/images/how-react-works-guide/2025-06-16-15-34-20.png)

# React のレンダリング全体の流れ

では前提もできたところで、React のレンダリング全体の流れについて見ていくことにしましょう。
React のレンダリングは、主に 四つのフェーズに分かれています。

- トリガーフェーズ: レンダリングの開始
- スケジュールフェーズ: レンダリングの優先度を決定し、いい感じに計画立て
- レンダーフェーズ: 仮想 DOM の状態を更新し、差分を検出
- コミットフェーズ: 実際の UI (実際の DOM) に差分を反映

トリガーフェーズは、React のレンダリング作業を開始するきっかけとなるフェーズです。
スケジュールフェーズは、レンダリングの優先度などを参考にしながら、タスクをどのようなタイミングで実行すべきかなどを決定し、計画を立てるフェーズです。

レンダーフェーズでは、先程の例で挙げたように仮想 DOM の状態を更新し、差分を検出するフェーズです。この処理は中断可能になっており、React が適切なタイミングで中断・再開することができます。
コミットフェーズでは、レンダーフェーズで検出された差分を実際の 見た目となる実 DOM に反映するフェーズです。このフェーズは中断されることがなく、短い期間で確実に実行される必要があります。

![](/images/how-react-works-guide/2025-06-16-16-27-35.png)

この四つのフェーズを通して React は宣言的な UI の実装を効率的に行うことができます。
React 公式ドキュメントでは下の 2 つのフェーズのみ解説されています。四つのフェーズの定義については以下のドキュメントより引用しています。
https://jser.dev/2023-07-11-overall-of-react-internals

日本語訳はこちらを参照してください。
https://calloc134.github.io/how-react-works/docs/react-internals-deep-dive/overall-of-react-internals

# Fiber ノードの基本的なプロパティ

先程、React は仮想 DOM を利用して UI の状態を管理すると説明しました。この「仮想 DOM」という呼称についてですが、本質的な理解ではないことをここで明確にしておきます。

React が内部で管理しているのは、仮想 DOM ではなく「Fiber ノード」と呼ばれるオブジェクトを木構造とした状態、「Fiber ツリー」と呼ばれるものです。

:::details なぜ「仮想 DOM」ではないのか？

「仮想 DOM」という言葉はわかりやすい表現ですが、以下の問題点があります。

1. DOM 要素ではないノードの存在
   - React の Fiber ノードは、DOM 要素だけでなく関数コンポーネント等も表現する
   - したがって、仮想 **DOM** という表現は不適切
2. DOM の状態のみを表現しているわけではない
   - Fiber ノードは更新の優先度や副作用など、DOM と無関係の状態も多く保持している
   - したがって DOM のコピーではなく、UI の状態を表現する ノードのツリーという認識が好ましい

以上の理由により、React の内部で管理されているのは「Fiber ノード」と呼ばれるオブジェクトのツリー構造であり、仮想 DOM として表現されるものではありません。ただし呼称としては「仮想 DOM」が広く使われていることには変わりありませんし、それほどピントがズレている表現ではないかなというところも正直なところです。

https://scrapbox.io/fsubal/%E3%80%8C%E4%BB%AE%E6%83%B3DOM%E3%80%8D%E3%81%A8%E3%81%84%E3%81%86%E7%94%A8%E8%AA%9E%E3%82%92%E4%BD%BF%E3%82%8F%E3%81%AA%E3%81%84
:::

Fiber ノードは、React のコンポーネントの状態を表現するためのオブジェクトであり、以下のような情報を持っています。

:::details Fiber ノードの定義
https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactInternalTypes.js#L67
:::

## 基本的なプロパティ

- key: コンポーネントの一意な識別子
- tag: コンポーネントのタイプ
- stateNode: コンポーネントのインスタンス (実際に対応する DOM ノードなど)

### key

key は開発者もおなじみのプロパティです。コンポーネントの一意な識別子として利用されており、差分検出の際に効率化を図るために使用されます。

リストとなっている要素をレンダリングするとき、`key`が指定されていない場合は後述のインデックス番号や型情報のみで判定することになりますが、誤検知や再生成の元となり、最悪の場合では計算量が O(n^2)となる可能性があります。
`key`を適切に指定することで走査が一度のループで済むようになり、計算量が O(n)としてパフォーマンスが向上します。

:::message
差分を最小限にするアルゴリズムについては研究されていますが、理論的に計算量が O(N^3)の複雑度を持ちます。
React はこれをトレードオフであると結論付け、`key`のようなヒントを与えることで計算量を O(N)に抑えられるようなアルゴリズムを採用した、という経緯があります。
https://legacy.reactjs.org/docs/reconciliation.html#motivation
:::

### tag

tag は Fiber ノードの種類を表現するプロパティとなっており、FunctionComponent (関数コンポーネント)、HostComponent (DOM 要素) などさまざまなタイプのコンポーネントを識別するために使用されます。内部的には整数値となっています。具体的な値は以下の通りです。

| tag の値          | 説明                                    |
| ----------------- | --------------------------------------- |
| FunctionComponent | 関数コンポーネント                      |
| ClassComponent    | クラスコンポーネント                    |
| HostComponent     | DOM 要素 (例: div, span など)           |
| HostText          | テキストノード (例: "Hello, World!")    |
| Fragment          | `<></>` で表現されるようなフラグメント  |
| ContextProvider   | コンテキストプロバイダー                |
| SuspenseComponent | Suspense コンポーネント                 |
| MemoComponent     | React.memo でラップされたコンポーネント |

### stateNode

stateNode はレンダリングの結果であるインスタンスを格納するためのプロパティです。
関数コンポーネントの場合はレンダリングの実態がないため null になります。一方 HostComponent (DOM 要素) や HostText (テキストノード)の場合、レンダリングの結果生成された DOM ノードが格納されることになります。

## Fiber ツリーにおける参照のプロパティ

- child: 第一子に当たる Fiber ノード
- sibling: 同じ親を持つ次の兄弟の Fiber ノード
- return: 親に当たる Fiber ノード
- index: 同じ親に属する子ノードの中でのインデックス
- alternate: 2 つある Fiber ノードのうち、相対するもう一方のノードへの参照 (ない場合は null)

### child, sibling, return

Fiber ノードは、木構造で表現されており、各ノードは親子関係や兄弟関係を持っています。
child は、現在の Fiber ノードに対する子ノードを指します。第一子のノードのみを指すことに注意してください。
return は、現在の Fiber ノードに対する親ノードを指します。
sibling は、同じ親を持ち、次に当たる兄弟ノードを指します。sibling を辿っていくことにより、共通の親を持つ兄弟ノードが連結リストのように繋がっていることがわかります。

![](/images/how-react-works-guide/2025-06-16-16-56-25.png)

#### index

index は、同じ親を持つ子ノードの中でのインデックスを表します。例えば子要素が

```jsx
<div>
  <a />
  <b />
  <c />
</div>
```

と与えられた場合、`<a />` の index は 0、`<b />` の index は 1、`<c />` の index は 2 となります。
開発者が key の指定を行わなかった場合、React はこの index を利用して差分検出を行います。この場合、少し非効率的な方法になります。

### alternate

alternate は、現在の Fiber ノードの相対するもう一方のノードへの参照です。React のレンダリングは 2 つの Fiber ツリー(仮想 DOM)を持ちながら進行していきますが、このときにもう片方のツリーで自身と同じ存在に対応するノードを指します。パラレルワールドの自分と繋がるためのポインタのようなものです。
初回のレンダリングでは current に対応するノードがないため alternate は null となりますが、更新が発生すると新しい Fiber ノードと古い Fiber ノードが互いに互いを alternate として参照し合うようになります。

![](/images/how-react-works-guide/2025-06-16-17-05-29.png)

## 更新の際に指標となるプロパティ

- lanes: 更新に対応する優先度 (Lanes)
- childLanes: 子コンポーネントの優先度を集約した優先度
- flags: 更新に関するフラグ (例: 属性の追加や削除など)
- subtreeFlags: 子から渡されたフラグを集約したフラグ
- deletions: 削除されるべき Fiber ノードのリスト

### lanes, childLanes

lanes は、更新に対応する優先度を表すプロパティです。React は更新の優先度を管理するために Lanes (レーン) と呼ばれる概念を導入しています。Lanes は、更新の優先度を表現するためのビットマスクであり、二進数で表現されるため異なる優先度もマージして表現することができます。詳細は後述します。
childLanes は、子や孫全体に対してレーンをマージしたプロパティです。
直下の child のレーン、更にその childLanes を OR 演算でマージしたものがここに格納されます。

### flags, subtreeFlags

flags は更新に関するフラグを表現するプロパティです。現在の Fiber ノードに関する変更をフラグの形式で表現します。
差分検出の段階で判定された変更点について、対応するフラグを立てる形になります。

| フラグの値 | 説明                                   |
| ---------- | -------------------------------------- |
| Placement  | 新しい要素が追加されたことを示すフラグ |
| Update     | 既存の要素が更新されたことを示すフラグ |
| Deletion   | 要素が削除されたことを示すフラグ       |
| Ref        | Ref が更新されたことを示すフラグ       |

フラグはレーンと同じくすべてビットマスクの二進数で表現されており、レーンと同じく複数のフラグを OR 演算で組み合わせて表現することができます。
subtreeFlags は、子ノードから渡されたフラグを集約したプロパティです。子ノードの flags を OR 演算でマージしたものがここに格納されます。

### deletions

deletions は、削除されるべき Fiber ノードのリストを保持するプロパティです。実際は Fiber ノードの配列となっており、差分検出の際に追加され実際の DOM に反映する際に参照されます。

# レンダリングにおける Fiber ツリーの構築と交換の流れ

初回レンダリングにおいて、Fiber ツリーでは下準備が行われます。
まず`createRoot`関数の内部で、Fiber ツリーの上に存在し Fiber ツリーを管理するための Fiber ノードである`FiberRootNode`が作成されます。このノードは Fiber ツリーを管理するノードであるため、どのような場合でも変わらず Fiber ツリーの一番根本に位置し続けます。

![](/images/how-react-works-guide/2025-06-16-17-28-09.png)

:::details `FiberRootNode`の作成部分の実装
https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactFiberRoot.new.js#L134
:::

ここで、`FiberRootNode`以下に連なる Fiber ツリーの構造について説明します。
Fiber ツリーの根本ノードは、`HostRoot`と呼ばれるタグを持つ Fiber ノードです。このコードが child プロパティで子コードを参照する形で Fiber ツリーが構築されます。

先程仮想 DOM の解説を行った際に、「一つ前のレンダリングで作成した仮想 DOM」と「新しくレンダリングで作成する最中の仮想 DOM」の二つのツリーが存在すると説明しました。これらの二つの仮想 DOM が、それぞれ`current`と`workInProgress`という Fiber ツリーに相当します。

![](/images/how-react-works-guide/2025-06-16-17-39-43.png)

`current`ツリーは現在表示されている UI 状態を表現する Fiber ツリーであり、「一つ前のレンダリングで作成した仮想 DOM」に相当します。
`FiberRootNode` の`current`プロパティにおいて、この`current`ツリーを参照しています。
`workInProgress`ツリーは、現在のレンダリングで作成されている Fiber ツリーであり、「新しくレンダリングで作成する最中の仮想 DOM」に相当します。`FiberRootNode` に該当するプロパティは存在しませんが、レンダリングの処理中に変数として存在します。

レンダーフェーズで`workInProgress`を構築し終わった後、コミットフェーズで`workInProgress`の内容を実 DOM に適用し終わると、`current`プロパティの参照先を`workInProgress`Fiber ツリーの根本に当たる Fiber ノードに切り替えます。
したがってその特性上、current プロパティの Fiber ツリーの内容は常に実 DOM の UI と一致しています。

![](/images/how-react-works-guide/2025-06-16-17-47-26.png)

余談ですが初回レンダリング時には実 DOM は存在しないため、current プロパティ 以下のツリーは存在するものの、子ノードは存在しない状態となります。

また、切り替えが終わったあとも昔の`current`ツリーはメモリ上に残り続けます。これは React がオブジェクトを再生成するためのコストを避けるための工夫となっています。
次のレンダリングでできるだけオブジェクトをリサイクルすることで新しい Fiber ノードを作成するコストを削減し、パフォーマンスを向上させることができます。

# React における優先度の概念、レーン

React では、優先度を「Lanes (レーン)」と呼ばれる概念で管理しています。
内部で 32 ビットのビットマスクとして定義されており、各ビットが異なる優先度を表現します。
この表現を利用することで、タスクについてあたかも「車線 (レーン)」を分けて走る車のように、優先度に応じた分け方を行うことができるのです。

タスクによって優先度が異なり、例えばユーザの入力に対する更新は高い優先度を持ち、アニメーションや非同期処理に対する更新は低い優先度を持つことが一般的です。
二進数で表現され、ビット位置が低い、つまりビットが右側にあるほど優先度が高いことを意味します。

二進数で表現することのメリットとして、二進数で OR 演算を行うことで複数の優先度を同時に表現できることが挙げられます。フラグをそれぞれ変数で持たせるより二進数で管理する方がメモリ効率が良くなるという決定があったのでしょう。
この優先度の概念は、React のレンダリングのスケジューリングにおいて重要な役割を果たします。是非覚えておいてください。

:::details レーンの定義
https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactFiberLane.new.js#L36
:::

# React のレンダリング手法の歴史

レンダリング手法の歴史についても触れておきましょう。
React のレンダリング手法は、バージョン 15 から 16 にかけて大きく変更されました。

バージョン 15 までは、React は「スタックベースのレンダリング手法」を採用していました。
簡単に解説すると、それぞれのコンポーネント毎にインスタンスを生成し、それを単一のツリー構造で管理していました。
レンダリングの際、ツリーの根本から末端までを再帰的に処理し、子ツリーまですべてのコンポーネントを一度にレンダリングしていました。この過程で JavaScript のコールスタックを大量に消費し、UI が固まるようなパフォーマンスの問題が発生していました。

バージョン 16 からは、React は「Fiber ベースのレンダリング手法」を採用しました。
Fiber ベースのレンダリング手法では、各コンポーネントを「Fiber ノード」として表現し、Fiber ノードが他の Fiber ノードを参照する形でツリー構造を形成します。
この構造にすることによるメリットとして、スタックベースではすべてのツリーを走査し終わるまで処理が止まってしまうのに対し、Fiber ベースではレンダリングの作業を分割し、、レンダーの処理の途中で一時停止・再開・中止が可能になります。

レンダリングの作業を分割する単位は「Unit of Work (作業単位)」と呼ばれており、これを小さなチャンクとしてブラウザのイベントループや一定時間内に合わせてそのチャンクを徐々に実行することでスムーズな UI 描画が実現できるようになりました。
またこの変更により、ユーザ入力などの緊急度の高い更新を優先して処理したり、不要になった作業を中止したりすることも可能となります。

また前述のとおり、Fiber では内部で優先度を管理するための「Lanes (レーン)」と呼ばれる概念が導入されました。React が更新の優先度を管理するための仕組みであり、異なる優先度を持つ更新を同時に処理することができます。

# Fiber ノードのその他のプロパティ

先程解説しきれなかった Fiber ノードのプロパティについて、以下にまとめます。具体的なレンダリングの流れについて登場するプロパティもあるため、必要があれば後で見直すことをおすすめします。

## コンポーネントに関するプロパティ

- ref: 開発者が Ref で渡したオブジェクト等

### ref

ref は、開発者が ref 属性を利用し、コンポーネントの実際のインスタンスにアクセスするためのプロパティです。レンダリングが終わりマウントされた後、`ref.current` に stateNode の値が設定されます。この`ref.current`を通し、開発者はコンポーネントのインスタンス(DOM 要素など)に直接アクセスすることができます。実際に利用する場合は`useRef`フックとの併用が一般的です。後ほど解説を行います。

その特性上から関数型コンポーネントでは動作しませんが、`forwardRef` を利用することで関数型コンポーネントでも ref を利用することができます。詳細については解説を省きますが、興味があれば React のドキュメントを参照してください。

## レンダリングに関するプロパティ

- memoizedProps: 前回のレンダリングで適用された Props
- pendingProps: 次のレンダリングで適用される Props
- memoizedState: 前回のレンダリングで適用された状態
- dependencies: フックの依存関係を表すオブジェクト (useContext などでコンテキストに依存している場合など)

### memoizedProps, pendingProps

memoizedProps は、前回のレンダリングで適用された Props を保持するプロパティです。React はここに前回のレンダリングで適用された Props を保持し、次のレンダリングで新しい Props と比較し、Props に変更がない場合には再レンダリングを避けるような挙動をとることで、処理の効率化を図ります。
一方、 pendingProps は、現在のレンダリング (新たなレンダリング)で利用される Props を保持するプロパティです。レンダリングの開始時点で親から渡された新しい Props がここに格納されます。

### memoizedState

memoizedState は、前回のレンダリングで導出し適用されたステートを保持するプロパティです。useState フック等の状態管理フックを利用している場合、前回のレンダリングで適用された状態がここに格納されます。
この memoizedState の値が変わらない場合、ステートの変更がないと判断され、再レンダリングを避けることができます。
memoizedState は`any`型を持つため、任意の値を格納することができます。実際の実装ではフックオブジェクトの連結リストがここに格納されることになります。詳細は後述します。

### dependencies

フックの依存関係をまとめたオブジェクトです。
useContext フックなど、コンテキストに依存している場合に利用されます。

# トリガーフェーズ

では、React のレンダリングの最初のフェーズであるトリガーフェーズについて解説します。

その前に、React ではタスクをどのように管理しているのかについて、タスクキューの概念を理解しておく必要があります。React ではタスクを優先度付きキュー (Priority Queue) として管理しています。競技プログラミングの要素が入ってきますが、馴染みのない方もいるかもしれませんので簡単に説明します。

## 優先度付きキュー

優先度付きキューとは、それぞれの要素に優先度をもたせ、優先度の高い要素を効率的に取り出せるよう設計されたデータ構造のことです。この実装として、バイナリヒープ (Binary Heap) がよく利用されます。
https://ja.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E3%83%92%E3%83%BC%E3%83%97
詳しい実装は省略しますが、優先度付きキューは以下のような特性を持っています。

- 末尾に新しい要素を追加することができる
- 要素について、優先度が高いものが優先的に取り出される

![](/images/how-react-works-guide/2025-06-16-18-24-46.png)

React では、まさにこの優先度付きキューを利用してレンダリングのタスクを管理しています。

## タスクキューの構造

React のタスクキューには二種類が存在し、それぞれ異なる目的で使用されます。

- `taskQueue`: すぐ実行されるようなタスクを管理するキュー
- `timerQueue`: 将来の実行を予定しているタスクを管理するキュー

二つのキューに違いはありますが、基本的な構造は同じと考え、抽象化して説明します。

`scheduleCallback`というメソッド内部で実際にタスクをキューに登録する処理が行われます。この内部でタスクオブジェクトが生成され、タスクが優先度付きキューに登録されます。

:::details タスク作成の実装
https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/scheduler/src/forks/Scheduler.js#L345
:::

React はタスクをキューに登録する際に、優先度(レーン)からスケジューリング優先度を導出します。
更に、スケジューリング優先度に応じてタイムアウト値というものを設定します。これはミリ秒で表現され、最大遅延時間とも表現されます。要するにタスクをどれだけ後回しにしていいかという値です。
このタイムアウト値の計算を行い、id やコールバック関数の用意を済ませてタスクオブジェクトを生成した後、タスクを優先度付きキューに登録します。
この際、ソートに利用するキーとして、`taskQueue`の場合はタスクの開始予定時刻(`startTime`)を、`timerQueue`の場合はタスクの期限切れ時刻(`expirationTime`、つまり開始予定時刻 + タイムアウト値)を利用します。

:::details タスク登録の実装
https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/scheduler/src/forks/Scheduler.js#L343
:::

ここからは次のスケジュールフェーズへと移行します。

# スケジュールフェーズ

このフェーズでは、React がレンダリングの計画を立て、それを実行するための準備・用意を行います。主に`workLoop`と呼ばれるループで構成されており、React がタスクを処理するためのメインのループとなります。スケジューリングを行うにあたり、一つのタスクの持ち時間であるタイムスライス時間が設定されており、急ぎであれば 5 ミリ秒、急ぎでなければ 25 ミリ秒といった形で設定されます。

ループ内部では`peek`メソッドを用いて一番上のタスクを閲覧し、処理を行うかを判断します。
タスクにまだ期限の余裕があり、かつ現在の持ち時間である 5 ミリ秒のタイムスライスを使い切った場合、タスクを後回しにすることにしてタスクを取り出さずにループを継続します。
そうでない場合、`pop`メソッドでタスクを取り出してタスクの処理を行います。具体的には、タスクのプロパティに付属するコールバック関数を実行することになります。
この処理の結果またタスクが発生するようであれば、再度タスクをキューに登録し、ループを繰り返します。

:::details スケジュールフェーズの実装
https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/scheduler/src/forks/Scheduler.js#L189
:::

このコールバック関数が実行されることで、React のレンダーフェーズが開始されます。

# レンダーフェーズ

ここから、React のレンダリングのメイン部分であるレンダーフェーズについて解説していきます。ここで、コンポーネントのレンダリングを実際に行いながら差分検知を行います。なお、React では差分検知のことを「Reconciliation (リコンシリエーション)」と呼んでいます。

レンダーの具体的な処理は、`performUnitOfWork`関数の中で行われます。

## レンダーフェーズにおけるループ

performUnitOfWork 関数で、ループを利用しながらそれぞれの Fiber ノードを処理していきます。

```ts
while (workInProgress !== null) {
  performUnitOfWork(workInProgress);
}
```

```ts
while (workInProgress !== null || shouldYield()) {
  performUnitOfWork(workInProgress);
}
```

初回レンダリングと再レンダリングで状況は変わりますが、workInProgress というのは単に「現在処理すべき Fiber ノード」を指す変数です。すべて処理が終わると`null`となるため、ループは終了します。
加えて後者の場合、レンダー処理を中断すべきかどうかを判断するフラグも同時に確認します。このようにすることでスケジューラの指示のとおりにレンダーフェーズを中断することができます。

:::details performUnitOfWork の実装
https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1741

https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1829
:::

performUnitOfWork 関数内部では、beginWork 関数と completeWork 関数の二つの関数が呼び出されます。処理の流れは一定のアルゴリズムに従っており、深さ優先探索のような形で Fiber ツリーを探索しながら処理を行います。このアルゴリズムは後ほど解説を行います。

beginWork 関数はレンダリングと差分検知、completeWork は後処理を行う立ち位置となります。

:::details performUnitOfWork の処理の流れ
https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1741
:::

ではまず、beginWork 関数について見ていきましょう。

:::details beginWork 関数の実装
https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3685
:::

## beginWork 関数: 更新の検出と bailout の試行

まず最初に、更新を検出するための処理が行われます。

前回のレンダリングで渡された Props と今回のレンダリングで渡された Props について、同じオブジェクトを参照しているかを確認します。一致していなければ更新されたと判断され、更新が必要であることを記録します。処理を簡単にするため浅い比較を行っています。また、コンテキストの変更があるか、状態更新があるか、その他更新が必要かどうかを判断するための処理が行われます。

最終的に更新が必要でないと判断された場合、更新をスキップするような機構が働きます。この機構のことを「bailout (ベイルアウト)」と呼びます。
bailout の条件を満たす場合、必要最低限のノードのコピーを行った上で Fiber ノードの計算を丸ごとスキップします。具体的な処理は複雑であるためここでは詳しく解説しませんが、処理を最適化する機構があるということだけ覚えておいてください。

## beginWork 関数: コンポーネントに応じたレンダリング処理

次に、大きな Switch 文で Fiber ノードの tag の値に応じた処理を行います。ここでは関数コンポーネント (FunctionComponent) と DOM 要素 (HostComponent) に絞って処理を解説します。

関数コンポーネントの場合のおおまかな流れを解説します。
最初に、コンポーネントを実行するための関数`renderWithHooks`を用いて、フックを処理しつつコンポーネントのレンダリングを行います。ここで初めて、関数コンポーネントが実行されるというわけです。

関数コンポーネントの定義は関数を実行して JSX 要素を返すというものです。つまり`ReactNode`型に含まれるいずれの要素を返す関数となります。したがって、`renderWithHooks`関数の戻り値も`ReactNode`型のいずれかの要素となります。この戻り値が`nextChildren`として、後のリコンシリエーションに利用されます。

:::message
`renderWithHooks`内部でどのようにフックを処理しているかの詳細は、後ほど専用のセクションで詳しく解説します。
:::

`ReactNode`型がどのような型であるかをざっくりおさらいしておきましょう。以下のいずれかのような型を持ちます。

- ReactElement: 通常の React 要素
- ReactText: テキストノード (文字列や数値)
- ReactFragment: 複数の要素をまとめるためのフラグメント

その他 ReactPortal やコンテキストに関連する型もありますが、省略します。

:::details ReactNode 型の定義
https://github.com/facebook/react/blob/v18.2.0/packages/shared/ReactTypes.js
:::

更に最適化のため、関数コンポーネント特有の bailout 処理を行います。条件は以下のとおりです。

- 初回レンダリングでなく、前回の Fiber ツリーが存在している
- フックやコンポーネントの Props が変更されていない

この条件が満たされると関数コンポーネントに変更がないと判断され、フックの再評価を含めた以後の再計算をスキップします。

その後、差分検出処理(リコンシリエーション)に移行します。`reconcileChildren`関数を用いてリコンシリエーションを行います。
関数に与える引数はおよそ次のとおりです。

- `current`: 現在の Fiber ツリーのノード
- `workInProgress`: 現在のレンダリングで作成される 予定の Fiber ツリーのノード
- `nextChildren`: 関数コンポーネントの実行結果である子コンポーネントの JSX 要素
- `renderLanes`: レーン (優先度) の値

リコンシリエーション処理の詳細は後ほど解説します。

:::details updateFunctionComponent 関数の実装
https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L951
:::

次に、DOM 要素の場合の処理を見ていきます。
まず適切な最適化処理を行った後、Fiber ノードが ref プロパティを持っている場合は今後実行されるコミットフェーズにおいて`ref.current`が更新されるよう、マークをしておきます。
その後、関数コンポーネントと同じく`reconcileChildren`関数を用いて子コンポーネントのリコンシリエーションを行います。

引数は関数コンポーネントと同じく以下のとおりです。

- `current`: 現在の Fiber ツリーのノード
- `workInProgress`: 現在のレンダリングで作成される予定の Fiber ツリーのノード
- `nextChildren`: DOM 要素の子コンポーネントの JSX 要素 (存在していれば)
- `renderLanes`: レーン (優先度) の値

HostComponent の場合も関数コンポーネントと同様に`nextChildren`が ReactNode 型のオブジェクトとなります。

:::message
余談ですが、`<div> Hello World </div>`のようにテキストコンテンツのみ存在する場合は 最適化を行うため null となります。
:::

:::details updateHostComponent 関数の実装
https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1426
:::

## beginWork 関数: 差分検知 (リコンシリエーション) 処理

`reconcileChildren`関数は、子コンポーネントのリコンシリエーションを行うための関数です。
リコンシリエーションとは、前回のレンダリングと今回のレンダリングでの差分を検出し、フラグをつけていくような処理を指します。
仕組みは複雑ですが、ざっくりと解説していきたいと思います。

なお、`reconcileChildren`の取る引数を先程解説しましたが、差分検出のための比較対象は`current.child`と`nextChildren`となります。つまり、既存の Fiber ノードと新しい子コンポーネントの JSX 要素を比較し、差分を検出していくことになります。新しい Fiber ノードは差分検出の後に作成されるものですので、`workInProgress.child`との比較をしているわけではないことに注意してください。

### 共通処理部分

リコンシリエーション処理は`reconcileChildFibers`関数で行われます(React v18.2 の場合。最新バージョンでは変更あり)。
この関数ではまず共通処理が実行されます。先程`nextChildren`だったものが`newChild`という引数で渡されています。
`newChild`は`ReactNode`型をもつオブジェクトなので、どのような特性かによって処理を分岐させます。

場合分けのケースはおよそ以下のとおりです。

1. 最上位が`<></>`のようなフラグメントであり、key が指定されていない場合
2. オブジェクト型の場合
   a. 単一要素の場合
   b. Portal の場合
   c. 配列型の場合
   d. 配列の場合
   e. イテラブルの場合
3. テキストや数値の場合
4. null または undefined の場合

主要ケースに絞って解説します。

#### フラグメントの場合

`<></>`のようなフラグメントかつ key が指定されていない場合、フラグメントの Fiber ノードを作成するのは非効率的です。そのため、フラグメントの内部の要素を配列として認識します。

つまり、

```tsx
return (
  <>
    <div> Hello </div>
    <span> World </span>
  </>
);
```

というコードは、以下のように解釈されます。

```tsx
return [<div> Hello </div>, <span> World </span>];
```

このように、フラグメントを最上位に付けてもパフォーマンスに影響が出ないように配慮されています。

#### オブジェクト型・単一要素の場合

通常の単一要素の場合の差分検出についてみていきます。

まず key の一致を判定し、一致しない場合は既存の子ノードは不要として認識され、子ノードに対して削除フラグを適用します。
key が一致している場合、型の判定に進みます。型が一致している場合は既存の Fiber を再利用し、型が一致しない場合は Placement フラグを立てた上で新しい Fiber ノードを作成する処理を行います。

既存の Fiber ノードが存在しない場合または key が一致しない場合は、新しい Fiber ノードを作成し Placement フラグを付与します。

:::details 新規 Fiber ノードの作成部分の実装
https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactChildFiber.new.js#L359
:::

#### オブジェクト型・配列の場合

配列となった要素に対しては、位置ベースのマッチングと key ベースのマッチングという二段階方式で差分検出を行います。

##### 位置ベースのマッチング

第一段階のマッチングは位置ベースのマッチングです。
位置ベースのマッチングでは、既存の Fiber ノードと新しい子要素の配列を比較し、同じ位置同士でキーと型が一致していることを判定していきます。
すべて一致した場合、すべての Fiber がそのまま再利用され、そこでマッチングが終了します。一方、一つでも不一致の要素が存在した段階で位置ベースのマッチングは終了します。

もし Fiber ノードの方にマッチング不成立となったノードがあれば、残った Fiber ノードすべてに削除フラグを付与します。
もし要素の方にマッチング不成立となった要素があれば、残った要素すべてに対して新しい Fiber ノードを作成し Placement フラグを付与します。

双方に対してマッチング不成立の対象が存在する場合、第二段階である key ベースのマッチングに移行します。

##### key ベースのマッチング

第二段階のマッチングは key ベースのマッチングです。

キーベースのマッチングでは、連想配列を使ってマッチングを行います。
キーが存在する場合はそれを連想配列のキーとして、存在しない場合はインデックスをキーとして利用します。これにより、O(1)の計算量でマッチングを行うことができます。
マッチした場合は Fiber ノードを再利用します。

### 初回レンダリングの場合

初回レンダリングの場合、内部で`mountChildFibers`関数が呼び出されます。
初回レンダリングなので、すべてのノードに「新規作成 (Placement)」フラグを立てるのも非効率的です。そのため、ノードには基本的にフラグを立てずに進行していきます。また、削除されるべきノードも存在しないため、削除の処理は行われません。

### 二回目以降のレンダリングの場合

(TODO)

:::details reconcileChildren の実装
https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactChildFiber.new.js#L1245
:::

## completeWork 関数: 後処理

completeWork 関数では、beginWork 関数で行われた処理の後処理を行います。関数コンポーネントの場合、ここでの処理はほぼ行われません。
一方 DOM 要素の場合はインスタンスの作成などの後処理が行われます。

## beginWork/completeWork の流れと深さ優先探索

# コミットフェーズ

##

# フックの動作

# 今回解説をスキップしたところ

# 終わりに
