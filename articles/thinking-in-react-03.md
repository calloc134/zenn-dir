---
title: "再考React - 第3回 useEffectを通して考える副作用の記述"
emoji: "⚛️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react", "frontend", "javascript", "typescript"]
published: false
---

# はじめに

こんにちは。かろっく@calloc134 です。

前回は、React のコア思想である純粋関数性について解説しました。
関数コンポーネントは純粋関数であることが推奨され、
副作用を含めるべきではないことを学びました。

一方、実際のアプリケーションを開発する場合、外部システムとのやり取りというのは必要不可欠です。
したがって開発者は、副作用を適切な場所に適切な方法で記述する必要があります。

今回は、React 特有の思想のうち、副作用の記述に絞って解説を行います。

# 純粋関数性を保ちながら副作用を外部に逃がす

前述のとおり、React は `f(...) = React 要素` という純粋関数性を保つことを前提に設計されています。

そのため、React 要素を生成する関数コンポーネントには、
React 管轄外となる外部システムとのやり取り（副作用）の記述を含めることができません。

そのため React は、
**関数コンポーネント実行の「外部」で副作用の実行を設定する手段を提供しています。**

副作用の記法の解説をする前に、重要な仕組みである useEffect について解説します。

# 前提知識: useEffect

## useEffect の技術的な詳細

まずは useEffect の技術的な詳細を解説します。

useEffect は、技術的に見れば
**React 要素から生成された変更が実 DOM に反映された後に、**
**任意の処理を差し込むことができる仕組み**のことです。

以下の 2 つの処理が差し込めます。

**①. セットアップ処理**
実 DOM ノードが反映された後（マウント直後）に実行される処理

**②. クリーンアップ処理**
実 DOM ノードが破棄される際（アンマウント時）に実行される処理

```tsx
useEffect(() => {
  // セットアップ処理
  console.log("マウントされました");

  return () => {
    // クリーンアップ処理
    console.log("アンマウントされます");
  };
}, []);
```

この場合の処理の流れは以下の通りです。

1. コンポーネントがマウントされるときにセットアップ処理が実行される
2. コンポーネントがアンマウントされるときにクリーンアップ処理が実行される

## 依存配列

useEffectでは、**依存配列**というものを指定することもできます。

依存配列とは、副作用処理が依存している入力値のことです。
副作用処理が依存している値とは、つまり
値の変化が **副作用処理の再実行のトリガとなる値**のことです。

依存配列には、状態群（state, props, context）や状態群から導出した値など、
**React 管轄内の値のみ**を含める必要があります。

依存配列を指定すると、処理が以下のようになります。

**①. セットアップ処理**

- 実 DOM ノードが反映された後（マウント直後）に実行される（従来と同じ）
- 依存配列が変化したタイミングで、前回のクリーンアップ処理の後に実行される

**②. クリーンアップ処理**

- 実 DOM ノードが破棄される際（アンマウント時）に実行される（従来と同じ）
- 依存配列が変化したタイミングで、次回のセットアップ処理の前に実行される

```tsx
useEffect(() => {
  console.log(`userId が ${userId} に変化しました`);

  return () => {
    console.log(`userId ${userId} のクリーンアップ`);
  };
}, [userId]);
```

この場合の処理の流れは以下の通りです。

1. コンポーネントがマウントされるときにセットアップ処理が実行される
2. 依存配列の値が変化したタイミングで、前回のクリーンアップ処理が実行される
3. 続けて、今回のセットアップ処理が実行される
4. コンポーネントがアンマウントされるときにクリーンアップ処理が実行される

## 注意点: 余計な依存関係を増やさない

useEffect の内部でのみ利用する変数・関数は、
できるだけ useEffect の内部で定義するようにしましょう。

これにより、依存配列に含めるべき変数・関数の数を減らすことができます。
また、定数であればそもそも関数コンポーネントの外部で定義してしまうのも手です。

```tsx
// ❌ 悪い例：外部で定義した関数を依存配列に含める
const handleResize = () => {
  console.log(window.innerWidth);
};

useEffect(() => {
  window.addEventListener("resize", handleResize);
  return () => window.removeEventListener("resize", handleResize);
}, [handleResize]); // handleResize が依存配列に含まれてしまう

// ✅ 良い例：useEffect 内部で定義する
useEffect(() => {
  const handleResize = () => {
    console.log(window.innerWidth);
  };

  window.addEventListener("resize", handleResize);
  return () => window.removeEventListener("resize", handleResize);
}, []); // 依存配列が空になる
```

:::message
**useEffect の依存配列は React 管轄内の値のみを含める必要がある**

先程、依存配列には、状態群（state, props, context）や状態群から導出した値など、
**React 管轄内の値のみ**を含める必要があると解説しました。
これについて、更に詳しく捕捉します。

useEffect の依存配列は「どのような値でも変化を検知できる」わけではありません。

別の言い方をすると、RxJS のように
**値に購読を設定し、値の変化を検知して何らかの処理を行う**
という仕組みではないということです。

そのため、React 外部の値を依存配列に含めても変化を検知できません。

仕組みは以下の通りです。

React の仕組みとして、
状態群（state, props, context）の変化に合わせて
関数コンポーネントを再実行することは前述の通りです。

関数コンポーネントが再実行されたとき、
前回の実行時と今回の実行時の依存配列内の値をそれぞれ比較し、
いずれかの値が変化していた場合にのみ useEffect 内の処理を再実行する、
という仕組みとなっています。

そのため、依存配列に React 管轄外である外部システムの値を含めたとしても、
React に外部システムの値の変化を検知する仕組みがないため、再実行がトリガされません。

そのため、依存配列には React 管轄内の値のみを含める必要があるのです。
:::

useEffect の技術的な側面は以上です。
しかし、技術的な側面だけ見て useEffect を利用すると、
React の設計思想に反した使い方をしてしまう可能性が高いです。

# 副作用の持つ特性

副作用が React 管轄外のシステムとのやり取りであることは前述の通りです。

ここで、副作用についてもう少し深く考えてみましょう。

すべての副作用は、**何かの事象に反応して発生するトリガ処理**とみなすことができます。

- React が実 DOM を反映した後・破棄した後をトリガとして発生する副作用
- ユーザが意図を持って行った操作をトリガとして発生する副作用
- React の状態群（state, props, context）や状態群から導出した値について
  値が変化したことをトリガとして発生する副作用

このように、副作用はどれも
**何かの事象に反応して発生するトリガ処理**とみなすことができます。

# React における副作用の記述

React において 典型的な副作用の記述を区分してみると、
いくつかのパターンに区分することができます。

1. **React が DOM ノードを反映・破棄したタイミングで**
   **外部のシステムを初期化・破棄する副作用**
2. **React 管轄内の値に基づいて、外部システムにその値を反映する副作用**
3. **何かのイベントに応じて実行される副作用**

これらについて、それぞれのトリガが何であるか、どのように実装するべきかを解説します。

## パターン 1: <br />React が DOM ノードを反映・破棄したタイミングでの副作用

何かの事象 = **React が DOM ノードを反映・破棄したという事象**に対するトリガといえます。

この場合は useEffect を利用して、セットアップ関数・クリーンアップ関数を定義します。

## パターン 2: <br />React 管轄内の値に基づいて外部システムに値を反映する副作用

React 管轄内の値 = 状態群（state, props, context）および状態群から派生させた値などです。

パターン 1 の事象に加え、
**React の管轄内の値が変化したという事象**に対するトリガが加わっているといえます。

この場合も useEffect を利用して、セットアップ関数・クリーンアップ関数を定義します。
更に、依存配列に React 管轄内の値を含めることで、
React 管轄内の値の変化をトリガとして副作用が実行されるようにします。

## パターン 3: 何かのイベントに応じて実行される副作用

何かの事象 = **ユーザが意図を持って行った操作**に対するトリガといえます。

この場合、イベントハンドラとしてコールバック関数を定義し、
その関数内に副作用処理を記述します。

以上の 3 つが、React における典型的な副作用処理のパターンと、
それぞれに対応する React が提供する副作用実行手段です。

# 各パターンの具体的な解説

ここから具体的な解説を行っていきます。

## パターン 1: <br />React が DOM ノードを反映・破棄したタイミングでの副作用

### 意図

DOM ノードが React によって画面に反映・破棄されたタイミングというのは、
React のコンポーネントの新規作成・破棄が実 DOM ノードに反映されたタイミングといえます。

DOM、つまり UIの反映という事象をトリガとして外部システムの初期化・破棄を行うことで、
**React 外部のシステムと React コンポーネントのライフサイクルを同期させる**
という意図を持ちます。

### 処理の流れ

1. セットアップ関数・クリーンアップ関数に
   セットアップ処理・クリーンアップ処理という副作用を記述する
2. useEffect へこれらの関数を渡す
3. React が DOM ノードを反映したタイミングで
   セットアップ関数が実行され、副作用が実行される
4. React が DOM ノードを破棄したタイミングで
   クリーンアップ関数が実行され、副作用が実行される

### 例: ネットワーク越しの外部サーバへの接続確立

```tsx
function ChatRoom({ roomId }: { roomId: string }) {
  useEffect(() => {
    // 初期化 = 外部サーバへの接続確立
    const connection = createConnection(roomId);
    connection.connect();

    return () => {
      // 破棄 = 外部サーバへの接続解除
      connection.close();
    };
  }, [roomId]);

  return <div>チャットルーム: {roomId}</div>;
}
```

処理の流れは以下の通りです。

1. コンポーネントがマウントされるときに接続を確立
2. コンポーネントがアンマウントされるときに接続を解除

### 例: React に対応していないコンポーネントライブラリの初期化・破棄

```tsx
function MapComponent() {
  const mapRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!mapRef.current) return;

    // 初期化 = コンポーネントライブラリの初期化
    const map = new ThirdPartyMap(mapRef.current, {
      center: [0, 0],
      zoom: 10,
    });

    return () => {
      // 破棄 = コンポーネントライブラリの破棄
      map.destroy();
    };
  }, []);

  return <div ref={mapRef} style={{ width: "100%", height: "400px" }} />;
}
```

useRef（後述）で 実際のDOM ノードを取得し、
そこに React に対応していないコンポーネントライブラリを代入します。
クリーンアップ関数では `destroy()` のような関数を呼び出し、破棄します。

処理の流れは以下の通りです。

1. コンポーネントがマウントされるときにコンポーネントライブラリを初期化
2. コンポーネントがアンマウントされるときにコンポーネントライブラリを破棄

### 亜種: 外部サーバへのログ送信

外部サーバへのログ送信のような処理の初期化・破棄もパターン 1 の一種と捉えられますが、
この場合は破棄が必要ありません。

```tsx
function AnalyticsComponent({ pageId }: { pageId: string }) {
  useEffect(() => {
    // 初期化 = ログ送信
    fetch("/api/analytics", {
      method: "POST",
      body: JSON.stringify({ event: "page_view", pageId }),
    });
    // 破棄 = なし
  }, []);

  return <div>Page: {pageId}</div>;
}
```

処理の流れは以下の通りです。

1. コンポーネントがマウントされるときにログを送信

## パターン 2: <br />React 管轄内の値に基づいて外部システムに値を反映する副作用

### 意図

React 管轄内の値（state, props, context など）が変化したという事象をトリガとして
外部システムにその値を反映させることで、
**React 外部のシステムと React コンポーネントの状態をその都度同期させる**
という意図を持ちます。

### 処理の流れ

1. セットアップ関数・クリーンアップ関数内部に
   セットアップ処理・クリーンアップ処理という副作用を記述する
2. useEffect へこれらの関数を渡す
3. 依存配列に state を含める
4. React が DOM ノードを反映したタイミングで
   セットアップ関数が実行され、副作用が実行される
5. state の値が変化したタイミングで、
   前回のクリーンアップ関数が実行され
   クリーンアップ処理の副作用が実行される
6. 続けて、今回のセットアップ関数が実行され、
   セットアップ処理の副作用が実行される
7. React が DOM ノードを破棄したタイミングで
   クリーンアップ関数が実行され、副作用が実行される

### 例: 複数回実行できる命令的 API を持つ DOM ノードの直接操作

具体例として、`<video>` の再生制御を考えます。
React の state に合わせて再生・一時停止を切り替えます。

```tsx
function VideoPlayer({ src, isPlaying }: { src: string; isPlaying: boolean }) {
  const videoRef = useRef<HTMLVideoElement>(null);

  useEffect(() => {
    if (!videoRef.current) return;

    // セットアップ関数 = state の値に合わせて再生・一時停止を実行
    if (isPlaying) {
      videoRef.current.play();
    } else {
      videoRef.current.pause();
    }
    // この場合はクリーンアップ関数は不要
  }, [isPlaying]);

  return <video ref={videoRef} src={src} />;
}
```

DOM ノードを useRef（後述）で取得し、それに対して再生・一時停止を指示します。
宣言的である React の state の世界から、
命令的な DOM ノードの指示へ、橋渡しを行うイメージです。

この場合、依存配列に state を含めます。

処理の流れは以下の通りです。

1. コンポーネントがマウントされるときに state の値に合わせて再生・一時停止を実行
2. state の値が変化したときに再度 state の値に合わせて再生・一時停止を実行
3. コンポーネントがアンマウントされるときは特に何も実行しない

### 例: 一度しか実行できない命令的 API を持つ DOM ノードの直接操作

具体例として、`<dialog>` の開閉制御を考えます。
React の state に合わせて、開く・閉じるを切り替えます。

```tsx
function Modal({
  isOpen,
  children,
}: {
  isOpen: boolean;
  children: React.ReactNode;
}) {
  const dialogRef = useRef<HTMLDialogElement>(null);

  useEffect(() => {
    if (!dialogRef.current) return;

    // セットアップ関数 = isOpen が true の場合に showModal() を実行
    if (isOpen) {
      dialogRef.current.showModal();
    }

    // クリーンアップ関数 = 常に close() を実行
    return () => {
      dialogRef.current?.close();
    };
  }, [isOpen]);

  return <dialog ref={dialogRef}>{children}</dialog>;
}
```

この場合、気をつけることがあります。
`showModal()` / `close()` は **一度しか実行してはいけません**。

`showModal()` で開いた dialog 要素に対して、
再度 `showModal()` を実行するとエラーになります。

そのため、依存配列に state を含めるだけでなく、
クリーンアップ関数で`close()` を実行するように実装する必要があります。

このようにすることで、一度しか実行できない命令的 API を安全に扱うことができます。

処理の流れは以下の通りです。

1. コンポーネントがマウントされるときに
   セットアップ処理として
   isOpen の値が true なら `showModal()` を実行
2. isOpen の値が変化したときにまずクリーンアップ処理として `close()` を実行
3. 続けてセットアップ処理として isOpen の値が true なら `showModal()` を実行
4. コンポーネントがアンマウントされるときに `close()` を実行

## パターン 3: 何かのイベントに応じて実行される副作用

### 意図

ユーザが意図を持って行った操作（クリック、入力、スクロールなど）を
トリガとして発生する副作用をイベントハンドラ内に閉じ込めることで、
**React の関数コンポーネントの実行外部に副作用処理を逃がす**という意図を持ちます。

### そもそもイベントハンドラとは

イベントハンドラとは、何かのイベントが発生したときに、
対応する処理を実行するコールバック関数です。

イベントハンドラは関数コンポーネントの外部で実行される関数であるため、
外部システムに対して影響を与える処理、
つまり副作用を記述して良い関数であるとされています。

特定のイベントに紐づく副作用は、このイベントハンドラに記述する必要があります。

### イベントハンドラの例

- 特定のボタンが押されたイベントに対して、処理を実行する
- キーボードが押されたイベントに対して、処理を実行する
- ウィンドウのリサイズイベントに対して、処理を実行する
- 外部サーバからの websocket 通知イベントに対して、処理を実行する
- setTimeout や setInterval のタイマーイベントに対して、処理を実行する

:::message
setTimeout や setInterval は厳密にはイベントハンドラではありませんが、
「一定時間経過後」や「一定時間ごと」というイベントで発火するイベントハンドラ的な性質を持つため
この解説ではイベントハンドラの一種として扱います。
:::

### 処理の流れ

1. イベントハンドラ関数内部に 副作用処理を記述する
2. 「任意のイベントハンドラ登録手段」を用いて
   イベントハンドラ関数をイベントハンドラに登録する
3. ユーザが意図を持って行った操作によって
   イベントハンドラ関数が実行され、副作用が実行される

### 「任意のイベントハンドラ登録手段」とは

特定のイベントに応じて実行される副作用は、イベントハンドラに記述するということがわかりました。
では、このイベントハンドラはどのように登録すれば良いのでしょうか。

イベントハンドラの登録手段はいくつか存在します。代表的なものとしては、以下の 2 つがあります。

1. **JSX のイベントハンドラ属性を用いる手段**
2. **useEffect（パターン 1）を利用する手段**

それぞれについて解説していきます。

なお、2 の useEffect を利用する手段でイベントハンドラを登録するということは、
前述した パターン 1 をイベントハンドラ登録に応用するということです。
つまり、パターン 1 をパターン 3 の内部に組み込む運用になります。

イベントハンドラ自体も副作用であり、イベントハンドラの登録も副作用である、という
二重の副作用の構造に注意してください。

では、それぞれの手段について解説していきます。

### 1. JSX のイベントハンドラ属性を用いる手段

イベントハンドラを設定するための基本的な手段です。

関数コンポーネントが生成する React 要素の属性として、
イベントハンドラとなる関数を登録する手段です。

この例では、`onClick` というイベントハンドラ属性を用いて、
クリックイベントに対するイベントハンドラを登録しています。

```tsx
function ShareButton({ url }: { url: string }) {
  const handleClick = () => {
    // ボタンが押された時に新しくウィンドウを開く
    window.open(`https://twitter.com/share?url=${encodeURIComponent(url)}`);
  };

  return <button onClick={handleClick}>Share</button>;
}
```

```tsx
function SubmitButton({ data }: { data: object }) {
  const handleClick = async () => {
    // ボタンが押されたときに外部サーバにデータを送信
    await fetch("/api/submit", {
      method: "POST",
      body: JSON.stringify(data),
    });
  };

  return <button onClick={handleClick}>Submit</button>;
}
```

イベントハンドラ属性は、React が管轄している要素であるため、
React が自動でイベントハンドラの登録・解除を行ってくれます。

つまり、開発者はイベントハンドラの登録・解除を自力で実装する必要がありません。

### 2. useEffect（パターン 1）を利用する手段

先程解説したイベントハンドラ属性は、
対応する React 要素が存在しない場合には利用できません。

例えば以下のような場合です。

- キーボードが押されたときに処理を実行したい場合
- ウィンドウのリサイズ時に処理を実行したい場合
- 外部サーバからの websocket 通知を受け取ったときに処理を実行したい場合
- setTimeout や setInterval を用いて時間経過後に処理を実行したい場合

その場合、useEffect を用いてイベントハンドラの登録・解除を自力で実装する必要があります。

```tsx
// キーボードが押されたときに処理を実行するようなイベントハンドラの登録・解除
function KeyboardListener() {
  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      console.log("Key pressed:", e.key);
    };

    // イベントハンドラの登録
    window.addEventListener("keydown", handler);

    return () => {
      // イベントハンドラの解除
      window.removeEventListener("keydown", handler);
    };
  }, []);

  return <div>Press any key</div>;
}
```

```tsx
// ウィンドウのリサイズ時に処理を実行するようなイベントハンドラの登録・解除
function ResizeListener({ onResize }: { onResize: (width: number) => void }) {
  useEffect(() => {
    const handler = () => {
      onResize(window.innerWidth);
    };

    window.addEventListener("resize", handler);
    return () => window.removeEventListener("resize", handler);
  }, [onResize]);

  return null;
}
```

```tsx
// setTimeout を用いて時間経過後に処理を実行するようなイベントハンドラの登録・解除
function DelayedMessage({
  delay,
  message,
}: {
  delay: number;
  message: string;
}) {
  const [show, setShow] = useState(false);

  useEffect(() => {
    // イベントハンドラの登録
    const id = setTimeout(() => {
      setShow(true);
    }, delay);

    return () => {
      // イベントハンドラの解除
      clearTimeout(id);
    };
  }, [delay]);

  return show ? <div>{message}</div> : null;
}
```

:::message
**useEffectEvent について**

useEffect でイベントハンドラを登録・解除する場合、
イベントハンドラ内で React 管轄内の値（state, props, context）を参照していると、
eslint によりそれらの値を依存配列に含めるように指摘される場合があります。

しかし、イベントハンドラの登録・解除は副作用の登録・解除であり、
依存配列に React 管轄内の値を含めてしまうと
不要なタイミングでイベントハンドラの登録・解除が発生してしまいます。

その場合、あえてイベントハンドラのコールバック関数を useEffect 外部で生成し、
更に useEffectEvent を用いてコールバック関数をラップします。

これにより、イベントハンドラ内で React 管轄内の値を安全に参照できるようになり、
かつ依存配列に React 管轄内の値を含める必要がなくなります。

また useEffectEvent を用いることで、
イベントハンドラ内で参照している React 管轄内の値（state, props, context）について、
常に最新の値を参照できるようになります。
:::

### イベントハンドラ属性と useEffect の使い分け

React 要素の中でイベントハンドラ属性を用いることが可能な場合は、
**基本的にイベントハンドラ属性を用いることが推奨されます。**

しかし、該当する React 要素が存在しない場合は
イベントハンドラ属性を用いることができないため、
useEffect を利用して副作用を設定する必要があります。

useEffect によるイベントハンドラの登録・解除は、あくまで
**イベントハンドラで副作用を設定できない場合の補完手段** であるため、
useEffect を用いる場合は本当にイベントハンドラで副作用を設定できないのかを
注意深く検討する必要があります。

- **イベントハンドラ属性**
  → React が管轄している要素であるため
  → イベントハンドラの登録・解除を React が自動で行ってくれる
- **useEffect**
  → React が管轄していない要素であるため
  → 開発者がイベントハンドラの登録・解除を自力で実装する必要がある

副作用の記述に慣れていない場合、
**クリーンアップ関数でイベントハンドラの解除を行うのを忘れがち** になります。
パターン 1 の useEffect と同様の注意点なので、しっかり忘れずに実装しましょう。

# 副作用実行手段の使い分け

典型的な副作用処理のパターンとそれぞれに対応する副作用実行手段を解説しました。

開発者は、実装したい副作用の内容に応じて
これらの副作用実行手段を使い分ける必要があります。

今回開発したパターンに当てはまらない場合、開発者は臨機応変に対応していく必要があります。

その場合も、実装したい副作用をじっくり観察してみることで、
それが今回解説したパターンの融合や亜種であり、
これらのパターンに落とし込むことが出来た、というケースが多いでしょう。

# 今回解説しなかった useEffect の使い方: <br />外部システムの値 → React の状態同期

今回は、外部システムの値 → React の状態同期という使い方は解説しませんでした。
これらの方法は useEffect を利用するよりも、別の手段を用いることが推奨されるためです。

## 同期的な値の読み取り

`localStorage` や `IndexedDB` のような
ブラウザのストレージからの同期的な値の読み取りにも useEffect を利用することはできますが、
推奨されません。

代わりに、React 18 で導入された `useSyncExternalStore` の利用が推奨されます。

React 外部のシステムの値を同期的に読み取るための手段を提供しており、
React 外部のシステムの値を React の状態として扱うことができます。詳細は後述します。

## 非同期なデータフェッチ

`fetch` のような HTTP クライアントを用いた非同期なデータフェッチにも
useEffect を利用することはできますが、推奨されません。

推奨する手段は、React Query、SWR のようなデータフェッチ支援ライブラリを利用することです。

これらのライブラリは、
外部サーバのデータを React の state と同期させるための手段を提供しており、
自前で useEffect を用いてデータフェッチ周りの処理を実装する必要がなくなります。

また、キャッシュ管理の他にも

- 再試行
- ポーリング
- データの永続化

などの機能を提供しています。
これらの処理は独自実装すると非常に難しくコストが高いですが、
これらのライブラリを利用することでライブラリに実装を任せることができます。

また、後述するコンポーネントのサスペンド機能も提供していることが多いです。

非同期なデータフェッチに useEffect を用いることは避け、これらの専用ライブラリを利用することが推奨されます。

# 副作用パターン分岐フローチャート

副作用を実装する際は、以下のフローチャートに沿って分岐を行うと良いでしょう。

**A. 副作用は何かのイベントに応じて実行される副作用であるか？**

- Yes → B へ
- No → C へ

**B. イベントハンドラに副作用を記述する手段を用いる**

React 要素にイベントハンドラ属性を用いてイベントハンドラを登録できるか？

- Yes → イベントハンドラ属性を利用する手段を用いる（パターン 3a）
- No → useEffect（パターン 1）を利用する手段を用いる（パターン 3b）

**C. 外部システムへの同期と捉える**

副作用は React 管轄内の値が変化したことをトリガとして実行される副作用であるか？

- Yes
  → 依存配列に React 管轄内の値を含めて
  → useEffect を利用する手段を用いる（パターン 2）
- No → D へ

**D. 副作用は React が DOM ノードを反映・破棄したタイミング**
**（React のライフサイクル）で実行される副作用であるか？**

- Yes → useEffect を利用する手段を用いる（パターン 1）
- No → 副作用の内容を見直す必要がある

## そもそも副作用でない場合の分岐

先程のフローチャートを始める前に、以下の問いを検討することが推奨されます。

**α. 実行したい処理は外部システムの値を読み取る or 値に影響を与えるか？**

- Yes → 副作用である → β へ
- No → 副作用ではない → React 内部の仕組みを極力利用する

副作用でない場合の代替案の例は以下の通りです。

- useEffect で状態群の変更にそって state を更新する
  - 代替案: useEffect を用いずに直接 state から値を導出する（適宜 `useMemo` を利用）
- useEffect で state の初期化を行う
  - 代替案: key 属性を用いてコンポーネントの再生成を制御する
- useEffect でアプリケーション全体の初期化を行う
  - 代替案: コンポーネント外部で初期化処理を実行する

**β. 実行したい処理は 外部システムの値 → React の状態同期であるか？**

- Yes → 副作用だが、useEffect を用いない手段を検討する
  - localStorage や IndexedDB から値を読み取る
    → 代替案: `useSyncExternalStore` を用いて同期的に値を読み取る
  - fetch を用いて非同期にデータを取得する
    → 代替案: React Query、SWR のようなデータフェッチ支援ライブラリを利用する
- No → 先程のフローチャートに従って分岐を続ける

このフローチャートに沿って副作用を記述していくことが好ましいです。

ただし、これは用法を意識したガイドラインであり、
実際の開発ではいくつかの注意点があります。

# 実際の開発での注意点

実際の開発では、これらのパターンが不可分である場合があります。

例えば、websocket の受信（パターン 1 とパターン 3b が不可分）を考えてみましょう。

```tsx
function WebSocketComponent({ url }: { url: string }) {
  const [messages, setMessages] = useState<string[]>([]);

  useEffect(() => {
    // まず websocket 接続を確立する（パターン 1）
    const ws = new WebSocket(url);

    // 次に受信イベントハンドラを登録する（パターン 3b）
    ws.addEventListener("message", (event) => {
      setMessages((prev) => [...prev, event.data]);
    });

    return () => {
      ws.close();
    };
  }, [url]);

  return (
    <ul>
      {messages.map((msg, i) => (
        <li key={i}>{msg}</li>
      ))}
    </ul>
  );
}
```

この場合、同一の useEffect 内でパターン 1 とパターン 3b の両方の役割を果たす方が自然です。

無理にパターン 1 とパターン 3b を分割するメリットはなく、かえって保守が難しくなります。
また、そもそもライブラリが提供する API 自体がこれらのパターンを分割できない場合もあります。

## useEffect の分割境界

では、useEffect の分割境界はどこにあるのでしょうか？

React 公式は、
**一つの useEffect ごとに、一つの外部システムへの同期となる設計**を推奨しています。
その指標として、**「依存配列が一致する」** かどうかが挙げられます。

同じ外部システムにアクセスしており、かつ依存配列が同じ場合は
**一つの外部システムへの同期** と捉えられるため、
それらを一つの useEffect にまとめるべきである可能性が高いです。

逆に、依存配列が異なる場合であったり、異なる外部システムへの同期であったりする場合は、
それらを別々の useEffect に分割することが推奨されます。

以上、イベントハンドラや useEffect を用いた副作用の記述手段について解説しました。

# 補助的な手段: useRef と ref 属性

React は、これまで解説した副作用実行手段に加えて、
副作用を記述しやすくするための補助的な手段も提供しています。

## useRef と ref 属性

任意の値を入れられるオブジェクトや実 DOM ノードへの参照を提供する手段です。
先程の副作用処理の中でも、DOM ノードを直接操作するために利用する例がいくつか出てきました。

useRef は 副作用実行手段というより、
副作用の処理を記述する際に利用するための補助的な手段です。

useRef は 2 つの責務を持ちます。

どちらの責務も
**「関数コンポーネントの実行外部でミュータブルな値を保持・参照する」**
ための手段として提供されているという点で共通しています。

### 1. 任意の値を入れられるオブジェクトの提供

関数コンポーネント内で `useRef` を呼び出すと `ref` オブジェクトが得られます。

この ref オブジェクトとは、
ミュータブルに利用でき 任意の値を入れられるオブジェクト
`ref.current` を持つオブジェクトです。

これにより関数コンポーネントの実行外部でミュータブルな値を保持できるようになります。

```tsx
function Timer() {
  const intervalIdRef = useRef<number | null>(null);

  const start = () => {
    intervalIdRef.current = setInterval(() => {
      console.log("tick");
    }, 1000);
  };

  const stop = () => {
    if (intervalIdRef.current) {
      clearInterval(intervalIdRef.current);
    }
  };

  return (
    <div>
      <button onClick={start}>Start</button>
      <button onClick={stop}>Stop</button>
    </div>
  );
}
```

### 2. 実 DOM ノードへの参照の取得

1 で入手した ref オブジェクトをコンポーネントの `ref` 属性に渡すと、
`ref.current` が任意の値ではなく、
ref 属性を与えたコンポーネントの実 DOM ノードを参照するようになります。

これにより、関数コンポーネントの実行外部で
実 DOM ノードへの参照を取得できるようになります。

```tsx
function FocusInput() {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleClick = () => {
    inputRef.current?.focus();
  };

  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Focus</button>
    </div>
  );
}
```

:::message
`ref` 属性を与えるコンポーネントは、
関数コンポーネントではなく DOM を持つコンポーネントである必要があります。

なお、Reactの用語として DOM を持つコンポーネントは **HostComponent** と呼ばれます。

関数コンポーネントが `ref` 属性を受け取る場合は、
関数コンポーネント内で HostComponent に `ref` を受け流す必要があります。
:::

## useRef の利用場所

基本的な React のスタンスとして、関数コンポーネント実行の内部、つまり
React 要素を生成する処理の中では、ミュータブルな値や実 DOM ノードへの参照を扱わず、
関数コンポーネントの純粋関数性を保つことを前提としています。

そのため、useRef で得られた `ref.current` は、
イベントハンドラや useEffect 内部のような
**副作用実行手段の中でのみ利用する** ことが想定されています。

## 要点まとめ

- 副作用は **関数コンポーネント本体ではなく外部で実行する** のが React の前提
- useEffect は主に **ライフサイクル同期** や **React 管轄内の値に応じた外部同期** に使う
- ユーザ操作起点の副作用は、まず **イベントハンドラ属性を優先** して記述する
- useEffect の設計単位は、原則 **1つの外部システムへの同期ごと** に分ける
- useRef は副作用そのものではなく、**副作用実装を補助する参照手段**

# おわりに

今回は、
副作用実行手段および 副作用を記述しやすくするための補助的な手段について解説しました。

これらの副作用実行手段は、
`f(...) = React 要素` という純粋関数性を保ちながら、
外部システムとのやり取りを関数コンポーネントの外部に逃がすために提供された手段です。

開発者は、React の思想に反しないように
外部システムとのやり取りを イベントハンドラや useEffect 内部に記述し、
関数コンポーネントの外部で実行するように注意する必要があります。
