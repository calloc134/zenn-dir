---
title: "SPA + API のセッション管理 安全性ランキング (CSRF 対策のベストプラクティスを添えて)"
emoji: "🙆"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["security", "session", "spa", "jwt", "cookie"]
published: false
---

# はじめに

こんにちは、calloc134 です。

皆さんは SPA でアプリケーションを作るとき、
API とのセッション管理にはどのような手法を利用していますか？
クッキー？それとも localStorage に JWT などを保存して利用？

今回は、SPA + API のセッション管理について基礎を押さえた上で、
参考になる安全性のランキングを作成してみました。

SPA + API のセキュリティについて、包括的に学習を深めていきましょう。

# 今回の前提条件

この記事では、以下のような構成を前提として話を進めます。

**フロントエンド**

SPA (Single Page Application) を想定しています。ブラウザ上で動作する JavaScript アプリケーションのことです。

**バックエンド**

API サーバを想定しています。具体的には REST API をイメージしており、JSON を受け取り JSON を返すことを前提としています。

そのため、クッキーを利用する場合は以下の属性となります。

- Secure 属性: true
- HttpOnly 属性: 場合による (後述)
- SameSite 属性: ドメインに依る (今回は解説しない)

**認証について**

認証は既に完了しており、これからセッションを開始する段階であることを前提とします。

# セッション管理における 2 つのレイヤ

巷では、「クッキーか JWT か」などの議論が行われることがあります。
しかし、この議論は対立軸を誤っています。

セッション管理には 2 つのレイヤが存在します。

1. トークン文字列がどのような形式か
2. トークン文字列をどこに保存し、どのように取り出して送信するか

この 2 つのレイヤを分けて考えることが重要です。
それぞれについて解説していきましょう。

## 1. トークン形式

トークン形式には、大きく分けて 2 つの方式があります。

### A. handle 型トークン

handle 型トークンとは、API 側のデータベースにセッション情報を保存し、トークン文字列はそのセッション情報を一意に指し示す ID のみを持つ方式です。

API 側はトークン文字列を受け取ると、データベースを参照してセッション情報を取得します。
例としては、セッション ID やランダム文字列トークンがこれに該当します。

ただ一意に指し示すだけであるため、トークン文字列自体は十分にランダムに生成された文字列であることが好ましいです。

**利点**

- API 側でセッション情報を管理できるため、セッションの失効が可能
- API 側でセッション情報を管理できるため、セッション情報が古くならない

**欠点**

- API 側でセッション情報を管理するため、情報を保存するインフラコストが発生する
- API 側でセッション情報を管理するため、スケーラビリティが低下する可能性がある
- API 側でセッション情報を管理するため、トークンの情報取得に DB アクセスが発生しレイテンシが増加する

### B. assertion 型トークン

assertion 型トークンとは、トークン文字列自体にセッション情報を含む方式です。

API 側はトークン文字列を受け取ると、トークン文字列を解析してセッション情報を取得します。
例としては、JWT がこれに該当します。

トークン文字列自体にセッション情報を含むため、トークン文字列は長く複雑になります。
ほとんどの場合、暗号化や署名が施されます。

**利点**

- API 側でセッション情報を管理しないため、インフラコストが発生しない
- API 側でセッション情報を管理しないため、スケーラビリティが向上する
- API 側でセッション情報を管理しないため、トークンの情報取得に DB アクセスが発生せずレイテンシが低減する

**欠点**

- API 側でセッション情報を管理しないため、セッションの失効が困難
- API 側でセッション情報を管理しないため、セッション情報が古くなる可能性がある

:::message
これらの欠点の解消も不可能ではありませんが、結局これらの欠点を解消しようとすると DB アクセスが必要となり、handle 型トークンの性質と似通ってしまいます。
:::

### C. 短命 assertion 型トークン + 長命 handle 型トークン

一般的には以上のとおりですが、2 つのトークンを組み合わせて利用することで、お互いの欠点を補うことも可能です。

この方式では、assertion 型トークンを短命に設定し、長命の handle 型トークンで assertion 型トークンを再発行します。同時に新しい長命 handle 型トークンを発行し、古いものを無効化します。

このように設計することで、assertion 型と handle 型の利点を組み合わせることが可能です。

**assertion 型トークンの欠点の解消**

assertion 型トークンの欠点は「セッションの失効が困難」であることでした。

この方式では、assertion 型トークンを短命に設定することで、短命 assertion 型トークンが盗まれた場合でも短期間で無効化され悪用が困難になります。また、長命 handle 型トークンは失効可能であるため、長命 handle 型トークンが盗まれた場合でも、API 側で失効させることでセッションを無効化可能です。

**handle 型トークンの欠点の解消**

handle 型トークンの欠点は「インフラコストが発生・スケーラビリティが低下・レイテンシが増加」でした。

この方式では、セッションとしては頻繁にアクセスする短命 assertion 型トークンを利用することで、普段のアクセスにおける DB アクセスを低減しインフラコストを抑制・スケーラビリティを向上・レイテンシを低減できます。長命 handle 型トークンは短命 assertion 型トークンの再発行時にのみ利用されるため、頻繁にアクセスされることがなくインフラコストを抑制可能です。

## 2. トークン保存場所・送信方法

次に、トークンをどこに保存し、どのように送信するかについて解説します。

### α. httpOnly クッキーに保存しブラウザが自動送信

ブラウザの提供するクッキー機能を利用する方式です。httpOnly 属性を付与することで JavaScript からのアクセスを防止します。API へのリクエスト時にブラウザが自動的にクッキーを送信します。

古き良きセッション管理手法といえます。

**利点**

攻撃者によってブラウザに悪意のある JavaScript コードが送り込まれた場合でも、JavaScript からクッキーにアクセスできないため、セッション情報そのものが盗まれるリスクを低減できます。

:::message
補足として、悪意ある JavaScript からクッキーを付けて API にアクセスすることは可能なことに注意してください。あくまでも永続的にセッション情報が盗まれるリスクを低減できるという意味であり、悪意ある JavaScript がブラウザで動作している間はセッションが乗っ取られるリスクがあることに注意が必要です。

httpOnly が付いていても被害が拡大する例として、パスワード変更 API を呼び出しパスワードを変更されるケースがあります。このようなアカウントアクセス拡大に繋がる API 呼び出しは、事前にパスワード再認証を要求するなどの対策が必要です。
:::

**欠点**

しっかり CSRF 対策を行う必要があります。CSRF は設定を誤らなければ防げる攻撃であるため、十分に注意して対策を行いましょう。SPA + API の場合の CSRF 対策については、別記事で解説予定です。

**クッキーの属性**

前提条件より、以下の属性を設定します。

- SameSite: None (または適切な値)
- Secure: true
- HttpOnly: true

### β. ブラウザの提供するストレージやメモリに保存し JavaScript でその都度取り出して送信

JavaScript を用いてストレージやメモリにトークン文字列を保存し、API へのリクエスト時に JavaScript でトークン文字列を取り出し、API リクエストヘッダなどにトークン文字列を付与して送信する方式です。

近年の SPA でよく利用される手法です。

トークンは以下のような場所に保存されます。

**ストレージ**

- localStorage
- sessionStorage
- IndexedDB

**メモリ**

- React の state
- JavaScript の変数

**利点**

CSRF 対策が不要です。JavaScript で API リクエストヘッダなどにトークン文字列を付与して送信するため、悪意ある第三者のオリジンからのリクエストではトークン文字列を付与できません。そのため CSRF 攻撃を防げます。

**欠点**

攻撃者によってブラウザに悪意のある JavaScript コードが送り込まれた場合、その JavaScript からストレージやメモリに保存されたトークン文字列にアクセスできるため、永続的にセッション情報が盗まれるリスクがあります。

この手法ではトークン文字列の保存・取り出しを JavaScript が担うため、悪意ある JavaScript の実行によるトークン奪取問題を根本的に防ぐことはできません。そのため、対処療法ではありますが、悪意ある JavaScript の実行を防ぐ対策が重要となります。

### 非推奨: httpOnly でないクッキー

httpOnly でないクッキーに保存する方式は、クッキーの利点が活かせない上に、JavaScript からアクセス可能であるため β の手法と同様の欠点を持ちます。

そのため、今回はこれを最初から非推奨とします。

## セッション管理の安全性ランキング

上記の 2 つのレイヤを組み合わせた場合の安全性 Tier 表を作成しました。

なお、簡単に比較できないものも存在します。そのため、ハッセ図という概念を利用し、安全性の高低を表現します。高低差を単純に比較できないものは、枝分かれで表現します。

また、CSRF 脅威は適切に対策すれば問題ないものとします。そのため、ランキングにおいて CSRF 脅威は考慮していません。ただし、CSRF 脅威に対して適切に対策を行う必要があることは念のため付記しておきます。前述のとおり、CSRF 対策については別記事で解説予定です。

### 1 位: A on α (handle 型トークン on httpOnly クッキー)

handle 型トークンを httpOnly クッキーに保存する方式です。

API 側でセッション情報を管理し失効可能であり、JavaScript からのアクセスを防止可能です。昔ながらの安全なセッション管理手法といえます。

昔はサーバが一台のことも多く、バックエンドサーバによるスケーラビリティの問題が今より少なかったため、この手法で何ら問題はなく一般的な構成でした。

**メリット**

- セッションの失効が可能であり、永続的なトークン奪取リスクを低減できる

**デメリット**

- インフラコストが発生
- スケーラビリティが低下
- レイテンシが増加
- CSRF 対策が必要 (適切に対策すれば問題なし)

**具体的なライブラリ**

Express.js では express-session が該当します。DB を抽象化したストアという概念を持ち、サーバ側にセッション情報を保存可能です。様々な DB 用のストア実装が存在し、httpOnly 属性付きクッキーに handle 型トークンを保存します。

https://github.com/expressjs/session

Spring Boot では Spring Session が該当します。Redis などの DB にセッション情報を保存可能で、httpOnly 属性付きクッキーに handle 型トークンを保存します。

https://spring.pleiades.io/spring-session/reference/guides/boot-redis.html

Auth.js では Database Session が該当します。HttpOnly クッキーに handle 型トークンを保存し、対応する DB にセッション情報を保存可能です。

https://authjs.dev/concepts/session-strategies#database-session
https://authjs.dev/getting-started/database

### 2 位: C on α (短命 assertion 型トークン + 長命 handle 型トークン on httpOnly クッキー)

短命 assertion 型トークンと長命 handle 型トークンを httpOnly クッキーに保存する方式です。

API 側でセッション情報を管理し、長命側は失効可能です。比較的安全なセッション管理手法といえます。

**メリット**

- 長命側トークンであれば失効が可能であり、永続的なトークン奪取リスクを低減できる
- 普段のアクセスにおける DB アクセスを低減し、インフラコストを抑制・スケーラビリティを向上・レイテンシを低減できる

**デメリット**

- 短命側トークンが盗まれた場合のリスクは残る (ただし短命であるためリスクはできるだけ低減)
- CSRF 対策が必要 (適切に対策すれば問題なし)

**具体的なライブラリ**

SuperTokens が該当します。内部的に短命 assertion 型トークン + 長命 handle 型トークンの組み合わせを利用しています。短命 assertion 型トークンはアクセストークン (JWT)、長命 handle 型トークンはリフレッシュトークン (ランダム文字列) に対応します。

https://supertokens.com/docs/references/how-supertokens-works

双方ともに HttpOnly 属性付きクッキーに保存されます。長命側トークンで短命側トークンを再発行し、同時に新しい長命側トークンを発行し古いものを無効化します。

SuperTokens は外部サーバとして動作しますが、SPA と直接通信はせず API サーバのみと通信します。API サーバはトークンの発行・検証を SuperTokens サーバに委託する形となります。とはいえ SPA から見れば API サーバがセッション管理を行っているのと変わりません。

**問題点**

この形を実装するフレームワークがほとんど存在しません。かろうじて SuperTokens が対応している程度です。

筆者の意見では、この形が最もバランスの良いセッション管理手法であると考えますが、現状で対応しているフレームワークはほとんどありません。

自前で対応しようとすると独自実装となりコストが高くなります。また、セキュリティにおける独自実装は、それ自体がセキュリティリスクを招く可能性があるため注意が必要です。

### 3 位: B on α (assertion 型トークン on httpOnly クッキー)

assertion 型トークンを httpOnly クッキーに保存する方式です。

JavaScript からのアクセスを防止可能です。モダンな API フレームワークでセッション管理のミドルウェアを利用すると、この形になることが多いです。

**メリット**

- JavaScript からのアクセスを防止可能であり、永続的なトークン奪取リスクを低減できる

**デメリット**

- API 側でセッション情報を管理しないため失効が困難であり、永続的なトークン奪取リスクが残る
- CSRF 対策が必要 (適切に対策すれば問題なし)

**具体的なライブラリ**

Hono では hono/session が該当します。内部的に JWE 形式の assertion 型トークンを保存し、デフォルトで HttpOnly 属性付きクッキーに保存されます。

https://github.com/honojs/middleware/tree/main/packages/session

Auth.js では JWT Session が該当します。HttpOnly クッキーに assertion 型トークンを保存します。

https://authjs.dev/concepts/session-strategies#jwt-session

### 4 位: C on β (短命 assertion 型トークン + 長命 handle 型トークン on ブラウザストレージやメモリ)

短命 assertion 型トークンと長命 handle 型トークンをブラウザストレージやメモリに保存する方式です。

API 側でセッション情報を管理し、長命側は失効可能です。Auth0 などの外部認可サーバを用いた SPA + API のセッション管理でよく利用される手法です。

以下のような対応となります。

- 短命 assertion 型トークン = アクセストークン (JWT)
- 長命 handle 型トークン = リフレッシュトークン (ランダム文字列)
- トークンはそれぞれメモリに保存されますが、指定が可能

緩和策として、Web Worker のメモリへの保存があります。リフレッシュトークンは Web Worker のメモリ内に保存されるため、悪意ある JavaScript からのアクセスが比較的困難になります。

トークン自体の発行は API サーバではなく外部の Auth0 サーバが担当します。SPA が Auth0 サーバと直接やり取りし、アクセストークン・リフレッシュトークンを受け取りメモリに保存します。その後 SPA が API サーバにアクセストークンを付与してリクエストを送信し、API サーバがアクセストークンを受け取りそれを検証します。

検証の手順を間違えると脆弱性を招くリスクがあるため注意が必要です。

**メリット**

- 長命側トークンであれば失効が可能であり、永続的なトークン奪取リスクを低減できる
- 短命側トークンが盗まれた場合のリスクは残る (ただし短命であるためリスクはできるだけ低減)
- 双方ともに CSRF 対策が不要

**デメリット**

- 短命側トークン及び長命側トークンが JavaScript からアクセス可能であるため、永続的なトークン奪取リスクが残る (特に長命側トークンは永続的に奪取されるリスクが高い)
- 悪意ある JavaScript の実行を防ぐ対策が重要

**具体的なライブラリ**

Auth0 SDK の auth0-spa-js (リフレッシュトークン利用) が該当します。`useRefreshTokens: true` オプションを指定することで対応可能です。

以下のような対応となります。

- 短命 assertion 型トークン = アクセストークン (JWT)
- 長命 handle 型トークン = リフレッシュトークン (ランダム文字列)
- トークンはそれぞれメモリに保存されますが、指定が可能

リフレッシュトークン奪取への緩和策として、この方式ではリフレッシュトークンを奪取されると永続的にアクセスされるリスクが高いため、Web Worker のメモリへの保存が利用されます。リフレッシュトークンは Web Worker のメモリ内に保存され、悪意ある JavaScript からのアクセスが比較的困難になります。

トークン自体の発行は API サーバではなく外部の Auth0 サーバが担当します。SPA が Auth0 サーバと直接やり取りし、アクセストークン・リフレッシュトークンを受け取りメモリに保存します。その後 SPA が API サーバにアクセストークンを付与してリクエストを送信し、API サーバがアクセストークンを受け取りそれを検証します。検証の手順を間違えると脆弱性を招くリスクがあるため注意が必要です。

**余談: OAuth との関連性と注意点**

この手法は、API サーバ単体というよりも、Auth0 などの外部認可サーバを用いた SPA + API のセッション管理でよく利用される手法です。この実装において OAuth のアクセストークン・リフレッシュトークンが流用されるケースが非常に多いです。

OAuth は仕様上アクセストークン・リフレッシュトークンを発行します。access token は短命 assertion 型トークンに該当し、refresh token は長命 handle 型トークンに該当します。このアクセストークンをセッショントークンとして流用しているイメージです。

OAuth のアクセストークン・リフレッシュトークンをセッション管理に流用すると、自然と C on β/α の形にたどり着きます。

しかし、筆者の意見では OAuth のアクセストークンをセッションに流用するのは推奨しません。OAuth のアクセストークンは本来リソースサーバーへのアクセス権を示すものであり、セッション管理のために設計されていないため、セッション管理の要件を満たさないと考えます。

また、検証を怠ると脆弱性を招くリスクもあります。詳しくは以前の記事を参照してください。

https://zenn.dev/calloc134/articles/oauth-cross-api-vuln-attack

### 同率 4 位: B on β (assertion 型トークン on ブラウザストレージやメモリ)

assertion 型トークンをブラウザストレージやメモリに保存する方式です。

SPA でよく利用される手法ですが、安全性は低いです。

**メリット**

- CSRF 対策が不要

**デメリット**

- API 側でセッション情報を管理しないため失効が困難であり、永続的なトークン奪取リスクが残る
- トークン文字列が JavaScript からアクセス可能であるため、永続的なトークン奪取リスクが残る
- 悪意ある JavaScript の実行を防ぐ対策が重要

**具体的なライブラリ**

Auth0 SDK の auth0-spa-js (リフレッシュトークン不使用) が該当します。`useRefreshTokens: false` (デフォルト) オプションを指定することで対応可能です。assertion 型トークンはアクセストークン (JWT) となります。リフレッシュトークンが存在しないこと以外は C on β と同じです。

https://authjs.dev/concepts/session-strategies#jwt-session

**余談: B on β と C on β の安全性比較**

B on β の場合、assertion 型トークンしか存在しないためトークンを奪取されると永続的にアクセスされます。ただし C on β も長命 handle 型トークンが奪取された場合は同等のリスクとなります。

どちらの手法も β であるため、どのみち悪意ある JavaScript によるトークン奪取による永続的アクセスのリスクが存在します。assertion 型トークンの有効期限に左右されるため一概に比較できません。そのため同率としました。

B on β において assertion 型トークンを短命に設定している場合、C on β よりも安全といえる可能性もあります。逆に Web Worker による長命 handle 型トークン奪取の緩和策を用いている場合は、C on β の方が安全といえる可能性もあります。

### 非推奨: B on non-httpOnly cookie (assertion 型トークン on httpOnly でないクッキー)

assertion 型トークンを httpOnly でないクッキーに保存する方式です。

JavaScript からアクセス可能であるため β の手法と同様の欠点を持ちます。更に CSRF 対策も必要となるため、これを採用するメリットはほとんどありません。α を利用する場合も同様です。

## 安全性ランキング考察

先程のランキングの強さを比較していきます。

### 1 位 → 2 位

handle 型トークン on httpOnly クッキーから、短命 assertion 型トークン + 長命 handle 型トークン on httpOnly クッキーへ移行した場合に増える欠点は、**assertion 型トークンが盗まれた場合のリスク (低)** です。

短命 assertion 型トークンが盗まれた場合、assertion 型トークンは API 側で失効させることができず、永続的アクセスのリスクがあるという欠点が増えます。ただし、短命であるためリスクは低いです。

### 2 位 → 3 位

短命 assertion 型トークン + 長命 handle 型トークン on httpOnly クッキーから、assertion 型トークン on httpOnly クッキーへ移行した場合に増える欠点は、**assertion 型トークンが盗まれた場合のリスク (高)** です。

assertion 型トークンが盗まれた場合、assertion 型トークンは API 側で失効させることができず、永続的アクセスのリスクがあるという欠点が増えます。またこの場合、assertion 型トークンは長命であることが多いためリスクが高くなります。

### 2 位 → 4 位

短命 assertion 型トークン + 長命 handle 型トークン on httpOnly クッキーから、短命 assertion 型トークン + 長命 handle 型トークン on ブラウザストレージやメモリへ移行した場合に増える欠点は、**トークン文字列が JavaScript からアクセス可能であること** です。

悪性 JavaScript がブラウザに送り込まれた場合、JavaScript からトークン文字列にアクセスできるため、永続的にセッション情報が盗まれるリスクがあるという欠点が増えます。長命 handle 型トークンが盗まれた場合のリスク自体は 2 位と変わりません。

### 3 位 → 4 位 (2)

assertion 型トークン on httpOnly クッキーから、assertion 型トークン on ブラウザストレージやメモリへ移行した場合に増える欠点は、**トークン文字列が JavaScript からアクセス可能であること** です。

悪性 JavaScript がブラウザに送り込まれた場合、JavaScript からトークン文字列にアクセスできるため、永続的にセッション情報が盗まれるリスクがあるという欠点が増えます。assertion 型トークン奪取による永続的アクセスのリスク自体は 3 位と変わりません。

### 4 位 → 非推奨

assertion 型トークン on ブラウザストレージやメモリから、assertion 型トークン on httpOnly でないクッキーへ移行した場合に増える欠点は、**CSRF 対策が必要となること** です。

CSRF 対策が不要であるという利点が失われるという欠点が増えます。

### ハッセ図による可視化

これを図に表すと以下のハッセ図のようになります。安全性の高いものほど上位に位置し、単純に比較できないものは枝分かれで表現しています。

```
                    1位: A on α
                         |
                    2位: C on α
                       /   \
                      /     \
               3位: B on α   4位: C on β
                      \     /
                       \   /
                  同率4位: B on β
                         |
                     非推奨: B on non-httpOnly cookie
```

# おわりに

今回は、SPA + API のセッション管理について、安全性の Tier 表を考えてみました。
安全な手法を取るに越したことはありませんが、安全性を高めるほど、利便性やインフラコストとのトレードオフが発生します。
自分のアプリケーションにとって、どの程度の安全性が必要かを見極め、適切なセッション管理手法を選択しましょう。

読んでいただき、ありがとうございました。
