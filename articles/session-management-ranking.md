---
title: "SPA + API のセッション管理 安全性ランキング (CSRF 対策のベストプラクティスを添えて)"
emoji: "🙆"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

# はじめに

こんにちは、calloc134 です。

皆さんはSPA で アプリケーションを作るとき、
API との セッション管理にはどのような手法を利用していますか？
クッキー？それとも localStorage に JWT などを保存して利用？

今回は、SPA + API のセッション管理について 基礎を押さえた上で、
参考になる 安全性の ランキングを作成してみました。

また、SPA + API においてクッキーを利用する場合に必須となるCSRF 対策についても簡単に解説します。

SPA + API のセキュリティについて、包括的に学習を深めていきましょう。

# 今回の前提条件

まず、本記事で想定する構成について整理しておきます。

- **フロントエンド**: SPA (Single Page Application)
  - ブラウザ上で動作する JavaScript アプリケーションを 想定
- **バックエンド**: API サーバ
  - REST API を想定

そして、**SPA と API サーバは完全に異なるドメインに存在する**ものとします。

具体的には、以下のようなドメイン構成を想定します。

| 役割 | ドメイン                  |
| ---- | ------------------------- |
| SPA  | `https://app.example.com` |
| API  | `https://api.example.net` |

完全な別ドメインに存在するため、クッキーを利用する場合は以下の属性を設定します。

- `SameSite` 属性: `None`
- `Secure` 属性: `true`
- `HttpOnly` 属性: 場合による（後述）

また、API サーバは JSON を受け取り JSON を返すことを前提とします。
そのため、API は HTML フォーム送信を受け付けないものとします。

- `application/x-www-form-urlencoded`
- `multipart/form-data`
- `text/plain`

これらのコンテンツタイプは受け付けません。

何らかの方法で認証を済ませ、これからセッション管理のためのトークン文字列（セッショントークン）が発行される段階を想定します。

# セッション管理における 2 つのレイヤ

巷では「クッキーか JWT か」などの議論が行われることがあります。しかし、この議論は対立軸を誤っていると言えます。

セッション管理には **2 つのレイヤ**が存在します。

1. **トークン文字列がどのような形式か**
2. **トークン文字列をどこに保存し、どのように取り出して送信するか**

この 2 つのレイヤを分けて考えることが重要です。それぞれ詳しく見ていきましょう。

## 1. トークン形式

トークン形式には主に以下の種類があります。

### A. handle 型トークン

handle 型トークンは、API 側のデータベースにセッション情報を保存し
トークン文字列自体はそのセッション情報を一意に指し示す ID のみを持つ形式です。

API 側はトークン文字列を受け取ると、データベースを参照してセッション情報を取得します。

**例**: セッション ID、ランダム文字列トークン

トークン文字列はただ一意に指し示すだけであるため、十分ランダムに生成された文字列であることが好ましいです。

**利点**:

- API 側でセッション情報を管理できるため、**セッションの失効が可能**
- API 側でセッション情報を管理できるため、**セッション情報が古くならない**

**欠点**:

- API 側でセッション情報を管理するため、**情報を保存するインフラコストが発生**する
- API 側でセッション情報を管理するため、**スケーラビリティが低下**する可能性がある
- API 側でセッション情報を管理するため、
  トークンの情報取得に **DB アクセスが発生しレイテンシが増加**する

### B. assertion 型トークン

assertion 型トークンは、トークン文字列自体にセッション情報を含む形式です。

API 側はトークン文字列を受け取ると、トークン文字列を解析してセッション情報を取得します。

**例**: JWT

トークン文字列自体にセッション情報を含むため、トークン文字列は長く複雑になります。
ほとんどの場合、暗号化や署名、またはその両方が利用されます。

**利点**:

- API 側でセッション情報を管理しないため、**インフラコストが発生しない**
- API 側でセッション情報を管理しないため、**スケーラビリティが向上**する
- API 側でセッション情報を管理しないため、
  トークンの情報取得に **DB アクセスが発生せずレイテンシが低減**する

**欠点**:

- API 側でセッション情報を管理しないため、**セッションの失効が困難**
- API 側でセッション情報を管理しないため、**セッション情報が古くなる可能性**がある

これらの欠点の解消も不可能ではありませんが、
結局これらの欠点を解消しようとすると DB アクセスが必要となり、handle 型トークンの性質と似通ってしまいます。

### C. 短命 assertion 型トークン + 長命 handle 型トークン

2 つのトークンを組み合わせて利用することで、お互いの欠点を補うことも可能です。

assertion 型トークンを短命に設定し、長命の handle 型トークンで assertion 型トークンを再発行します。
同時に新しい長命 handle 型トークンを発行し、古いものを無効化します。

このように設計することで、assertion 型と handle 型の利点を組み合わせることができます。

**assertion 型トークンの欠点への対処**:

- **セッションの失効が困難**:
  assertion 型トークンを短命に設定することで、
  もし盗まれた場合でも有効期限が切れれば 実質的にセッションを無効化可能
  また 長命 handle 型トークンは失効可能であるため
  盗まれた場合でも API 側で失効させることでセッションを無効化可能

**handle 型トークンの欠点への対処**:

- **インフラコストが発生・スケーラビリティが低下・レイテンシが増加**
  セッションとしては頻繁にアクセスする短命 assertion 型トークンを利用することで
  普段のアクセスにおける DB アクセスを低減し それぞれの欠点を緩和可能
  長命 handle 型トークンは短命 assertion 型トークンの再発行時にのみ利用されるため
  頻繁にアクセスされることがなくそれぞれの欠点はそれほど問題にならない

## 2. トークン保存場所・送信方法

次に、トークンをどこに保存し、どのように送信するかについて見ていきます。

### α. httpOnly クッキーに保存しブラウザが自動送信

ブラウザの提供するクッキー機能を利用する方法です。
httpOnly 属性を付与することで JavaScript からのアクセスを防止します。
API へのリクエスト時にブラウザが自動的にクッキーを送信します。

セッションクッキーによる古典的なセッション管理手法といえます。

**利点**:

- 攻撃者によってブラウザに悪意のある JavaScript コードが送り込まれた場合でも
  JavaScript からクッキーにアクセスできないため
  **セッション情報そのものが盗まれるリスクを低減**できる

:::message
httpOnly 属性付きクッキーに保存した場合でも、
悪意ある JavaScript のすべての活動に対して安全になるわけではありません。

例えば、悪意ある JavaScript から API にアクセスすることは可能です。

API アクセスにおける被害拡大の例として、例えば パスワード変更 API を考えてみましょう。

攻撃者は httpOnly 属性付きクッキーに保存されたセッショントークンを直接取得することはできませんが、
そのクッキーを fetch API などで API に送信することは可能です。

そのため攻撃者が 悪意あるJavaScript を通して パスワード変更 API を呼び出し、パスワードを変更することで
攻撃者がアカウントに永続的にアクセスできるようになる可能性があります。
このようなアカウントアクセス拡大に繋がる機能を提供するAPIを実装する際は、再認証を要求するなどの対策を行うことが重要です。

あくまでも「永続的にセッション情報が盗まれるリスクを低減できる」という意味であり、
悪意ある JavaScript がブラウザで動作している間は API へのアクセスが可能であることに注意してください。

:::

**欠点**:

- **しっかり CSRF 対策を行う必要がある**
  CSRF は設定を誤らなければ防げる攻撃であるため 十分に注意して対策を行うこと
  SPA + API の場合の CSRF 対策については後述

なお、この場合のクッキーの属性については以下の通りです。

- `SameSite`: `None`
  - 完全な別ドメイン間でクッキーを送信するために必要
- `Secure`: `true`
  - HTTPS 通信時のみクッキーを送信
- `HttpOnly`: `true`
  - JavaScript からのアクセスを防止

### β. ブラウザの提供するストレージやメモリに保存し JavaScript でその都度取り出して送信

JavaScript を用いてストレージやメモリにトークン文字列を保存し、
API へのリクエスト時に JavaScript でトークン文字列を取り出し
API リクエストヘッダなどにトークン文字列を付与して送信する方法です。

近年の SPA でよく利用される手法です。

トークンの保存場所としては主に以下の 2 つがあります。

- ストレージ
  - localStorage
  - sessionStorage
  - IndexedDB
- メモリ
  - React の state
  - JavaScript の変数

**利点**:

- JavaScript で API リクエストヘッダなどにトークン文字列を付与して送信するため
  悪意ある第三者のオリジンからのリクエストではトークン文字列を付与できず CSRF 攻撃を防げる

**欠点**:

- 攻撃者によってブラウザに悪意のある JavaScript コードが送り込まれた場合
  その JavaScript からストレージやメモリに保存されたトークン文字列にアクセスできるため
  **永続的にセッション情報が盗まれるリスク**がある

β の手法ではトークン文字列の保存・取り出しを JavaScript が担うため、
悪意ある JavaScript の実行によるトークン奪取問題を根本的に解決することはできません。

そのため対処療法として、**悪意ある JavaScript の実行を防ぐ対策が重要**となります。
悪意ある JavaScript の実行を防ぐ対策についてはここでは解説しません。

### 非推奨: httpOnly でないクッキー

httpOnly でないクッキーにトークンを保存する方法は、
クッキーの利点が活かせず、またJavaScript からアクセス可能であるため β の手法と同様の欠点を持ちます。
そのため、今回の記事ではこれを最初から非推奨とします。

# セッション管理の安全性ランキング

上記の 2 つのレイヤを組み合わせた場合の安全性ランキングを作成しました。

なお、簡単に比較できないものも存在するため、
**ハッセ図**という概念を利用し、安全性の高低を表現しつつ 高低差を単純に比較できないものを枝分かれで表現しています。

また、登場するCSRF脅威について **適切に対策すれば問題ないものとします**。
そのため、ランキングにおいて CSRF 脅威は考慮していません。
また、適切な CSRF 対策については後述します。

## 1 位: A on α（handle 型トークン on httpOnly クッキー）

API 側でセッション情報を管理し失効可能 かつ JavaScript からのアクセスを防止可能な手法です。
古典的なセッション管理手法であり、最も安全性が高いと考えられます。

昔はサーバが一台のことも多く、バックエンドサーバによるスケーラビリティの問題が今より少なかったため、
この手法で何ら問題はなく一般的な構成でした。

**メリット**:

- セッションの失効が可能 → 永続的なトークン奪取リスクを低減

**デメリット**:

- インフラコストが発生
- スケーラビリティが低下
- レイテンシが増加
- CSRF 対策が必要（適切に対策すれば問題なし）

**具体的なライブラリ**:

- **Express.js: express-session**
  - https://github.com/expressjs/session
  - DB を抽象化したストアという概念を持ち、サーバ側にセッション情報を保存可能
  - 様々な DB 用のストア実装が存在
  - httpOnly 属性付きクッキーに handle 型トークンを保存
- **Spring Boot: Spring Session**
  - https://spring.pleiades.io/spring-session/reference/guides/boot-redis.html
  - Redis などの DB にセッション情報を保存可能
  - httpOnly 属性付きクッキーに handle 型トークンを保存
- **Auth.js: Database Session**
  - https://authjs.dev/concepts/session-strategies#database-session
  - httpOnly クッキーに handle 型トークンを保存
  - 対応する DB にセッション情報を保存可能
    - https://authjs.dev/getting-started/database

## 2 位: C on α（短命 assertion 型トークン + 長命 handle 型トークン on httpOnly クッキー）

API 側でセッション情報を管理し、長命側は失効可能な、比較的安全なセッション管理手法です。

**メリット**:

- 長命側トークンであれば失効が可能 → 永続的なトークン奪取リスクを低減
- 普段のアクセスにおける DB アクセスを低減し、インフラコストを抑制、スケーラビリティを向上、レイテンシを低減

**デメリット**:

- 短命側トークンが盗まれた場合のリスクは残る（ただし短命であるためリスクはできるだけ低減）
- CSRF 対策が必要（適切に対策すれば問題なし）

**具体的なライブラリ**:

- **SuperTokens**
  - https://supertokens.com/docs/references/how-supertokens-works
  - 内部的に短命 assertion 型トークン + 長命 handle 型トークンの組み合わせを利用
    - 短命 assertion 型トークン = アクセストークン（JWT）
    - 長命 handle 型トークン = リフレッシュトークン（ランダム文字列）
  - 双方ともに httpOnly 属性付きクッキーに保存
    - 長命側トークンで短命側トークンを再発行し、同時に新しい長命側トークンを発行し古いものを無効化する
  - SuperTokens は外部サーバとして動作するが、SPA と直接通信はせず API サーバのみと通信する。API サーバはトークンの発行・検証を SuperTokens サーバに委託する形。とはいえ SPA から見れば API サーバがセッション管理を行っているのと変わらない。

:::message alert
**問題点**: この形を実装するフレームワークがほとんどありません。かろうじて SuperTokens が対応している程度です。

筆者の意見では、この形が最もバランスの良いセッション管理手法であると考えますが、現状で対応しているフレームワークはほとんどありません。自前で対応しようとすると独自実装となりコストが高く、またセキュリティにおける独自実装はそれ自体がセキュリティリスクを招く可能性があるため注意が必要です。
:::

## 3 位: B on α（assertion 型トークン on httpOnly クッキー）

JavaScript からのアクセスを防止可能な手法です。モダンな API フレームワークでセッション管理のミドルウェアを利用すると、この形になることが多いです。

**メリット**:

- JavaScript からのアクセスを防止可能 → 永続的なトークン奪取リスクを低減

**デメリット**:

- API 側でセッション情報を管理しないため失効が困難 → 永続的なトークン奪取リスクが残る
- CSRF 対策が必要（適切に対策すれば問題なし）

**具体的なライブラリ**:

- **Hono: hono/session**
  - https://github.com/honojs/middleware/tree/main/packages/session
  - 内部的に JWE 形式の assertion 型トークンを保存
  - デフォルトで httpOnly 属性付きクッキーに保存
- **Auth.js: JWT Session**
  - https://authjs.dev/concepts/session-strategies#jwt-session
  - httpOnly クッキーに assertion 型トークンを保存

## 4 位: C on β（短命 assertion 型トークン + 長命 handle 型トークン on ブラウザストレージやメモリ）

API 側でセッション情報を管理し、長命側は失効可能な手法です。Auth0 などの外部認可サーバを用いた SPA + API のセッション管理でよく利用されます。

**対応関係**:

- 短命 assertion 型トークン = アクセストークン（JWT）
- 長命 handle 型トークン = リフレッシュトークン（ランダム文字列）
- トークンはそれぞれメモリに保存されるが、指定が可能

**緩和策**: Web Worker のメモリへの保存

- リフレッシュトークンは Web Worker のメモリ内に保存されるため、悪意ある JavaScript からのアクセスが比較的困難

トークン自体の発行は API サーバではなく外部の Auth0 サーバが担当します。SPA が Auth0 サーバと直接やり取りし、アクセストークン・リフレッシュトークンを受け取りメモリに保存します。その後 SPA が API サーバにアクセストークンを付与してリクエストを送信し、API サーバがアクセストークンを受け取りそれを検証します。検証の手順を間違えると脆弱性を招くリスクがあるため注意が必要です。

**メリット**:

- 長命側トークンであれば失効が可能 → 永続的なトークン奪取リスクを低減
- 短命側トークンが盗まれた場合のリスクは残る（ただし短命であるためリスクはできるだけ低減）
- 双方ともに CSRF 対策が不要

**デメリット**:

- 短命側トークン及び長命側トークンが JavaScript からアクセス可能であるため、永続的なトークン奪取リスクが残る（特に長命側トークンは永続的に奪取されるリスクが高い）
- 悪意ある JavaScript の実行を防ぐ対策が重要

**具体的なライブラリ**:

- **Auth0 SDK: auth0-spa-js（リフレッシュトークン利用）**
  - https://auth0.com/docs/libraries/auth0-single-page-app-sdk
  - `useRefreshTokens: true` オプションを指定することで対応可能
  - リフレッシュトークン奪取への緩和策として、リフレッシュトークンは Web Worker のメモリ内に保存され、悪意ある JavaScript からのアクセスが比較的困難

:::message
**余談: OAuth との関連性と注意点**

この手法は、API サーバ単体というよりも、Auth0 などの外部認可サーバを用いた SPA + API のセッション管理でよく利用される手法です。この実装において OAuth のアクセストークン・リフレッシュトークンが流用されるケースが非常に多いです。

OAuth は仕様上アクセストークン・リフレッシュトークンを発行します。

- access token は短命 assertion 型トークンに該当
- refresh token は長命 handle 型トークンに該当

このアクセストークンをセッショントークンとして流用しているイメージです。OAuth のアクセストークン・リフレッシュトークンをセッション管理に流用すると、自然と C on β/α の形にたどり着きます。

しかし、筆者の意見では **OAuth のアクセストークンをセッションに流用するのは推奨しません**。OAuth のアクセストークンは本来リソースサーバーへのアクセス権を示すものであり、セッション管理のために設計されていないためです。

また、検証を怠ると脆弱性を招くリスクもあります。詳しくは以前の記事を参照してください。

https://zenn.dev/calloc134/articles/oauth-cross-api-vuln-attack
:::

## 同率 4 位: B on β（assertion 型トークン on ブラウザストレージやメモリ）

SPA でよく利用される手法ですが、安全性は低いです。

**メリット**:

- CSRF 対策が不要

**デメリット**:

- API 側でセッション情報を管理しないため失効が困難 → 永続的なトークン奪取リスクが残る
- トークン文字列が JavaScript からアクセス可能であるため、永続的なトークン奪取リスクが残る
- 悪意ある JavaScript の実行を防ぐ対策が重要

**具体的なライブラリ**:

- **Auth0 SDK: auth0-spa-js（リフレッシュトークン不使用）**
  - https://auth0.com/docs/libraries/auth0-single-page-app-sdk
  - `useRefreshTokens: false`（デフォルト）オプションを指定することで対応可能
  - assertion 型トークン = アクセストークン（JWT）
  - リフレッシュトークンが存在しないこと以外は C on β と同じ

:::message
**余談: B on β と C on β の安全性比較**

B on β の場合、assertion 型トークンしか存在しないためトークンを奪取されると永続的にアクセスされます。ただし C on β も長命 handle 型トークンが奪取された場合は同等のリスクがあります。

どちらの手法も β であるため、どのみち悪意ある JavaScript によるトークン奪取による永続的アクセスのリスクが存在します。assertion 型トークンの有効期限に左右されるため一概に比較できず、そのため同率としました。

B on β において assertion 型トークンを短命に設定している場合、C on β よりも安全といえる可能性もあります。逆に Web Worker による長命 handle 型トークン奪取の緩和策を用いている場合は、C on β の方が安全といえる可能性もあります。
:::

## 非推奨: B on non-httpOnly cookie

assertion 型トークン on httpOnly でないクッキーは、JavaScript からアクセス可能であるため β の手法と同様の欠点を持ちます。さらに CSRF 対策も必要となるため、これを採用するメリットはほとんどありません。α を利用する場合も同様です。

# 安全性ランキング考察

先程のランキングの強さを比較してみましょう。

**1 位 → 2 位**:

- handle 型トークン on httpOnly クッキー から
- 短命 assertion 型トークン + 長命 handle 型トークン on httpOnly クッキー へ
- **増えた欠点**: assertion 型トークンが盗まれた場合のリスク（低）
  - 短命 assertion 型トークンが盗まれた場合、assertion 型トークンは API 側で失効させることができず、永続的アクセスのリスクがあるという欠点が増える
  - ただし、短命であるためリスクは低い

**2 位 → 3 位**:

- 短命 assertion 型トークン + 長命 handle 型トークン on httpOnly クッキー から
- assertion 型トークン on httpOnly クッキー へ
- **増えた欠点**: assertion 型トークンが盗まれた場合のリスク（高）
  - assertion 型トークンが盗まれた場合、assertion 型トークンは API 側で失効させることができず、永続的アクセスのリスクがあるという欠点が増える
  - またこの場合、assertion 型トークンは長命であることが多いためリスクが高い

**2 位 → 4 位**:

- 短命 assertion 型トークン + 長命 handle 型トークン on httpOnly クッキー から
- 短命 assertion 型トークン + 長命 handle 型トークン on ブラウザストレージやメモリ へ
- **増えた欠点**: トークン文字列が JavaScript からアクセス可能であること
  - 悪性 JavaScript がブラウザに送り込まれた場合、JavaScript からトークン文字列にアクセスできるため、永続的にセッション情報が盗まれるリスクがあるという欠点が増える
  - 長命 handle 型トークンが盗まれた場合のリスク自体は 2 位と変わらない

**3 位 → 4 位（2）**:

- assertion 型トークン on httpOnly クッキー から
- assertion 型トークン on ブラウザストレージやメモリ へ
- **増えた欠点**: トークン文字列が JavaScript からアクセス可能であること
  - 悪性 JavaScript がブラウザに送り込まれた場合、JavaScript からトークン文字列にアクセスできるため、永続的にセッション情報が盗まれるリスクがあるという欠点が増える
  - assertion 型トークン奪取による永続的アクセスのリスク自体は 3 位と変わらない

**4 位 → 非推奨**:

- assertion 型トークン on ブラウザストレージやメモリ から
- assertion 型トークン on httpOnly でないクッキー へ
- **増えた欠点**: CSRF 対策が必要となること
  - CSRF 対策が不要であるという利点が失われるという欠点が増える

これを図に表すと以下のハッセ図のようになります。安全性の高いものほど上位に位置し、単純に比較できないものは枝分かれで表現しています。

```
                    1位: A on α
                         │
                    2位: C on α
                       ／    ＼
                 3位: B on α   4位: C on β
                       ＼    ／
                   同率4位: B on β
                         │
                    非推奨: B on non-httpOnly cookie
```

# SPA + API における CSRF 周りと対策（Hono を例に）

API の CSRF 対策についても登場したため、ここでベストプラクティスを整理しておきます。

## 前提知識

### オリジン（Origin）

オリジンとは、**スキーム + ホスト + ポート**の三要素です。三要素がすべて一致している場合にのみ同一オリジンとみなされます。

| ドメイン                  | スキーム | ホスト          | ポート                    |
| ------------------------- | -------- | --------------- | ------------------------- |
| `https://app.example.com` | https    | app.example.com | 443（省略時のデフォルト） |
| `https://api.example.net` | https    | api.example.net | 443（省略時のデフォルト） |

これら 2 つのオリジンは**異なるオリジン**であるとみなされます。

### サイト（Site）

サイトとは、**トップレベルドメイン + その直下のドメイン名**の組み合わせです。いわゆる eTLD+1（effective Top Level Domain + 1）と呼ばれるもので、トップレベルドメインの一つ左側のドメイン名までを含みます。例えば `co.uk` ドメインの場合はさらにその左側のドメイン名までを含みます。

**別ドメインの場合**:
| ドメイン | eTLD+1 |
|----------|--------|
| `https://app.example.com` | example.com |
| `https://api.example.net` | example.net |

→ **異なるサイト**

**サブドメインの場合**:
| ドメイン | eTLD+1 |
|----------|--------|
| `https://app.example.com` | example.com |
| `https://api.example.com` | example.com |

→ **同一サイト**

### CSRF（Cross-Site Request Forgery）

CSRF（クロスサイトリクエストフォージェリ）とは、悪意ある第三者のオリジンからのリクエストにより、被害者のアカウントで意図しない操作が実行される攻撃です。

**JavaScript を用いた CSRF 攻撃の例**:

1. 被害者が攻撃者サーバにアクセス
2. 攻撃者サーバが提供する JavaScript が被害者のブラウザ上で実行される
3. 悪意ある JavaScript が fetch API などを用いて API サーバにリクエストを送信（`credentials: "include"` を指定）
4. ブラウザが自動的にクッキーを送信
5. API サーバがリクエストを処理し副作用のある操作を実行

**今回の想定**: JavaScript を用いた CSRF 攻撃を主に想定します。そのため HTML フォームを送信するような昔ながらの CSRF 攻撃は想定しません。フォーム送信に関するコンテンツタイプはそもそも API サーバで拒否します。

### XS-Leak（Cross-Site Leak）

XS-Leak（クロスサイトリーク）とは、悪意ある第三者のオリジンからのリクエストにより、被害者のアカウントで実行された操作の結果が攻撃者に漏洩する攻撃です。

本来であれば CSRF とは区別されますが、今回は CSRF 対策と合わせて考慮します。

## JavaScript を用いた CSRF / XS-Leak 攻撃に対する防御策

以下の防御策を適用すれば、ほとんどの CSRF 攻撃を防げます。

### HTTP メソッドの切り分け

まず、副作用のある API と副作用のない API を HTTP メソッドで切り分けることが重要です。

**副作用のある API**: API の呼び出しによりサーバ側の状態が変更される API

- 例: ユーザ登録 API、パスワード変更 API、商品購入 API
- **POST, PUT, PATCH, DELETE などの unsafe method に限定**

**副作用のない API**: API の呼び出しによりサーバ側の状態が変更されない API

- 例: ユーザ情報取得 API、商品一覧取得 API
- **GET, HEAD, OPTIONS などの safe method に限定**

この切り分けは開発者が意識して行う必要があります。

**CSRF 防御の目的**:

- 副作用のある API に対しては「**実行させない**」を目的とした防御策を適用
- 副作用のない API に対しては「**実行の結果を見られない**」を目的とした防御策を適用

### 適切な CORS（Cross-Origin Resource Sharing）設定による SOP（Same-Origin Policy）の厳格な適用

`hono/cors` ミドルウェアを利用して、ポリシーにより被害者のブラウザにおける fetch API の動作に制限をかけます。

**SOP とは**: 開いているサイトの JavaScript で fetch API などを用いて別オリジンの API にアクセスする行為には制限がかかっています。この制限を SOP（同一生成元ポリシー）と呼びます。

**CORS とは**: SOP の制限を緩和するためのルールが CORS です。Web 技術の発展により、別オリジン間での API アクセスの需要が高まったため、CORS を用いて SOP の制限を緩和することができるようになりました。allowlist のようなイメージで、アクセスを許可する出どころのオリジンを指定できます。

SOP の制限および CORS が CSRF 対策そのものという訳ではありませんが、**CORS の適切な設定による SOP の厳格な制限適用 + 副作用の有無による API のメソッド分離**を合わせることで、CSRF 攻撃の脅威を大幅に低減できます。

**CORS ポリシーの設定内容**:

- CORS 設定で SPA（正規のサイト）のオリジンのみを許可
- これにより:
  - SPA（正規のサイト）から行われる API へのアクセスは許可される
  - 攻撃者サーバ（悪意あるサイト）から行われる API へのアクセスはブラウザが制限する

**CORS 設定を適用した際の動作**:

**副作用のある API（unsafe method）の場合**:

1. fetch API などで unsafe method を送信しようとすると、まずブラウザがプリフライトリクエスト（OPTIONS メソッド）を送信
2. API サーバがプリフライトリクエストに対して、ヘッダに CORS ポリシー情報を含んだレスポンスを返す
3. ブラウザがレスポンスを確認し、ポリシーで許可されていない場合は JavaScript（fetch API など）がエラーとなり本リクエストを送信しない
4. これにより「**実行させない**」ことを実現

**副作用のない API（safe method）の場合**:

1. ブラウザが直接本リクエスト（safe method）を送信
2. API サーバがレスポンスを返す（このときヘッダに CORS ポリシー情報を含む）
3. ブラウザがレスポンスを確認し、ポリシーで許可されていない場合は JavaScript（fetch API など）がエラーとなりレスポンス内容を取得できない
4. これにより「**実行の結果を見られない**」ことを実現

:::message
**余談: unsafe method におけるプリフライトリクエストについて**

unsafe method であっても特定の条件下ではプリフライトリクエストが送信されない場合があります。例えばコンテンツタイプがフォーム送信（`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`）の場合などです。

これらのケースは今回の攻撃想定とはズレるため、ここでは解説しません。今回の解説ではこれらのケースをブロックすることを前提とします（後述）。
:::

### unsafe method において `Origin` ヘッダ・`Referer` ヘッダの検証（allowlist 利用）

自前でミドルウェアを実装する必要がありますが、CORS 設定に加えて二重の防御策として有効です。

CORS ポリシーはブラウザが自主的に fetch API などの動作を制限する仕組みです。それに対し、API サーバ側でも検証を行うことで、より確実に CSRF 攻撃を防げます。

fetch API などを用いてリクエストを送信する場合、ブラウザが自動的に `Origin` ヘッダを付与します。`Origin` ヘッダとは、リクエストがどのオリジンから送信されたかを示すヘッダです。

SPA（正規のサイト）のオリジンのみを allowlist に登録し、リクエストが来た際に `Origin` ヘッダの値を検証します。allowlist に登録されていないオリジンからのリクエストは拒否します。

これにより:

- SPA（正規のサイト）から行われる API へのアクセスは許可される
- 攻撃者サーバ（悪意あるサイト）から行われる API へのアクセスは拒否される

:::message
**余談**: 古いブラウザでは `Origin` ヘッダが付与されない場合があるため、その場合は `Referer` ヘッダも検証すると良いでしょう。`Referer` ヘッダとは、リクエストがどの URL から送信されたかを示すヘッダです。

古いブラウザに対応する場合の処理の流れ:

1. まず `Origin` ヘッダを検証
2. `Origin` ヘッダが存在しない場合は `Referer` ヘッダを検証
3. どちらも allowlist に登録されていないオリジンからのリクエストは拒否
   :::

### コンテンツタイプが `application/json` となっているかのチェック

以下のコンテンツタイプをすべて拒否することができます。

- `application/x-www-form-urlencoded`
- `multipart/form-data`
- `text/plain`
- コンテンツタイプの欠落

昔ながらの CSRF 攻撃を防ぐ対策として有効です。今回の攻撃想定と異なる CSRF 攻撃についてすべて防ぐことができます。ただし、自前でミドルウェアを実装する必要があります。

### SameSite 属性は利用できない

今回は SPA と API が完全別ドメインに存在するため、サイトも別サイトとなります。そのため、異なるサイト間のクッキー送信となります。

異なるサイト間のクッキー送信を許可するには、`SameSite` 属性を `None` に設定する必要があります。`SameSite` 属性を `Lax` や `Strict` に設定すると、ブラウザがクッキーを送信できなくなるため、CSRF 防御策としては利用できません。

なお、`SameSite` 属性が `None` の場合、`Secure` 属性を付与する必要があることに注意してください。

### 注意点: `hono/csrf` ミドルウェアは SPA + API 構成においてあまり効果がない

SPA + API 構成の場合、`application/json` のリクエストボディしか受け付けない場合が多いです。一方、`hono/csrf` ミドルウェアは HTML form の送れるコンテンツタイプに対して CSRF 防御を提供するものです。

- `application/x-www-form-urlencoded`
- `multipart/form-data`
- `text/plain`

そのため、SPA + API 構成においてはあまり効果がありません。

# おわりに

今回は、SPA + API のセッション管理について、安全性の Tier 表を考えてみました。
加えて、SPA + API においてクッキーを利用する場合に必須となる CSRF 対策についても解説しました。
安全な手法を取るに越したことはありませんが、安全性を高めるほど、利便性やインフラコストとのトレードオフが発生します。
自分のアプリケーションにとって、どの程度の安全性が必要かを見極め、適切なセッション管理手法を選択しましょう。

読んでいただき、ありがとうございました。
