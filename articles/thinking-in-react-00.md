---
title: "再考React - 第0回 宣言的UIとUIフレームワーク"
emoji: "⚛️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react", "frontend", "javascript", "typescript"]
published: false
---

# はじめに

:::message alert

React Tokyo フェス 2026 に合わせて公開する予定でしたが、
挿絵の進捗が良くないこと・内容の裏取りが間に合っていないことも含め、
しばらくは限定公開のまま、シリーズ終了後 推敲しつつ、
準備ができ次第公開とします！

もしかすると4月以降になってしまうかも・・・
お手数をおかけします・・・！

:::

こんにちは。かろっく@calloc134 です。

皆さんは React を使っていて、以下のような感想を持ったことはありませんか？

「React ってやたら複雑な仕組みを持っているけど、なぜこんな設計なんだろう」
「useEffectの使い方がよくわからず、雰囲気で使ってる」

この記事シリーズではReact の設計思想を深掘りし、
React がなぜこのような設計になっているのか、
それによりどのようなことを実現しようとしているのかを解説していきます。

今回の解説は 第 0 回として、React の思想を語る前に、
React を含む UI フレームワーク全般に共通する
「宣言的 UI」という考え方について解説していきます。

:::message
今回は、Web における UI フレームワークに絞って解説を行います。
そのため、React Native などについては言及を避け、

実際のUI = 実際の DOM、いわゆる **実DOM** として説明を行います。
:::

# 宣言的 UI とは

宣言的 UI とは、
**How（UI をどう描くか）** を記述せず、
**What（UI がどうあるべきか）を記述するスタイル**のことです。

従来の命令的な UI 構築では、UI を描画するために

- 表示したい見た目を、開発者が手動で挿入
- データが変化したら、開発者が見た目を手動で更新

といった手順を、手動でひとつひとつ記述する必要がありました。

![](/images/thinking-in-react-00/2026-02-27-22-27-59.png)

一方、宣言的 UI では

- 表示したい見た目を記述するだけで、見た目が自動で挿入される
- データが変化したら、見た目が自動で更新される

といった形で、
**「この状態のときは、こういう UI であるべき」という最終的な姿だけを記述します。**

![](/images/thinking-in-react-00/2026-02-27-23-14-52.png)

宣言的 UI を実現するために、
React や Vue などの UIフレームワークのような仕組みを用いて
実DOMの 描画・更新を任せる、という構図になります。

- 命令的 UI: `document.createElement` や `innerHTML` を使って
  実DOM を直接操作するスタイル
- 宣言的 UI: React や Vue など、何らかの仕組みに
  実DOMの描画・更新を任せるスタイル

## 要素という概念

宣言的 UI を採用するフレームワークには、
**仮想的に 理想形の見た目、**
つまり **理想のUIを表現したオブジェクト** である「要素」が存在します。

![](/images/thinking-in-react-00/2026-02-27-22-57-40.png)

開発者は、この「要素」本体および、
要素を生成する何らかの仕組みを実装します。

逆に、この要素から実際の UI を生成する処理は
宣言的 UIフレームワークが担当してくれるため、
開発者は UI の詳細な更新ロジックを意識する必要がなくなります。

要素を生成する仕組みは、関数やクラスで実装を行います。

![](/images/thinking-in-react-00/2026-02-27-23-01-25.png)

開発者が実装した 要素を生成する仕組みをフレームワークに与えると、
フレームワークはそれを実行し、要素を取得します。
その後、要素をもとに UI を描画・更新します。

![](/images/thinking-in-react-00/2026-02-27-23-05-12.png)

## フレームワークによる差分検知と更新

UIの描画・更新について、詳しく見ていきましょう。

何らかの方法でフレームワークが要素を生成すると、
**フレームワークは以下の 2 つを比較し、差分検知を行います。**

1. フレームワーク内部に保持されている**過去の状態**
2. 新しく作成された **「要素」**

この比較の結果、以下のものが得られます。

- UI の差分情報
- (新しい内部状態)

![](/images/thinking-in-react-00/2026-02-27-23-47-26.png)

フレームワークは、洗い出した差分を実 DOM に適用することで実際の UI を更新します。
また、今回新しく作成した現在の内部状態は
次回以降利用するためにフレームワーク内部に保持されます。

## 宣言的 UI の利点

この設計により、
**UI 更新の詳細な手続きをフレームワークに任せることができる**という大きな利点が産まれます。

開発者は「今この状態ならこういう見た目」という対応関係だけを記述すればよく、
「前の状態からどう変更するか」という差分の計算はフレームワークが担当してくれます。

## 具体例

### React の場合

React では、開発者は要素を生成する仕組みを**関数（関数コンポーネント）** で実装します。

```tsx
function Counter({ count }: { count: number }) {
  return <div>Count: {count}</div>;
}
```

ここで返される要素は、**React 要素**と呼ばれるオブジェクトであり、
これが React における「要素」に相当します。

実行時に React が要素生成関数、つまり関数コンポーネントを呼び出し、React 要素を受け取ります。
あとは React が要素の差分を検知し、実 DOM に最小限の変更を加えます。

:::message

React では、この React要素を
JSX という HTML風の記法で記述することができます。
ここでは詳しくは解説しません。

:::

### Vue の場合

Vue では通常、開発者はテンプレートを記述します。

```ts
<template>
  <div>Count: {{ count }}</div>
</template>

<script>
export default {
  props: {
    count: Number
  }
}
</script>
```

このテンプレートは、コンパイル時にレンダー関数へ変換されます。

```ts
export function render(_ctx, _cache) {
  return (
    _openBlock(),
    _createElementBlock(
      "div",
      null,
      "Count: " + _toDisplayString(_ctx.count),
      1 /* TEXT */,
    )
  );
}
```

ここで return されるオブジェクトは **VNode**と呼ばれ、
これが Vue における「要素」に相当します。

実行時には、Vue がこのレンダリング関数を呼び出し、要素を受け取ります。
あとは Vue が要素の差分を検知し、実 DOM に最小限の変更を加えます。

## 差分検知アルゴリズム: Reconciliation

差分検知アルゴリズムは **Reconciliation** と呼ばれます。

Reconciliation とは UI のみに存在する単語ではなく、
宣言的なシステムを構築する際に広く用いられる概念です。
例えば、Kubernetes の Reconciliation Loop も同様の概念に基づいています。

「あるべき姿」と「現在の姿」を比較し、差分を埋めるという考え方は、
宣言的システム全般に通じるものであるといえるでしょう。

# React の思想を語る前に

ここまでは、React を含む UI フレームワーク全般に共通する考え方を解説してきました。
これ以降は、React 特有の思想について解説していきます。

その前に、一つ重要な用語の整理をしておきます。

## 「仮想 DOM」という言葉を使わない理由

もしかすると、ここまでの解説で
「仮想DOM」 という単語を意図的に避けていることに気がついた方もいるかもしれません。

今回および以降の解説では **「仮想 DOM」という言葉を使いません**。
「仮想 DOM」という言葉は、誤解を招きやすいためです。

仮想 DOM という言葉は、以下の 2 つの異なる概念を混同してしまいます。

1. **React が受け取る要素**
   - React 要素（仮想的に UI を記述したオブジェクト）
2. **React が内部的に保持する内部状態**
   - Fiber ツリー（仮想的に状態を表現したデータ構造）

ここからは それぞれ **「React 要素」** と **「Fiber ツリー」** と呼び、
これら2つを明確に区別して説明していきます。

## 要点まとめ

- 宣言的 UI の本質は、**How ではなく What を記述する**こと
- フレームワークは **過去の内部状態と今回の要素を比較**して差分更新する
- 開発者の主な責務は **「状態と見た目の対応関係」を宣言すること**
- 本シリーズでは「仮想 DOM」を曖昧に使わず、**React 要素と Fiber ツリーを分けて捉える**

# おわりに

今回は、宣言的 UI と UI フレームワークの基本的な考え方について解説しました。

**宣言的 UI では、開発者は「UI がどうあるべきか」を記述するだけでよく、「どう更新するか」はフレームワークが担当してくれます。**
この設計により、コードの可読性・保守性が向上し、複雑な UI の構築が容易になります。

次回は、React 特有の思想である**純粋関数性**について解説していきます。
React がなぜ関数コンポーネントを推奨し、なぜ純粋性を重視するのか、
深掘りしていきましょう。
