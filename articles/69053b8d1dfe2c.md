---
title: "個人開発予約システム リファクタリング記録"
emoji: "🍣"
type: "tech" # tech: 技術記事 / idea: アイデア
topics:
  ["個人開発", "react", "hono", "リファクタリング", "クリーンアーキテクチャ"]
published: false
---

## はじめに

こんにちは。calloc134 です。
以前、授業内開発で部室予約システムを作成した記事を書きました。
https://zenn.dev/calloc134/articles/c24167f2fb6921

このプロダクトについて実際に大学の軽音楽部に働きかけたところ、採用していただけることになりました。
しかし、コードの流れが追いづらく、メンテナンス性や拡張性が低かったため、一週間かけてリファクタリングを行いました。
今回はそのリファクタリングについて書いていきます。

## リファクタリング前

### バックエンド

以下の URL から、当時のバックエンドのコードを確認できます。
https://github.com/calloc134/reserv-backend-lab/tree/8db7d41ce6c0485b32f2f6dcf4c9e6fd34342cd8

バックエンドには Hono というフレームワークを使用しています。
なんと、すべての処理を単一のファイルに書いてしまっています。そのため、行数は 1000 行を超えており、該当する処理を探すのが困難でした。

このコードでは値オブジェクトパターンを利用しており、ここで値のオブジェクトのロジックを表現しています。

https://github.com/calloc134/reserv-backend-lab/blob/8db7d41ce6c0485b32f2f6dcf4c9e6fd34342cd8/src/index.ts#L22-L95

しかし、レイヤ区分などはされておらず、コードの流れが追いづらい状態でした。

### フロントエンド

以下の URL から、当時のフロントエンドのコードを確認できます。
https://github.com/calloc134/reserv-frontend-lab/tree/d52f43403a59f36e11d2756ee2d4f102b20f60a5

フロントエンドには React を使用しています。
バックエンドに比べると、比較的ファイル分割ができています。
しかし、ページ内部に大量のステートが存在しており、また同じ見た目であってもコンポーネントで共通化を行っていないため、コードの重複が多くなってしまっていました。

https://github.com/calloc134/reserv-frontend-lab/blob/d52f43403a59f36e11d2756ee2d4f102b20f60a5/src/pages/WeeklyReservations.tsx#L27-L60

以上のような状態で導入するのは今後の継続的な開発に支障をきたすため、リファクタリングを行うことにしました。

## リファクタリングの進行: 全体の方針

リファクタリングを開始するにあたって、以下のような方針を立てました。

- Notion で自分のコードの現状を整理し、処理の流れを把握
- アーキテクチャに分割した際の構造を設計

いきなり手を動かすのではなく、現在記述されているコードを慎重にリバースエンジニアリングしてから検証を行う流れを意識しました。

## リファクタリングの進行: バックエンド

### Notion でのコードリーディング

まずは現在定義されているエンドポイントを整理し、どのようなエンドポイントがどのようなユースケースで呼び出しされているかを把握しました。

![](/images/69053b8d1dfe2c/2024-10-12-18-59-29.png)

![](/images/69053b8d1dfe2c/2024-10-12-19-01-26.png)
_他にも多数のエンドポイントが存在しています_

ここで、少しでも気になったことはここにメモを残しています。
考えたことが無駄にならないよう、メモを残すことは非常に重要だと感じました。

:::message
ここでは、リポジトリを集約ルートに厳密に一致させるかどうかについて悩んでいます。
:::

現在のアプリケーションで必要ないエンドポイントが見つかった場合は、積極的に削除を行いました。
またエンドポイント以外にも、現在利用されている値オブジェクトやユーティリティ関数を整理していきました。

![](/images/69053b8d1dfe2c/2024-10-12-19-04-24.png)
![](/images/69053b8d1dfe2c/2024-10-12-19-06-07.png)

ここの段階で背景のロジックに必要ない処理をユーティリティ関数に記述していたことを発見し、その部分のコードを削除しました。

### アーキテクチャの設計

ここから、アーキテクチャの設計とレイヤの分離を行いました。
今回のアプリケーションは、SQL によるロジックの表現が多い性質を持っています。

予約管理システムにおいて、以下のようなロジックが必要となります。

- 既に同じ日付と時限で予約が入っているかどうか
- 一週間以内に自分が予約した予約がないかどうか

このような特性のアプリケーションでは、ドメイン層(エンティティ内部)でロジックを表現できない形となります。
そのため、ドメイン層ではエンティティをクラスとして表現するのではなく、単純な型として表現し、リポジトリ層にロジックの実装を許容することにしています。

:::message
なお、リポジトリにロジックの実装を許容しているといっても、命名はロジックに立つスタンスではなく、物理的に行う事柄を表現するよう心がけています。
:::

また、今回実装するリポジトリについては考えるところがありました。
ドメイン駆動設計の戦術部分実装において、リポジトリというものはエンティティの集約ルートと一致させる必要があるとされています。

以下の記事より引用します。
https://zenn.dev/kohii/articles/e4f325ed011db8#%E9%9B%86%E7%B4%84

> エンティティは必ずしもフラットなデータクラスではなく、ネストしたバリューオブジェクトや子エンティティを持っている場合があります。このエンティティを起点とするオブジェクトのまとまりを「集約 (Aggregate)」と呼び、起点となるエンティティを「集約ルート (Aggregate Root)」と呼びます。

また、以下の記事からも引用します(以下の記事は Eric Evans のドメイン駆動設計からの引用を行なっているため、間接的な引用とさせていただきます)。
https://qiita.com/ROPITAL/items/2298abf06b92914ee35b#%E9%9B%86%E7%B4%84%E3%81%A8%E3%81%AF

> 「集約」とは、関連するオブジェクトの集まりのことで、データ変更の目的で 1 つの単位として扱います。" - Evans 126

つまり、集約とは関連するオブジェクトの集まりであり、データ変更の目的で 1 つの単位として扱うものであるとされています。その集約において一番根本となるエンティティを集約ルートと呼びます。
この集約エンティティを受け取るようにリポジトリを実装するのが、ドメイン駆動設計の戦術部分において推奨されている方法です。
しかし今回は利便性を踏まえ、おおむねこのパターンを踏襲しつつ、一部のリポジトリにおいては集約外のデータも取得することを許容することにしました。

具体的には、予約エンティティを取得するときに、部屋の情報も同時に取得するようなリポジトリ実装を行なっています。

:::message
このパターンについて、CQRS パターンを採用すればより適切な実装が出来ると考えられます。

CQRS パターンを簡単に説明すると、クエリとコマンドの責務を分離し、それぞれの責務に適したアーキテクチャを採用するというものです。
https://little-hands.hatenablog.com/entry/2019/12/02/cqrs
こうすることでリード用のエンティティとライト用のエンティティを分離することができ、より柔軟なアーキテクチャを実現できます。
ただし、今回は CQRS を採用するコストが高いと判断し、採用を見送りました。
以後、クエリ要件が複雑化した場合は、CQRS パターンを採用することを検討していきたいと考えています。
:::

リファクタリングは、以下の流れで進行しました。

1. 値オブジェクトをファイルに切り出し
2. ユーティリティ関数をファイルに切り出し
3. ハンドラを確認して DB アクセスのロジックをリポジトリに切り出し
4. リポジトリの返却する型をエンティティとして定義・切り出し
5. リポジトリのロジックをユースケースに切り出し

今回のアーキテクチャはクリーンアーキテクチャです・・・と言いたいところですが、クリーンアーキテクチャを厳密に適用することは難しいです。
アーキテクチャの本質とはコードの流れを追いやすくすることです。そのため、アーキテクチャのルールを厳密に適用する必要はありません。

今回採用したアーキテクチャは、構造で考えるとヘキサゴナルに近いかなと思います。アーキテクチャでおなじみの成瀬さんが提唱している ADOP というアーキテクチャを参考にしています。

https://nrslib.com/adop/

では、アーキテクチャの依存関係を図にしてみます。
型の依存関係は以下のとおりです。

```mermaid
graph TD
handler[ハンドラ] --> |型参照| DTO[DTO]
handler --> |型参照| domain[ドメイン]
repository[リポジトリ] --> |型参照| domain[ドメイン]
utility[ユーティリティ] --> |型参照| domain
usecase[ユースケース] --> |型参照| domain
```

呼び出しに伴うロジックの依存関係は以下のとおりです。

```mermaid
graph TD
handler[ハンドラ] --> |呼び出し| usecase[ユースケース]
usecase --> |呼び出し| repository[リポジトリ]
usecase --> |呼び出し| utility[ユーティリティ]
```

:::details まとめると

```mermaid
graph TD
handler[ハンドラ] --> |型参照| DTO[DTO]
handler --> |型参照| domain[ドメイン]
repository[リポジトリ] --> |型参照| domain[ドメイン]
repository <--> |呼び出し| domain
usecase[ユースケース] <--> |呼び出し| utility[ユーティリティ]
utility --> |型参照| domain
handler <--> |呼び出し| usecase
usecase <--> |呼び出し| repository
usecase --> |型参照| domain
handler <--> |呼び出し| domain
```

:::

### 最終的な実装

ディレクトリ構造は以下のとおりです。

![](/images/69053b8d1dfe2c/2024-10-12-19-43-26.png)

ハンドラ層(index.ts)では DTO 型をとるユーザのリクエストを受け取り、値オブジェクトやエンティティに変換してユースケース層に渡します。
ハンドラ層以外では基本的にドメイン層の型を使用しているため、ハンドラ層でのみ DTO を使用しています。
https://github.com/calloc134/reserv-backend-lab/blob/master/src/index.ts#L362-L427

ユースケース層では、エンドポイント毎のロジックを記述しています。

![](/images/69053b8d1dfe2c/2024-10-12-19-44-25.png)

https://github.com/calloc134/reserv-backend-lab/blob/master/src/usecase/reservation_or_disabled/postReservation.ts#L13-L75

ユースケース層では、リポジトリ層のロジックを呼び出しています。
リポジトリ層では DB (ユーザ集約については外部サービス)へのアクセスを行い、エンティティに変換して返却しています。
![](/images/69053b8d1dfe2c/2024-10-12-19-14-40.png)

また必要に応じて、ユースケース層はユーティリティ層のロジックを呼び出すことができます。

今回はドメイン層・ユーティリティ層・ユースケース層の全てで neverthrow を利用し、エラー処理を明示的に扱えるようにしています。
これによりコード量は増えますが、エラー処理の流れが明確になり、エラーハンドリングの漏れを防ぐことができます。
また、DTO からエンティティの変換をハンドラ層、DB からエンティティの変換をリポジトリ層で行うことで、ユースケース層でロジックの実装に専念できるようになりました。

## リファクタリングの進行: フロントエンド

フロントエンドのリファクタリングについても、同様の流れで進めました。

### Notion でのコードリーディング

