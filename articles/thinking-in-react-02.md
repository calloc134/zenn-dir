---
title: "再考React - 第2回 Reactのコア思想である純粋関数性"
emoji: "⚛️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react", "frontend", "javascript", "typescript"]
published: false
---

# はじめに

こんにちは。かろっく@calloc134 です。

前回は、宣言的 UI と UI フレームワークの基本的な考え方について解説しました。
今回からは、React 特有の思想について深掘りしていきます。

React の設計思想の中核にあるのは**純粋関数性**です。
React がなぜ関数コンポーネントを推奨し、なぜ純粋性を重視するのか、
その理由と恩恵を解説していきます。

# 要素を生成する仕組み = コンポーネント

前回の記事で、宣言的 UIフレームワークでは、
ユーザが UI を記述するための要素を生成する仕組みが必要であると説明しました。

React では、この要素を生成する仕組みを**コンポーネント**と呼びます。

前回の説明にそって解説すると、

> 開発者が実装した コンポーネント を React に与えると、
> React はコンポーネントを実行し、要素を取得します。
> その後、要素をもとに UIを描画・更新します。

という流れになります。

またReact では、このコンポーネントを
クラスではなく**関数**として定義することを推奨しています。
関数として定義されたコンポーネントを**関数コンポーネント**と呼びます。

そして、関数コンポーネントの実装において、
関数型プログラミングの概念やパターンを積極的に採用するよう開発者に求めています。
これが React の大きな特徴の一つです。

なお、解説にあたり、
以後 React の要素のことを明示的に **「React 要素」** と呼びます。

## 関数コンポーネントの純粋関数性

React は関数コンポーネントに対して、
以下の特性を持つように設計することを要求しています。

**A. 同じ入力に対して同じ出力を返す関数**

つまり、入力値以外の外部の値から読み取りを行わない関数です。

**B. 関数の実行で外部の値を変更しない関数**

つまり、戻り値以外の外部の値に書き込みを行わない関数です。

この A/B の両方を満たす関数を**純粋関数**とし、
React は関数コンポーネントが純粋関数であることを強く推奨しています。

```tsx
// 純粋な関数コンポーネントの例
function Greeting({ name }: { name: string }) {
  // 入力（props）のみに基づいて出力を返す
  return <h1>Hello, {name}!</h1>;
}
```

## 純粋関数性を保つことの意義

UI を記述する React 要素を生成する関数コンポーネントが
`f(...) = React 要素` という純粋関数性を保つように設計する、というのは
React の真髄とも言える重要な設計思想です。

この設計思想があることの大きな利点は 2 つあります。

### 1. 責務の分離

React が関数コンポーネントに純粋関数性を要求する理由の 1 つ目は、
責務の分離を実現するためです。

React以前の UI フレームワークでは、

- 純粋な UI の記述
- 外部システムとのやり取り

という 2 つの責務が混在しがちでした。

React は この 2 つの責務を明確に分離する設計を要求することで、
開発者に対し、責務の混在しないコードを書くことを強制します。

そのため 無秩序なコードが減り、コードの秩序が保たれるといった理論です。
責務の分離されたコードは、開発者にとってもReactにとっても管理がしやすくなります。

:::message
しかし、責務の分割を強制することは、開発者にとってはある程度の制約にもなります。
この思想はしばしば「React は過度に複雑である」という批判の的にもなります。
:::

### 2. 純粋関数性を前提とした最適化や並列処理

Reactが関数コンポーネントに純粋関数性を要求する理由の 2 つ目は、
React 内部での最適化や並列処理を可能にするためです。

Reactは、関数コンポーネントが純粋関数性を持つことを前提とすることで、
以下のような最適化や並列処理の技術を行うことができます。

- 実行の並列化（React 18 の Concurrent Features による並列レンダリングなど）
- 関数コンポーネント実行の一時停止・再開による ユーザ操作への応答性向上
- パフォーマンスの最適化（React Compiler によるメモ化の自動化など）

これは React 自体の性能向上やユーザ体験の向上に寄与します。

React は、純粋関数性を前提とした最適化や並列処理の技術を、
今後も積極的に開発していく方針を示しています。

React の最適化や並列処理の恩恵を最大限に受けるためにも、
関数コンポーネントが純粋関数性を保つように設計することが重要です。

純粋関数性を保つことは、開発者・React 双方にとって大きな利益をもたらします。

# A/B の詳細

では、先程説明した A/B のそれぞれの性質について、より詳しく見ていきましょう。

## A. 同じ入力に対して同じ出力を返す関数

同じ入力値 state, props, context の組み合わせに対して、
常に同じ React 要素を返すような関数です。

擬似的な式で表現すると、以下のようになります。

```
f(state, props, context) = React 要素
```

props, state もまとめて状態として考えることもできるため、
簡単に `f(state) = UI` と表現されることもあります。

React 公式はこの性質を **「idempotent（冪等）」** と表現しています。
厳密な数学的定義とは異なりますが、同じ入力に対して同じ出力を返す性質を指します。

### A の性質を満たすために避けるべき処理

この関数が A の性質を満たすためには、
外部システムからの値の読み取りを避ける必要があります。

```tsx
// ❌ 悪い例: 外部の値を読み取っている
function BadComponent() {
  const title = document.title; // ブラウザ API からの読み取り
  const random = Math.random(); // ランダム値の生成
  const now = new Date(); // 現在時刻の読み取り

  return (
    <div>
      {title} - {random} - {now.toString()}
    </div>
  );
}

// ✅ 良い例: 入力のみに基づいて出力を返す
function GoodComponent({
  title,
  timestamp,
}: {
  title: string;
  timestamp: number;
}) {
  return (
    <div>
      {title} - {new Date(timestamp).toString()}
    </div>
  );
}
```

以下のような処理が避けるべき処理の例になります。
これらの処理は、外部システムからの値の読み取りに該当する処理といえます。

- ブラウザの API の呼び出しによる値の読み取り（例: `document.title` 読み取り）
- fetch による外部サーバからのデータ取得
- localStorage からのデータ取得
- ランダム値の生成と読み取り
- 現在時刻の読み取り

## B. 関数の実行で外部の値を変更しない関数

関数の実行によって、外部システムに影響を与える処理を行わない関数です。

### B の性質を満たすために避けるべき処理

この関数が B の性質を満たすためには、
外部システムへの値の書き込みを避ける必要があります。

```tsx
// ❌ 悪い例: 外部に影響を与えている
function BadComponent({ title }: { title: string }) {
  document.title = title; // ブラウザ API への書き込み
  localStorage.setItem("visited", "true"); // localStorage への保存

  return <div>{title}</div>;
}

// ✅ 良い例: React 要素の生成のみを行う
function GoodComponent({ title }: { title: string }) {
  return <div>{title}</div>;
}
```

以下のような処理が避けるべき処理の例になります。
これらの処理は、外部システムへの値の書き込みに該当する処理といえます。

- ブラウザの API の呼び出しによる値の変更（例: `document.title` の値変更）
- fetch による外部サーバへのデータ送信
- localStorage へのデータ保存
- 実 DOM ノードの直接操作
  - DOM ノードの直接操作とは React の管轄外の操作であると言えるため
    React 管轄外の外部システムに対する値の変更に該当する
- 非 React の命令的ライブラリの初期化・破棄
- その他、React 要素の生成に関係のない行為
  - `setTimeout` や `setInterval` のタイマー登録など

# 副作用とは

A/B で禁止された処理は、おおむね「外部システム」とのやり取りに該当します。
この外部システムとのやり取りに該当する処理を、React では **「副作用」** と呼びます。

React は、関数コンポーネントがこの副作用を持たず、
純粋関数性を保つことを強く推奨しています。

開発者は、関数コンポーネントの実装において、副作用を避けるように努める必要があります。

:::message
Reactは、開発者に際して一切の副作用を禁止しているわけではないことに注意してください。

React が禁止するのは、
**「要素を生成する関数」である関数コンポーネントが** 副作用を持つことです。

そしてReact は、
副作用処理を記述するための専用の仕組みを、
要素生成処理とは別の場所に用意しています。

実装したいものに副作用がある場合、
この専用の仕組みを利用して副作用を記述することが推奨されます。

これについては次回以降の解説で詳しく説明していきます。

:::

なお わかりやすさのため、
これ以降 state, props, context をまとめて**状態群**と呼ぶことにします。

# 入力値である状態群の値が変化した時に <br />React が React 要素を生成しなおす仕組み

関数コンポーネントは、
入力値である state, props, context の組み合わせ（状態群）から
純粋に React 要素を生成する関数といえます。

先程、React は 関数コンポーネントを呼び出すことで React 要素を生成すると説明しました。
この呼び出しは、状態群のいずれかの値が変化したときに行われます。

入力値である状態群のいずれかの値が変化した時に、React は関数コンポーネントを呼び出し、
React 要素を生成するという流れになります。

```tsx
function Counter({ initialCount }: { initialCount: number }) {
  const [count, setCount] = useState(initialCount);

  // count（state）が変化すると、React がこの関数を再実行する
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

:::message
props の場合は props の値の変化を検知するというより、
親コンポーネントが再レンダーされるタイミングで props は「変化した」とみなされ、
関数コンポーネントが再実行されるといった動作をします。
:::

これにより、状態変化に応じた React 要素の更新を実現することができます。

関数コンポーネントを関数としてみなして考えると、
入力が変化した際、それに反応して出力（React 要素）を再生成するという
設計になっているといえます。

# 入力値はスナップショット

## 状態群のイミュータブル性

状態群（state, props, context）は、関数コンポーネント実行時に導出され、固定されます。
そのため、関数コンポーネントの実行の途中に これらの値を即時に変化させることはできません。

関数コンポーネント実行時における状態群は、
関数コンポーネントの実行開始時に値が固定され、終了まで変化しない
**イミュータブル（不変）なデータ**として扱われます。

## スナップショットという考え方

では、この状態群がイミュータブルなデータであることを、
React はどのように捉えているのでしょうか。

React は、状態群に対して**スナップショット**という考え方を導入しています。

**スナップショット**とは、「ある時点の状態を切り取った」
イミュータブル（不変）なデータのことです。

React においては、状態群がスナップショットとして扱われ、
一つのレンダーフェーズ（関数コンポーネントの実行）において、
関数コンポーネント実行開始時の状態群の値が固定され、
終了まで変化せず一貫して同じ値が保たれることが保証されます。

```tsx
function Example() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    // この時点での count は 0（スナップショット）
    setCount(count + 1);
    setCount(count + 1);
    setCount(count + 1);
    // 3 回 setCount を呼んでも、count は 0 のまま
    // 結果として count は 1 になる（0 + 1 が 3 回）
  };

  return <button onClick={handleClick}>Count: {count}</button>;
}
```

状態群がスナップショットとして固定されることで、
1 つの関数コンポーネント実行中において、
一貫して同じ状態が保たれることが保証されます。

一貫性が保たれることにより、レンダリングの予期せぬ動作やバグを防止することができます。

:::message
**スナップショットとバッチ処理の関連性**

React は、状態群をスナップショットとして扱うという要件を満たすため 状態更新のバッチ処理を行います。
状態更新のバッチ処理とは、複数の状態更新をまとめて処理することです。
詳細については 次回以降の解説で説明していきます。
:::

## JavaScript の仕組みから<br />イミュータブルになっているわけではない

state, props, context 自体は JavaScript のオブジェクトであり、
JavaScript の仕組み上はミュータブル（可変）です。
そのため、開発者がこれらの値を関数コンポーネント実行中に変更することは、技術的には可能です。

しかし React の設計思想として、
関数コンポーネント実行時における状態群はスナップショットとして
イミュータブルに扱うことを前提としています。

そのため、これらの値を関数コンポーネント実行中に変更することは React の設計思想に反します。
開発者は、状態群の値をしっかりイミュータブルに保ち、
関数コンポーネント実行中に変更しないよう注意して実装する必要があります。

```tsx
// ❌ 悪い例：props を直接変更している
function BadComponent({ user }: { user: { name: string } }) {
  user.name = "Modified"; // React の思想に反する
  return <div>{user.name}</div>;
}

// ✅ 良い例：新しいオブジェクトを作成する
function GoodComponent({ user }: { user: { name: string } }) {
  const modifiedUser = { ...user, name: "Modified" };
  return <div>{modifiedUser.name}</div>;
}
```

## 要点まとめ

- React は関数コンポーネントに **純粋関数性（A/B）** を強く求める
- 純粋関数性の狙いは **責務分離** と **React 内部最適化（並列化・再開可能性など）**
- 関数コンポーネント内での外部読み書きは副作用であり、**要素生成処理に混ぜない**
- state / props / context はレンダー中、**スナップショットとして一貫した値**として扱う

# おわりに

今回は、React のコア思想である純粋関数性について解説しました。

React は、関数コンポーネントが純粋関数性を持つことを強く推奨しています。
これにより、責務の分離が実現され、React 内部での最適化や並列処理が可能になります。

また、状態群はスナップショットとしてイミュータブルに扱われ、レンダリングの一貫性が保証されます。

さて、現実のアプリケーションでは外部システムとのやり取り（副作用）が必要です。

次回は、React が提供する副作用の記述手段である **useEffect** について解説していきます。
React の思想に沿った形で副作用を記述する方法を学んでいきましょう。
