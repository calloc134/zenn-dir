---
title: "React の思想を考える - 第 2 回 React のコア思想である 純粋関数性"
emoji: "⚛️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react", "frontend", "javascript", "typescript"]
published: false
---

# はじめに

こんにちは。かろっく@calloc134 です。

前回は、宣言的 UI と UI フレームワークの基本的な考え方について解説しました。今回からは、React 特有の思想について深掘りしていきます。

React の設計思想の中核にあるのは**純粋関数性**です。React がなぜ関数コンポーネントを推奨し、なぜ純粋性を重視するのか、その理由と恩恵を解説していきます。

# 要素を生成する仕組みに「純粋関数性」を強く推奨する関数型の思想

宣言的 UI に渡す要素を生成する関数を**コンポーネント**と呼びます。以後、React の要素は明示的に**「React 要素」**と呼びます。

React では、このコンポーネントをクラスではなく**関数**として定義することを推奨しています。関数として定義されたコンポーネントを**関数コンポーネント**と呼びます。

そして、関数コンポーネントの実装において、関数型プログラミングの概念やパターンを多く取り入れています。

## 純粋関数とは

具体的には、React は関数コンポーネントに対して、以下の特性を持つように設計することを要求しています。

**A. 同じ入力に対して同じ出力を返す関数**

つまり、入力値以外の外部の値から読み取りを行わない関数です。

**B. 関数の実行で外部の値を変更しない関数**

つまり、戻り値以外の外部の値に書き込みを行わない関数です。

この A/B の両方を満たす関数を**純粋関数**とし、React は関数コンポーネントが純粋関数であることを強く推奨しています。

```tsx
// 純粋な関数コンポーネントの例
function Greeting({ name }: { name: string }) {
  // 入力（props）のみに基づいて出力を返す
  return <h1>Hello, {name}!</h1>;
}
```

## 純粋関数性を保つことの意義

UI を記述する React 要素を生成する関数コンポーネントが `f(...) = React 要素` という純粋関数性を保つように設計する、というのは React の真髄とも言える重要な設計思想です。

この設計思想があることの大きな利点は 2 つあります。

### 1. 責務の分離

従来の UI フレームワークでは、以下の 2 つの責務が混在しがちでした。

- 純粋な UI の記述
- 外部システムとのやり取り

React では、この 2 つの責務を明確に分離する設計を要求することで、開発者が強制的にこれらの責務の混在しないコードを書くことを促します。そのため、コード品質が一定に保たれ、無秩序なコードが減ります（理論上は）。

これは開発者から見て大きな利点となります。

:::message
しかし、この思想はしばしば「React は過度に複雑である」という批判の的にもなります。むずかしいところです。
:::

### 2. 純粋関数性を前提とした最適化や並列処理

React 内部では、関数コンポーネントが純粋関数性を持つことを前提に、以下のような処理を行うことができます。

- 実行の並列化（React 18 の Concurrent Features による並列レンダリングなど）
- 関数コンポーネントの実行一時停止・再開によるユーザ操作への応答性向上
- パフォーマンスの最適化（React Compiler によるメモ化の自動化など）
- 関数コンポーネントの実行停止（サスペンド）によるロード画面表示

これは React 自体の性能向上やユーザ体験の向上に寄与します。

React は今後も純粋関数性を前提とした最適化や並列処理の技術を積極的に導入していく予定です。そのため、React の最適化や並列処理の恩恵を最大限に受けるためにも、関数コンポーネントは純粋関数性を持つように設計することが重要です。

純粋関数性を保つことは、開発者・React 双方にとって大きな利益をもたらします。

# A/B の詳細

A/B それぞれの詳細を見ていきましょう。

## A. 同じ入力に対して同じ出力を返す関数

これは、同じ入力値 state, props, context の組み合わせに対しては、常に同じ React 要素を返すような関数です。

擬似的な式で表現すると、以下のようになります。

```
f(state, props, context) = React 要素
```

props, state もまとめて状態として考えることもできるため、簡単に `f(state) = UI` と表現されることもあります。

また、React 公式はこの性質を**「idempotent（冪等）」**と表現しています。厳密な数学的定義とは異なりますが、同じ入力に対して同じ出力を返す性質を指します。そのため、以後は**冪等な関数**という表現も用います。

### A の性質を満たすために避けるべき処理

この関数が A の性質を満たすためには、外部システムからの値の読み取りを避ける必要があります。

```tsx
// ❌ 悪い例：外部の値を読み取っている
function BadComponent() {
  const title = document.title; // ブラウザ API からの読み取り
  const random = Math.random(); // ランダム値の生成
  const now = new Date(); // 現在時刻の読み取り

  return (
    <div>
      {title} - {random} - {now.toString()}
    </div>
  );
}

// ✅ 良い例：入力のみに基づいて出力を返す
function GoodComponent({
  title,
  timestamp,
}: {
  title: string;
  timestamp: number;
}) {
  return (
    <div>
      {title} - {new Date(timestamp).toString()}
    </div>
  );
}
```

避けるべき処理の例は以下のとおりです。

- ブラウザの API の呼び出しによる値の読み取り（例: `document.title` 読み取り）
- fetch による外部サーバからのデータ取得
- localStorage からのデータ取得
- ランダム値の生成と読み取り
- 現在時刻の読み取り

## B. 関数の実行で外部の値を変更しない関数

これは、関数の実行によって、外部システムに影響を与える処理を行わない関数です。

### B の性質を満たすために避けるべき処理

この関数が B の性質を満たすためには、外部システムへの値の書き込みを避ける必要があります。

```tsx
// ❌ 悪い例：外部に影響を与えている
function BadComponent({ title }: { title: string }) {
  document.title = title; // ブラウザ API への書き込み
  localStorage.setItem("visited", "true"); // localStorage への保存

  return <div>{title}</div>;
}

// ✅ 良い例：React 要素の生成のみを行う
function GoodComponent({ title }: { title: string }) {
  return <div>{title}</div>;
}
```

避けるべき処理の例は以下のとおりです。

- ブラウザの API の呼び出しによる値の変更（例: `document.title` の値変更）
- fetch による外部サーバへのデータ送信
- localStorage へのデータ保存
- 実 DOM ノードの直接操作
  - DOM ノードの直接操作とは、React の管轄外の操作であると言えるため、React 管轄外の外部システムに対する値の変更に該当します
- 非 React の命令的ライブラリの初期化・破棄
- その他、React 要素の生成に関係のない行為（`setTimeout` や `setInterval` のタイマー登録など）

# 副作用とは

A/B で禁止された処理は、おおむね「外部システム」とのやり取りに該当します。この外部システムとのやり取りに該当する処理を、React では**「副作用」**と呼びます。

React は、関数がこの副作用を持たないことを強く推奨しています。

:::message
なお、「要素を生成する関数」である関数コンポーネントが副作用を持たない設計にすることを要求しているだけであり、React で記述するアプリケーション全体に対して一切の副作用を禁止しているわけではありません。

むしろ React は、副作用処理を記述する手段を提供しています。副作用を実行するための手段は別途提供されています（後述）。
:::

なお、これ以降 state, props, context をまとめて**状態群**と呼ぶことにします。

# 入力値である状態群の値が変化した時に React が React 要素を生成しなおす仕組み

関数コンポーネントは、入力値である state, props, context の組み合わせ（状態群）から純粋に React 要素を生成する関数です。

React では、React 要素の生成関数も React が呼び出します。開発者は、関数コンポーネントを定義し React に登録するだけで良いのです。

入力値である状態群のいずれかの値が変化した時に、React は関数コンポーネントを呼び出し、React 要素を生成します。

```tsx
function Counter({ initialCount }: { initialCount: number }) {
  const [count, setCount] = useState(initialCount);

  // count（state）が変化すると、React がこの関数を再実行する
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

:::message
props の場合は props の値の変化を検知するというより、親コンポーネントが再レンダーされるタイミングで props は「変化した」とみなされ、関数コンポーネントが再実行されます。
:::

これにより、UI の状態変化に応じた React 要素の更新が実現されます。入力が変化した際にそれに反応して出力（React 要素）を再生成するという設計です。

# 入力値はスナップショット（イミュータブル）なデータとして扱うという設計思想

## 関数コンポーネントの実行処理における状態群のイミュータブル性

状態群（state, props, context）は、関数コンポーネント実行時に導出され、固定されます。そのため、関数コンポーネントの実行の途中に、これらの値を即時に変化させることはできません。

つまり、関数コンポーネント実行時における状態群は、関数コンポーネントの実行開始時に値が固定され、終了まで変化しない、**イミュータブル（不変）なデータ**として扱われます。

## スナップショットという考え方

**スナップショット**とは、「ある時点の状態を切り取った」イミュータブル（不変）なデータのことです。

React は状態群に対してスナップショットという考え方を導入しています。React においては、状態群がスナップショットとして扱われ、一つのレンダーフェーズ（関数コンポーネントの実行）において、状態群の値が変化せず一貫して同じ状態が保たれることを保証しています。

```tsx
function Example() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    // この時点での count は 0（スナップショット）
    setCount(count + 1);
    setCount(count + 1);
    setCount(count + 1);
    // 3 回 setCount を呼んでも、count は 0 のまま
    // 結果として count は 1 になる（0 + 1 が 3 回）
  };

  return <button onClick={handleClick}>Count: {count}</button>;
}
```

状態群がスナップショットとして固定されることで、1 つの関数コンポーネント実行中において、一貫して同じ状態が保たれることが保証され、レンダリングの予期しないバグを防止できます。

:::message
**スナップショットとバッチ処理の関連性**

React は、状態群をスナップショットとして扱うことで、必然的にバッチ処理が要件として必要になってきます。詳細は後述します。
:::

## JavaScript の仕組みからイミュータブルになっているわけではない

state, props, context 自体は JavaScript のオブジェクトであり、JavaScript の仕組み上はミュータブル（可変）です。そのため、技術的には状態群の値を変更することは可能です。

しかし、React の設計思想として、関数コンポーネント実行時における状態群はスナップショットとして扱われ、イミュータブルなデータとして扱われると想定されています。

そのため、これらの値を関数コンポーネント実行中に変更することは React の設計思想に反します。開発者は、これらの状態群の値を変更するのを避け、イミュータブルなデータとして扱うように努める必要があります。

```tsx
// ❌ 悪い例：props を直接変更している
function BadComponent({ user }: { user: { name: string } }) {
  user.name = "Modified"; // React の思想に反する
  return <div>{user.name}</div>;
}

// ✅ 良い例：新しいオブジェクトを作成する
function GoodComponent({ user }: { user: { name: string } }) {
  const modifiedUser = { ...user, name: "Modified" };
  return <div>{modifiedUser.name}</div>;
}
```

# おわりに

今回は、React のコア思想である純粋関数性について解説しました。

React は、関数コンポーネントが純粋関数性を持つことを強く推奨しています。これにより、責務の分離が実現され、React 内部での最適化や並列処理が可能になります。

また、状態群はスナップショットとしてイミュータブルに扱われ、レンダリングの一貫性が保証されます。

しかし、現実のアプリケーションでは外部システムとのやり取り（副作用）が必要です。次回は、React が提供する副作用の記述手段である **useEffect** について解説していきます。React の思想に沿った形で副作用を記述する方法を学んでいきましょう。
