---
title: "SPA + API セッション管理 安全性ランキング作ってみた"
emoji: "🙆"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

# はじめに

こんにちは、calloc134 です。

皆さん、SPA で アプリケーションを作るとき、API との セッション管理にはどのような手法を利用していますか？

クッキー？それとも localStorage に JWT などを保存して利用？

今回は、SPA + API のセッション管理について、基礎を押さえた上で、安全性の ランキングを作成してみました。

# 今回の前提条件

- フロントエンド: SPA (Single Page Application)
  - ブラウザ上で動作する JavaScript アプリケーション
- バックエンド: API サーバ
  - REST API や GraphQL API など
- SPA と API サーバは 異なるオリジンに存在することを想定
  - 例: SPA が `https://spa.invalid`、API サーバが `https://api.invalid` に存在
- API サーバは JSON を受け取り JSON を返すことを前提
  - そのため、HTML フォームを送信するような 古き良き セッション管理手法は利用しない
- 認証は 既に完了しており
  - セッション管理のための トークン文字列 (セッショントークン) が 発行されていることを前提

# セッション管理における 2 つのレイヤ

- 巷では、クッキーか JWT か、などの議論が行われる
- しかし、その議論は 対立軸を誤っている
- セッション管理には 2 つのレイヤが存在する
  - トークン文字列がどのような形式か
  - トークン文字列をどこに保存し どのように取り出して送信するか
- この 2 つのレイヤを分けて考えることが重要
- 1. トークン形式
  - A. handle 型トークン
    - API 側のデータベースに セッション情報を保存し
    - トークン文字列は そのセッション情報を一意に指し示す ID のみ
    - API 側は トークン文字列を受け取ると
    - データベースを参照し セッション情報を取得する
      - 例: セッション ID、ランダム文字列トークン
    - ただ一意に指し示すだけでいいので 、トークン文字列自体は 短く ランダムなもので良い
    - 利点
      - API 側 で セッション情報を管理できるため、セッションの失効が可能
      - API 側 で セッション情報を管理できるため、セッション情報が古くならない
    - 欠点
      - API 側 で セッション情報を管理するため、情報を保存するインフラコストが発生する
      - API 側 で セッション情報を管理するため、スケーラビリティが低下する可能性がある
      - API 側 で セッション情報を管理するため、DB アクセスが発生し レイテンシが増加する
  - B. assertion 型トークン
    - トークン文字列自体に セッション情報を含む
    - API 側は トークン文字列を受け取ると
    - トークン文字列を解析し セッション情報を取得する
      - 例: JWT
    - トークン文字列自体に セッション情報を含むため、トークン文字列は 長く 複雑になる
    - ほとんどの場合、暗号化や署名が施される
    - 利点
      - API 側 で セッション情報を管理しないため、インフラコストが発生しない
      - API 側 で セッション情報を管理しないため、スケーラビリティが向上する
      - API 側 で セッション情報を管理しないため、DB アクセスが発生せず レイテンシが低減する
    - 欠点
      - API 側 で セッション情報を管理しないため、セッションの失効が困難
      - API 側 で セッション情報を管理しないため、セッション情報が古くなる可能性がある
- 2. トークン保存場所・送信方法

  - α. httpOnly クッキー に保存し ブラウザが自動送信
    - ブラウザの提供するクッキー機能を利用
    - httpOnly 属性を付与することで JavaScript からのアクセスを防止
    - API へのリクエスト時に ブラウザが自動的にクッキーを送信
    - 古き良き セッション管理手法 といえる
    - 利点
      - 攻撃者によって ブラウザに 悪意のある JavaScript コードが送り込まれた場合でも
        - JavaScript から クッキーにアクセスできないため
        - セッション情報そのものが盗まれるリスクを低減できる
          - 捕捉: ただし 悪意ある JavaScript から
          - クッキーを付けて API にアクセスすることは可能なことに注意
          - あくまでも 永続的に セッション情報が盗まれるリスクを低減できる、という意味であり
          - 悪意ある JavaScript が ブラウザで動作している間は セッションが乗っ取られるリスクがあることに注意
          - httponly が付いていても 被害が拡大する例:
            - パスワード変更 API を呼び出し パスワードを変更される
          - このような アカウントアクセス拡大に繋がる API 呼び出しは、
          - 事前に パスワード再認証を要求するなどの 対策が必要
        -
    - 欠点
      - しっかり CSRF 対策を行う必要がある
        - 今回は API が JSON を受け取り JSON を返すことを前提としているため
        - ある程度 CSRF は難しいものと考察される
        - ただし CORS 設定や CSRF 対策 ヘッダ などを用いて CSRF 対策をぬかりなく行う必要がある
        - CSRF は 設定を誤らなければ 防げる攻撃であるため
        - 十分に注意して対策を行うこと
  - β. ブラウザの提供するストレージやメモリに保存し JavaScript でその都度 取り出して 送信
    - JavaScript を用いて ストレージやメモリに トークン文字列を保存し
    - API へのリクエスト時に JavaScript で トークン文字列を取り出し
    - API リクエストヘッダなどに トークン文字列を付与して 送信
    - 近年の SPA で よく利用される手法
    - トークンは以下のような場所に保存
      - ストレージ
        - localStorage
        - sessionStorage
        - IndexedDB
      - メモリ
        - React の state
        - JavaScript の変数
    - 利点
      - CSRF 対策が不要
        - JavaScript で API リクエストヘッダなどに トークン文字列を付与して 送信するため
        - 悪意ある第三者ドメインからの リクエストでは トークン文字列を付与できない
        - そのため CSRF 攻撃を防げる
    - 欠点
      - 攻撃者によって ブラウザに 悪意のある JavaScript コードが送り込まれた場合
        - その JavaScript から ストレージやメモリに保存された トークン文字列にアクセスできるため
        - 永続的に セッション情報が盗まれるリスクがある
        - この手法では トークン文字列の保存・取り出しを JavaScript が担うため
        - 悪意ある JavaScript の実行による トークン奪取問題を 根本的に防ぐことはできない
        - そのため、対処療法ではあるが
        - 悪意ある JavaScript の実行を防ぐ対策が重要
  - 非推奨: httponly でないクッキー
    - クッキーの利点が活かせない上に
    - JavaScript からアクセス可能であるため β の手法と同様の欠点を持つ
    - そのため、今回はこれを最初から非推奨とする

- 一般的には 上記の通り
- なお、2 つのトークンを組み合わせて利用することで、お互いの欠点を補うことも可能
  - C. 短命 assertion 型トークン + 長命 handle 型トークン
    - assertion 型トークンを 短命に設定し
    - 長命の handle 型トークンで assertion 型トークンを再発行する
    - 同時に 新しい 長命 handle 型トークンを発行し、古いものを無効化する
    - このように設計することで、assertion 型と handle 型の利点を組み合わせることが可能
      - assertion 型 トークンの欠点:
        - セッションの失効が困難
          - assertion 型トークンを 短命に設定することで
          - 短命 assertion 型 トークンが 盗まれた場合でも 短期間で無効化され 悪用が困難
          - また 長命 handle 型トークンは 失効可能であるため
          - 長命 handle 型トークンが 盗まれた場合でも
          - API 側で 失効させることで セッションを無効化可能
      - handle 型 トークンの欠点:
        - インフラコストが発生・スケーラビリティが低下・レイテンシが増加
          - セッションとしては 頻繁にアクセスする 短命 assertion 型トークンを利用することで
          - 普段のアクセスにおける DB アクセスを低減し インフラコストを抑制・スケーラビリティを向上・レイテンシを低減
          - 長命 handle 型トークンは 短命 assertion 型トークンの再発行時にのみ利用されるため
          - 頻繁にアクセスされることがなく インフラコストを抑制可能

## セッション管理の安全性ランキング

- 上記の 2 つのレイヤを組み合わせた場合の 安全性 Tier 表
- なお、簡単に比較できないものも存在する
  - ハッセ図 という概念を利用し、安全性の高低を表現
  - 高低差を 単純に比較できないものは、枝分かれで表現する
- 1 位: A on α
  - handle 型トークン on httpOnly クッキー
  - API 側で セッション情報を管理し 失効可能
  - JavaScript からのアクセスを防止可能
  - 昔ながらの 安全なセッション管理手法
    - 昔は サーバが一台のことも多く
    - バックエンドサーバ による スケーラビリティの問題が今より少なかったため
    - この手法で何ら問題はなく、一般的な構成であった
  - メリット:
    - セッションの失効が可能
      - 永続的なトークン奪取リスクを低減
  - デメリット:
    - インフラコストが発生
    - スケーラビリティが低下
    - レイテンシが増加
    - CSRF 対策が必要(適切に対策すれば問題なし)
- 2 位: C on α
  - 短命 assertion 型トークン + 長命 handle 型トークン on httponly クッキー
  - API 側で セッション情報を管理し 長命側は失効可能
  - 比較的安全なセッション管理手法
  - メリット:
    - 長命側トークンであれば失効が可能
      - 永続的なトークン奪取リスクを低減
    - 普段のアクセスにおける DB アクセスを低減し
      - インフラコストを抑制
      - スケーラビリティを向上
      - レイテンシを低減
  - デメリット:
    - 短命側トークンが 盗まれた場合のリスクは残る
      - ただし 短命であるため リスクは できるだけ低減
    - CSRF 対策が必要(適切に対策すれば問題なし)
  - 問題点: この形を実装するフレームワークが ほとんどない
    - かろうじて supertokens が 対応している程度
      - 筆者の意見では この形が 最もバランスの良いセッション管理手法であると考えるが
      - 現状で対応しているフレームワークは ほとんどない
    - 自前で対応しようとすると独自実装となり コストが高い
    - また セキュリティにおける独自実装は、それ自体が セキュリティリスクを招く可能性があるため 注意が必要
- 3 位: B on α
  - assertion 型トークン on httpOnly クッキー
  - JavaScript からのアクセスを防止可能
  - モダンな API フレームワーク でセッション管理のミドルウェアを利用すると この形になることが多い
  - メリット:
    - JavaScript からのアクセスを防止可能
      - 永続的なトークン奪取リスクを低減
  - デメリット:
    - API 側で セッション情報を管理しないため 失効が困難
      - 永続的なトークン奪取リスクが残る
    - CSRF 対策が必要(適切に対策すれば問題なし)
- 同率 3 位: C on β/α
  - 短命 assertion 型トークン on ブラウザストレージやメモリ + 長命 handle 型トークン on httpOnly クッキー
  - API 側で セッション情報を管理し 長命側は失効可能
  - Auth0 などの 外部認可サーバを用いた SPA + API のセッション管理で よく利用される手法
    - この問題点は 後述する
  - メリット:
    - 長命側トークンであれば失効が可能
      - 永続的なトークン奪取リスクを低減
    - 短命側トークンが 盗まれた場合のリスクは残る
      - ただし 短命であるため リスクは できるだけ低減
  - デメリット:
    - 短命側トークンが JavaScript からアクセス可能であるため
      - 永続的なトークン奪取リスクが残る
    - 悪意ある JavaScript の実行を防ぐ対策が重要
    - 長命側トークンは CSRF 対策が必要(適切に対策すれば問題なし)
  - B on α と 同率 3 位
    - この 2 つはどちらも 一長一短であり
    - 単純に比較することができないため 同率 3 位とした
    - 詳細は 後述する
  - 余談: OAuth との関連性と注意点
    - この手法は、API サーバ単体というよりも
      - Auth0 などの 外部認可サーバを用いた SPA + API のセッション管理で よく利用される手法
    - OAuth では access token と refresh token の組み合わせがよく利用される
      - access token は 短命 assertion 型トークン
      - refresh token は 長命 handle 型トークン
      - このアクセストークンをセッショントークンとして流用しているイメージ
    - OAuth のアクセストークン・リフレッシュトークンを セッション管理に流用すると、
      - 自然と C on β/α の形にたどり着く
    - しかし、筆者の意見では OAuth のアクセストークンをセッションに流用するのは推奨しない
      - OAuth のアクセストークンは 本来 リソースサーバーへのアクセス権を示すものであり
      - セッション管理のために設計されていないため
      - セッション管理の要件を満たさないと考える
    - また、検証を怠ると 脆弱性を招くリスクもある
    - 詳しくは 以前の記事を参照
      - 【OAuth】アクセストークンの検証を誤ると成りすまし攻撃ができます
      - https://zenn.dev/calloc134/articles/oauth-cross-api-vuln-attack
- 4 位: B on β
  - assertion 型トークン on ブラウザストレージやメモリ
  - SPA で よく利用される手法だが 安全性は低い
  - メリット:
    - CSRF 対策が不要
  - デメリット:
    - API 側で セッション情報を管理しないため 失効が困難
      - 永続的なトークン奪取リスクが残る
    - トークン文字列が JavaScript からアクセス可能であるため
      - 永続的なトークン奪取リスクが残る
    - 悪意ある JavaScript の実行を防ぐ対策が重要
- 非推奨 1: B on non-httponly cookie
  - assertion 型トークン on httponly でないクッキー
  - JavaScript からアクセス可能であるため β の手法と同様の欠点を持つ
  - 更に CSRF 対策も必要となるため これを採用するメリットはほとんどない
  - α を利用する場合も同様

## 安全性 ランキング考察

- 先程のランキングは、一つずつ順位を下っていくごとに
- 一つセキュリティの欠点が増えるようになっている
  - 1 位 → 2 位:
    - handle 型トークン on httpOnly クッキー から
    - 短命 assertion 型トークン + 長命 handle 型トークン on httpOnly クッキー へ
    - 短命 assertion 型トークンが 盗まれた場合のリスクが増える
  - 2 位 → 3 位(1):
    - 短命 assertion 型トークン + 長命 handle 型トークン on httpOnly クッキー から
    - assertion 型トークン on httpOnly クッキー へ
    - 長命側トークンの失効可能性が失われる
  - 2 位 → 3 位(2):
    - 短命 assertion 型トークン + 長命 handle 型トークン on httpOnly クッキー から
    - 短命 assertion 型トークン on ブラウザストレージやメモリ + 長命 handle 型トークン on httpOnly クッキー へ
    - 短命側トークンが JavaScript からアクセス可能になる
  - 3 位(1): → 4 位:
    - assertion 型トークン on httpOnly クッキー から
    - assertion 型トークン on ブラウザストレージやメモリ へ
    - トークン文字列が JavaScript からアクセス可能になる
  - 3 位(2): → 4 位:
    - 短命 assertion 型トークン on ブラウザストレージやメモリ + 長命 handle 型トークン on httpOnly クッキー から
    - assertion 型トークン on ブラウザストレージやメモリ へ
    - 長命側トークンの失効可能性が失われる
- これを図に表すと 以下のハッセ図のようになる
  - 安全性の高いものほど 上位に位置し
  - 単純に比較できないものは 枝分かれで表現
  - (ここに図を記述)

# おわりに

今回は、SPA + API のセッション管理について、安全性の Tier 表を考えてみました。
安全な手法を取るに越したことはありませんが、安全性を高めるほど、利便性やインフラコストとのトレードオフが発生します。
自分のアプリケーションにとって、どの程度の安全性が必要かを見極め、適切なセッション管理手法を選択しましょう。

読んでいただき、ありがとうございました。
