---
title: "SPA + API のセッション管理 安全性ランキング (CSRF 対策のベストプラクティスを添えて)"
emoji: "🙆"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

# はじめに

こんにちは、calloc134 です。

皆さん、SPA で アプリケーションを作るとき、API との セッション管理にはどのような手法を利用していますか？
クッキー？それとも localStorage に JWT などを保存して利用？

今回は、SPA + API のセッション管理について、基礎を押さえた上で、安全性の ランキングを作成してみました。
また、SPA + API における CSRF 脅威 と その対策についても ベストプラクティスを整理しました。

SPA + API のセキュリティについて、包括的に学習を深めていきましょう。

# 今回の前提条件

- フロントエンド: SPA (Single Page Application)
  - ブラウザ上で動作する JavaScript アプリケーション
- バックエンド: API サーバ
  - REST API や GraphQL API など
- SPA と API サーバは 異なるオリジンに存在することを想定
  - 例: SPA が `https://spa.invalid`、API サーバが `https://api.invalid` に存在
- API サーバは JSON を受け取り JSON を返すことを前提
  - そのため、HTML フォームを送信するような 古き良き セッション管理手法は利用しない
- 認証は 既に完了しており
  - セッション管理のための トークン文字列 (セッショントークン) が 発行されていることを前提

# セッション管理における 2 つのレイヤ

- 巷では、クッキーか JWT か、などの議論が行われる
- しかし、その議論は 対立軸を誤っている
- セッション管理には 2 つのレイヤが存在する
  - トークン文字列がどのような形式か
  - トークン文字列をどこに保存し どのように取り出して送信するか
- この 2 つのレイヤを分けて考えることが重要
- 1. トークン形式
  - A. handle 型トークン
    - API 側のデータベースに セッション情報を保存し
    - トークン文字列は そのセッション情報を一意に指し示す ID のみ
    - API 側は トークン文字列を受け取ると
    - データベースを参照し セッション情報を取得する
      - 例: セッション ID、ランダム文字列トークン
    - ただ一意に指し示すだけでいいので 、トークン文字列自体は 短く ランダムなもので良い
    - 利点
      - API 側 で セッション情報を管理できるため、セッションの失効が可能
      - API 側 で セッション情報を管理できるため、セッション情報が古くならない
    - 欠点
      - API 側 で セッション情報を管理するため、情報を保存するインフラコストが発生する
      - API 側 で セッション情報を管理するため、スケーラビリティが低下する可能性がある
      - API 側 で セッション情報を管理するため、DB アクセスが発生し レイテンシが増加する
  - B. assertion 型トークン
    - トークン文字列自体に セッション情報を含む
    - API 側は トークン文字列を受け取ると
    - トークン文字列を解析し セッション情報を取得する
      - 例: JWT
    - トークン文字列自体に セッション情報を含むため、トークン文字列は 長く 複雑になる
    - ほとんどの場合、暗号化や署名が施される
    - 利点
      - API 側 で セッション情報を管理しないため、インフラコストが発生しない
      - API 側 で セッション情報を管理しないため、スケーラビリティが向上する
      - API 側 で セッション情報を管理しないため、DB アクセスが発生せず レイテンシが低減する
    - 欠点
      - API 側 で セッション情報を管理しないため、セッションの失効が困難
      - API 側 で セッション情報を管理しないため、セッション情報が古くなる可能性がある
- 2. トークン保存場所・送信方法

  - α. httpOnly クッキー に保存し ブラウザが自動送信
    - ブラウザの提供するクッキー機能を利用
    - httpOnly 属性を付与することで JavaScript からのアクセスを防止
    - API へのリクエスト時に ブラウザが自動的にクッキーを送信
    - 古き良き セッション管理手法 といえる
    - 利点
      - 攻撃者によって ブラウザに 悪意のある JavaScript コードが送り込まれた場合でも
        - JavaScript から クッキーにアクセスできないため
        - セッション情報そのものが盗まれるリスクを低減できる
          - 捕捉: ただし 悪意ある JavaScript から
          - クッキーを付けて API にアクセスすることは可能なことに注意
          - あくまでも 永続的に セッション情報が盗まれるリスクを低減できる、という意味であり
          - 悪意ある JavaScript が ブラウザで動作している間は セッションが乗っ取られるリスクがあることに注意
          - httponly が付いていても 被害が拡大する例:
            - パスワード変更 API を呼び出し パスワードを変更される
          - このような アカウントアクセス拡大に繋がる API 呼び出しは、
          - 事前に パスワード再認証を要求するなどの 対策が必要
        -
    - 欠点
      - しっかり CSRF 対策を行う必要がある
        - CSRF は 設定を誤らなければ 防げる攻撃であるため
        - 十分に注意して対策を行うこと
        - SPA + API の場合の CSRF 対策については、後述
  - β. ブラウザの提供するストレージやメモリに保存し JavaScript でその都度 取り出して 送信
    - JavaScript を用いて ストレージやメモリに トークン文字列を保存し
    - API へのリクエスト時に JavaScript で トークン文字列を取り出し
    - API リクエストヘッダなどに トークン文字列を付与して 送信
    - 近年の SPA で よく利用される手法
    - トークンは以下のような場所に保存
      - ストレージ
        - localStorage
        - sessionStorage
        - IndexedDB
      - メモリ
        - React の state
        - JavaScript の変数
    - 利点
      - CSRF 対策が不要
        - JavaScript で API リクエストヘッダなどに トークン文字列を付与して 送信するため
        - 悪意ある第三者ドメインからの リクエストでは トークン文字列を付与できない
        - そのため CSRF 攻撃を防げる
    - 欠点
      - 攻撃者によって ブラウザに 悪意のある JavaScript コードが送り込まれた場合
        - その JavaScript から ストレージやメモリに保存された トークン文字列にアクセスできるため
        - 永続的に セッション情報が盗まれるリスクがある
        - この手法では トークン文字列の保存・取り出しを JavaScript が担うため
        - 悪意ある JavaScript の実行による トークン奪取問題を 根本的に防ぐことはできない
        - そのため、対処療法ではあるが
        - 悪意ある JavaScript の実行を防ぐ対策が重要
  - 非推奨: httponly でないクッキー
    - クッキーの利点が活かせない上に
    - JavaScript からアクセス可能であるため β の手法と同様の欠点を持つ
    - そのため、今回はこれを最初から非推奨とする

- 一般的には 上記の通り
- なお、2 つのトークンを組み合わせて利用することで、お互いの欠点を補うことも可能
  - C. 短命 assertion 型トークン + 長命 handle 型トークン
    - assertion 型トークンを 短命に設定し
    - 長命の handle 型トークンで assertion 型トークンを再発行する
    - 同時に 新しい 長命 handle 型トークンを発行し、古いものを無効化する
    - このように設計することで、assertion 型と handle 型の利点を組み合わせることが可能
      - assertion 型 トークンの欠点:
        - セッションの失効が困難
          - assertion 型トークンを 短命に設定することで
          - 短命 assertion 型 トークンが 盗まれた場合でも 短期間で無効化され 悪用が困難
          - また 長命 handle 型トークンは 失効可能であるため
          - 長命 handle 型トークンが 盗まれた場合でも
          - API 側で 失効させることで セッションを無効化可能
      - handle 型 トークンの欠点:
        - インフラコストが発生・スケーラビリティが低下・レイテンシが増加
          - セッションとしては 頻繁にアクセスする 短命 assertion 型トークンを利用することで
          - 普段のアクセスにおける DB アクセスを低減し インフラコストを抑制・スケーラビリティを向上・レイテンシを低減
          - 長命 handle 型トークンは 短命 assertion 型トークンの再発行時にのみ利用されるため
          - 頻繁にアクセスされることがなく インフラコストを抑制可能

## セッション管理の安全性ランキング

- 上記の 2 つのレイヤを組み合わせた場合の 安全性 Tier 表
- なお、簡単に比較できないものも存在する
  - ハッセ図 という概念を利用し、安全性の高低を表現
  - 高低差を 単純に比較できないものは、枝分かれで表現する
- また CSRF 脅威 は 適切に対策すれば 問題ないものとする
  - そのため ランキングにおいて CSRF 脅威は考慮していない
  - ただし CSRF 脅威に対して 適切に対策を行う必要があることは 念のため 付記しておく
- 1 位: A on α
  - handle 型トークン on httpOnly クッキー
  - API 側で セッション情報を管理し 失効可能
  - JavaScript からのアクセスを防止可能
  - 昔ながらの 安全なセッション管理手法
    - 昔は サーバが一台のことも多く
    - バックエンドサーバ による スケーラビリティの問題が今より少なかったため
    - この手法で何ら問題はなく、一般的な構成であった
  - メリット:
    - セッションの失効が可能
      - 永続的なトークン奪取リスクを低減
  - デメリット:
    - インフラコストが発生
    - スケーラビリティが低下
    - レイテンシが増加
    - CSRF 対策が必要(適切に対策すれば問題なし)
- 2 位: C on α
  - 短命 assertion 型トークン + 長命 handle 型トークン on httponly クッキー
  - API 側で セッション情報を管理し 長命側は失効可能
  - 比較的安全なセッション管理手法
  - メリット:
    - 長命側トークンであれば失効が可能
      - 永続的なトークン奪取リスクを低減
    - 普段のアクセスにおける DB アクセスを低減し
      - インフラコストを抑制
      - スケーラビリティを向上
      - レイテンシを低減
  - デメリット:
    - 短命側トークンが 盗まれた場合のリスクは残る
      - ただし 短命であるため リスクは できるだけ低減
    - CSRF 対策が必要(適切に対策すれば問題なし)
  - 問題点: この形を実装するフレームワークが ほとんどない
    - かろうじて supertokens が 対応している程度
      - 筆者の意見では この形が 最もバランスの良いセッション管理手法であると考えるが
      - 現状で対応しているフレームワークは ほとんどない
    - 自前で対応しようとすると独自実装となり コストが高い
    - また セキュリティにおける独自実装は、それ自体が セキュリティリスクを招く可能性があるため 注意が必要
- 3 位: B on α
  - assertion 型トークン on httpOnly クッキー
  - JavaScript からのアクセスを防止可能
  - モダンな API フレームワーク でセッション管理のミドルウェアを利用すると この形になることが多い
  - メリット:
    - JavaScript からのアクセスを防止可能
      - 永続的なトークン奪取リスクを低減
  - デメリット:
    - API 側で セッション情報を管理しないため 失効が困難
      - 永続的なトークン奪取リスクが残る
    - CSRF 対策が必要(適切に対策すれば問題なし)
- 4 位: C on β
  - 短命 assertion 型トークン + 長命 handle 型トークン on ブラウザストレージやメモリ
  - API 側で セッション情報を管理し 長命側は失効可能
  - Auth0 などの 外部認可サーバを用いた SPA + API のセッション管理で よく利用される手法
    - この問題点は 後述する
  - メリット:
    - 長命側トークンであれば失効が可能
      - 永続的なトークン奪取リスクを低減
    - 短命側トークンが 盗まれた場合のリスクは残る
      - ただし 短命であるため リスクは できるだけ低減
    - 双方ともに CSRF 対策が不要
  - デメリット:
    - 短命側トークン 及び 長命側トークンが JavaScript からアクセス可能であるため
      - 永続的なトークン奪取リスクが残る
      - 特に 長命側トークンは 永続的に奪取されるリスクが高い
    - 悪意ある JavaScript の実行を防ぐ対策が重要
  - 余談: OAuth との関連性と注意点
    - この手法は、API サーバ単体というよりも
      - Auth0 などの 外部認可サーバを用いた SPA + API のセッション管理で よく利用される手法
    - OAuth では access token と refresh token の組み合わせがよく利用される
      - access token は 短命 assertion 型トークン
      - refresh token は 長命 handle 型トークン
      - このアクセストークンをセッショントークンとして流用しているイメージ
    - OAuth のアクセストークン・リフレッシュトークンを セッション管理に流用すると、
      - 自然と C on β/α の形にたどり着く
    - しかし、筆者の意見では OAuth のアクセストークンをセッションに流用するのは推奨しない
      - OAuth のアクセストークンは 本来 リソースサーバーへのアクセス権を示すものであり
      - セッション管理のために設計されていないため
      - セッション管理の要件を満たさないと考える
    - また、検証を怠ると 脆弱性を招くリスクもある
    - 詳しくは 以前の記事を参照
      - 【OAuth】アクセストークンの検証を誤ると成りすまし攻撃ができます
      - https://zenn.dev/calloc134/articles/oauth-cross-api-vuln-attack
- 同率 4 位: B on β
  - assertion 型トークン on ブラウザストレージやメモリ
  - SPA で よく利用される手法だが 安全性は低い
  - メリット:
    - CSRF 対策が不要
  - デメリット:
    - API 側で セッション情報を管理しないため 失効が困難
      - 永続的なトークン奪取リスクが残る
    - トークン文字列が JavaScript からアクセス可能であるため
      - 永続的なトークン奪取リスクが残る
    - 悪意ある JavaScript の実行を防ぐ対策が重要
  - C on β との比較
    - B on β の場合、assertion 型トークン しか存在しないため トークンを奪取されると永続的にアクセスされる
    - ただし C on β も 長命 handle 型 トークンが 奪取された場合は 同等のリスク
    - どちらの手法も β であるため、悪意ある JavaScript による トークン奪取による 永続的アクセスのリスクが存在する
    - そのため 同率とした
    - 逆に言えば、B on β において assertion 型トークンを 短命に設定している場合、
      - C on β よりも安全といえる可能性もある
- 非推奨 1: B on non-httponly cookie
  - assertion 型トークン on httponly でないクッキー
  - JavaScript からアクセス可能であるため β の手法と同様の欠点を持つ
  - 更に CSRF 対策も必要となるため これを採用するメリットはほとんどない
  - α を利用する場合も同様

## 安全性 ランキング考察

- 先程のランキングは、一つずつ順位を下っていくごとに
- 一つセキュリティの欠点が増えるようになっている
  - 1 位 → 2 位:
    - handle 型トークン on httpOnly クッキー から
    - 短命 assertion 型トークン + 長命 handle 型トークン on httpOnly クッキー へ
    - 短命 assertion 型トークンが 盗まれた場合のリスクが増える
- これを図に表すと 以下のハッセ図のようになる
  - 安全性の高いものほど 上位に位置し
  - 単純に比較できないものは 枝分かれで表現
  - (ここに図を記述)

# SPA + API における CSRF 周りと 対策 (Hono を例に)

- API の CSRF 対策についても登場したため、ここでベストプラクティスを整理しておく
- 今回の構成の前提
  - SPA と API が 完全別ドメインに存在
  - API サーバは JSON を受け取り JSON を返すことを前提
    - つまり JSON 形式 `application/json` の リクエストボディ しか受け付けない
    - そのため HTML フォーム を送信するような 昔ながらの CSRF 攻撃は想定しない
      - `application/x-www-form-urlencoded`
      - `multipart/form-data`
      - `text/plain`
    - これらのコンテンツタイプは そもそも API サーバで拒否することを前提とする (後述)
- この場合の CSRF 脅威 と 対策について
  - 攻撃者サーバ が 提供する JavaScript を 被害者のブラウザ上で 実行させる
    - 例:
      - 1. 被害者が 攻撃者サーバ にアクセス
      - 2. 攻撃者サーバ が 提供する JavaScript が 被害者のブラウザ上で 実行される
      - 3. 悪意ある JavaScript が fetch API などを用いて API サーバ に リクエストを送信 (credentials: "include" を指定)
      - 4. ブラウザが 自動的に クッキーを送信
      - 5. API サーバが リクエストを処理し 副作用のある操作を実行
- これに対してどのように防御するか
- 以下の防御策を適用すれば ほとんどの CSRF 攻撃を防げる

  - まず 副作用のある API と 副作用のない API を切り分ける
    - 副作用 = データベースの状態を変更する可能性があること
  - メソッドの切り分け
    - 副作用のある API: POST, PUT, PATCH, DELETE などの unsafe method に限定する
    - 副作用のない API: GET, HEAD, OPTIONS などの safe method に限定する
      - この切り分けは 開発者が 意識して行う必要がある
    - CSRF 防御の目的
      - 副作用のある API に対しては 「実行させない」を目的とした 防御策を適用
      - 副作用のない API に対しては 「実行の結果を見られない」を目的とした 防御策を適用
  - API 全体に対して

    - 適切な CORS (Cross-Origin Resource Sharing) 設定による SOP (Same-Origin Policy) の厳格な適用

      - `hono/cors` ミドルウェアを利用
      - ポリシーにより 被害者のブラウザにおける fetch API の動作に制限をかける
      - SOP とは
        - 以後、簡単のために オリジン = ドメイン だと思ってもらえば良い
          - 厳密には違うが ここでは深堀りしない
        - 開いているサイトの JavaScript で fetch API などを用いて
        - 別オリジンの API にアクセスする行為には 制限がかかっている
        - この制限を SOP (同一生成元ポリシー) と呼ぶ
      - CORS とは

        - SOP の制限を緩和するためのルールが CORS
          - Web 技術の発展により、別ドメイン間での API アクセスの需要が高まったため
          - CORS を用いて SOP の制限を緩和することができるようになった
        - allowlist のようなイメージで アクセスを許可する出どころのオリジンを指定できる

      - SOP の制限 および CORS が CSRF 対策 そのものという訳ではないが

        - CORS の適切な 設定 による SOP の厳格な制限適用 + 副作用の有無による API のメソッド分離 を合わせることで
        - CSRF 攻撃の脅威を大幅に低減できる

      - CORS ポリシーの設定内容
        - CORS 設定で SPA (正規のサイト) のオリジンのみを許可
        - これにより
          - SPA (正規のサイト) から 行われる API へのアクセスは 許可される
          - 攻撃者サーバ (悪意あるサイト) から 行われる API へのアクセスは ブラウザが制限する
        - という動作を実現
      - CORS 設定を適用した際の動作
        - CORS 設定を適用した際の動作も学習しておくと良い
        - 副作用のある API (unsafe method)の場合:
          - unsafe method = POST, PUT, PATCH, DELETE など
            - unsafe method の場合でも かならず 以下の流れになる訳ではない
            - 詳細は後述
          - fetch API などで unsafe method を送信しようとすると
          - まずブラウザが プリフライトリクエスト (OPTIONS メソッド) を送信
          - API サーバが プリフライトリクエストに対して
            - ヘッダに CORS ポリシー情報を含んだ レスポンスを返す
          - ブラウザが レスポンスを確認し ポリシーで許可されていない場合は
          - JavaScript(fetch API など) が エラーとなり 本リクエストを送信しない
          - API サーバが レスポンスを返す
          - これにより「実行させない」ことを実現
        - 副作用のない API (safe method)の場合:
          - safe method = GET, HEAD, OPTIONS など
          - ブラウザが 直接 本リクエスト (safe method) を送信
          - API サーバが レスポンスを返す
            - このとき ヘッダに CORS ポリシー情報を含む
          - ブラウザが レスポンスを確認し ポリシーで許可されていない場合は
          - JavaScript(fetch API など) が エラーとなり レスポンス内容を取得できない
          - これにより「実行の結果を見られない」ことを実現
        - 余談: unsafe method におけるプリフライトリクエストについて
          - unsafe method であっても 特定の条件下では プリフライトリクエストが送信されない場合がある
            - 例えば コンテンツタイプが フォーム送信
              - `application/x-www-form-urlencoded`
              - `multipart/form-data`
              - `text/plain`
            - の場合など
            - これらのケースは今回の攻撃想定 とはズレるため ここでは解説しない
            - 今回の解説では これらのケースをブロックすることを前提とする (後述)

    - unsafe method において `Origin` ヘッダ・`Referer` ヘッダ の検証 (allowlist 利用)
      - 自前でミドルウェアを実装する必要あり
      - CORS 設定に加えて 二重の防御策として有効
      - CORS ポリシーは ブラウザが自主的に fetch API などの動作を制限する仕組みである
        - それに対し、API サーバ側でも 検証を行うことで
        - より確実に CSRF 攻撃を防げる
      - fetch API などを用いて リクエストを送信する場合
        - ブラウザが 自動的に `Origin` ヘッダ を付与する
        - `Origin` ヘッダとは
          - リクエストが どのオリジン (ドメイン) から送信されたかを示すヘッダ
      - SPA (正規のサイト) のオリジンのみを allowlist に登録し
        - リクエストが 来た際に `Origin` ヘッダ の値を検証
        - allowlist に登録されていないオリジンからの リクエストは拒否
        - これにより
          - SPA (正規のサイト) から 行われる API へのアクセスは 許可される
          - 攻撃者サーバ (悪意あるサイト) から 行われる API へのアクセスは 拒否される
        - という動作を実現
      - 余談: 古いブラウザでは `Origin` ヘッダ が付与されない場合があるため
        - その場合は `Referer` ヘッダ も検証すると良い
        - `Referer` ヘッダ とは
          - リクエストが どの URL から送信されたかを示すヘッダ
        - `Referer` ヘッダ も SPA (正規のサイト) のオリジンのみを allowlist に登録し
        - リクエストが 来た際に `Referer` ヘッダ の値を検証
        - 古いブラウザに対応する場合の処理の流れ
          - 1. まず `Origin` ヘッダ を検証
          - 2. `Origin` ヘッダ が存在しない場合は `Referer` ヘッダ を検証
          - 3. どちらも allowlist に登録されていないオリジンからの リクエストは拒否
    - 追加: コンテンツタイプが `application/json` となっているかのチェック
      - 以下のコンテンツタイプをすべて 拒否することができる
        - `application/x-www-form-urlencoded`
        - `multipart/form-data`
        - `text/plain`
        - コンテンツタイプの欠落
      - 昔ながらの CSRF 攻撃を防ぐ対策として有効
        - 今回の 攻撃想定 と異なる CSRF 攻撃について すべて防ぐことができる
        - ただし 自前でミドルウェアを実装する必要あり
    - 余談: SameSite 属性は 利用できない
      - 今回は SPA と API が 完全別ドメインに存在するため
        - SameSite 属性を `None` に設定する必要がある
        - SameSite 属性を `Lax` や `Strict` に設定すると
        - ブラウザが クッキーを送信できなくなるため
      - CSRF 防御策としては 利用できない
      - なお、SameSite 属性が `None` の場合
        - Secure 属性を付与する必要があることに注意

  - 注意点: `hono/csrf` ミドルウェアは SPA + API 構成 においてあまり効果がない
    - SPA + API 構成の場合 `application/json` の リクエストボディ しか受け付けない場合が多い
    - 一方、`hono/csrf` ミドルウェアは
    - HTML form の遅れる コンテンツタイプに対して CSRF 防御を提供するものである
      - `application/x-www-form-urlencoded`
      - `multipart/form-data`
      - `text/plain`
    - そのため SPA + API 構成においては あまり効果がない

# おわりに

今回は、SPA + API のセッション管理について、安全性の Tier 表を考えてみました。
安全な手法を取るに越したことはありませんが、安全性を高めるほど、利便性やインフラコストとのトレードオフが発生します。
自分のアプリケーションにとって、どの程度の安全性が必要かを見極め、適切なセッション管理手法を選択しましょう。

読んでいただき、ありがとうございました。
