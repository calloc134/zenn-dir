---
title: "再考React - 第 1 回 はじめに: 宣言的 UI と UI フレームワーク"
emoji: "⚛️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react", "frontend", "javascript", "typescript"]
published: false
---

# はじめに

こんにちは。かろっく@calloc134 です。

皆さんは React を使っていて、以下のような感想を持ったことはありませんか？

「React ってやたら複雑な仕組みを持っているけど、なぜこんな設計なんだろう」
「useEffectの使い方がよくわからず、雰囲気で使ってる」

この記事シリーズではReact の設計思想を深掘りし、
React がなぜこのような設計になっているのか、
それによりどのようなことを実現しようとしているのかを解説していきます。

第 1 回では、React を含む UI フレームワーク全般に共通する
「宣言的 UI」という考え方から始めていきましょう。

:::message
今回は、Web における UI フレームワークに絞って解説を行います。
そのため、React Native などについては言及を避け、

実際のUI = 実際の DOM、いわゆる **実DOM** として説明を行います。
:::

# 宣言的 UI とは

宣言的 UI とは、
**How（UI をどう描くか）** を記述せず、
**What（UI がどうあるべきか）を記述するスタイル**のことです。

従来の命令的な UI 構築では、UI を描画するために

- 表示したい見た目を、開発者が手動で挿入
- データが変化したら、開発者が見た目を手動で更新

といった手順を、手動でひとつひとつ記述する必要がありました。

一方、宣言的 UI では

- 表示したい見た目を記述するだけで、見た目が自動で挿入される
- データが変化したら、見た目が自動で更新される

といった形で、
「この状態のときは、こういう UI であるべき」という最終的な姿だけを記述します。

Web フロントエンドの分野では、

- 命令的 UI: `document.createElement` や `innerHTML` を使って
  実DOM を直接操作するスタイル
- 宣言的 UI: React や Vue などのフレームワークに
  実DOMの描画・更新を任せるスタイル

といえるでしょう。

## 要素という概念

宣言的 UI を採用するフレームワークには、
**仮想的に UI・見た目 を表現したオブジェクト**である「要素」が存在します。

開発者は、この「要素」本体および、
要素を生成する何らかの仕組みを実装します。

逆に、この要素から実際の UI を生成する処理は
宣言的 UIフレームワークが担当してくれるため、
開発者は UI の更新ロジックを意識する必要がなくなります。

要素を生成する仕組みは、関数やクラスで実装を行います。

開発者が実装した 要素を生成する仕組みをフレームワークに与えると、
フレームワークはそれを実行し、要素を取得します。
その後、要素をもとに UI を描画・更新します。

## フレームワークによる差分検知と更新

UIの描画・更新について、詳しく見ていきましょう。
何らかの方法で生成された「要素」をフレームワークが受け取ると、
フレームワークは以下の 2 つを比較し、差分検知を行います。

1. フレームワーク内部に保持されている**過去の内部状態**
2. 今回新しく作成されフレームワークに与えられる **「要素」**

この比較の結果、以下のものが得られます。

- UI の差分情報
- 今回新しく作成した現在の内部状態

フレームワークは、洗い出した差分を実 DOM に適用することで実際の UI を更新します。
また、今回新しく作成した現在の内部状態は
次回以降利用するためにフレームワーク内部に保持されます。

## 宣言的 UI の利点

この設計により、
**UI 更新の詳細な手続きをフレームワークに任せることができる**という大きな利点が産まれます。

開発者は「今この状態ならこういう見た目」という対応関係だけを記述すればよく、
「前の状態からどう変更するか」という差分の計算はフレームワークが担当してくれます。

## 具体例

### React の場合

React では、開発者は要素を生成する仕組みを**関数（関数コンポーネント）** で実装します。

```tsx
function Counter({ count }: { count: number }) {
  return <div>Count: {count}</div>;
}
```

React が要素生成関数、つまり関数コンポーネントを呼び出し、要素を受け取ります。
あとは React が要素の差分を検知し、実 DOM に最小限の変更を加えます。

### Vue の場合

Vue では、開発者は要素を生成する仕組みを**レンダリング関数**で実装します。

```javascript
render() {
  return h('div', {}, `Count: ${this.count}`)
}
```

Vue がレンダリング関数を呼び出し、要素を受け取ります。
あとは Vue が要素の差分を検知し、実 DOM に最小限の変更を加えます。

## 差分検知アルゴリズム: Reconciliation

差分検知アルゴリズムは **Reconciliation** と呼ばれます。

Reconciliation とは UI のみに存在する単語ではなく、
宣言的なシステムを構築する際に広く用いられる概念です。
例えば、Kubernetes の Reconciliation Loop も同様の概念に基づいています。

「あるべき姿」と「現在の姿」を比較し、差分を埋めるという考え方は、
宣言的システム全般に通じるものであるといえるでしょう。

# React の思想を語る前に

ここまでは、React を含む UI フレームワーク全般に共通する考え方を解説してきました。
これ以降は、React 特有の思想について解説していきます。

その前に、一つ重要な用語の整理をしておきます。

## 「仮想 DOM」という言葉を使わない理由

今回の解説では **「仮想 DOM」という言葉を使いません**。

「仮想 DOM」という言葉は、誤解を招きやすいためです。仮想 DOM という言葉は、以下の 2 つの異なる概念を混同してしまいます。

1. **React が受け取る要素**
   - React 要素（仮想的に UI を記述したオブジェクト）
2. **React が内部的に保持する内部状態**
   - Fiber ツリー（仮想的に状態を表現したデータ構造）

ここからは それぞれ **「React 要素」** と **「Fiber ツリー」** と呼び、
これら2つを明確に区別して説明していきます。

# おわりに

今回は、宣言的 UI と UI フレームワークの基本的な考え方について解説しました。

宣言的 UI では、開発者は「UI がどうあるべきか」を記述するだけでよく、「どう更新するか」はフレームワークが担当してくれます。
この設計により、コードの可読性・保守性が向上し、複雑な UI の構築が容易になります。

次回は、React 特有の思想である**純粋関数性**について解説していきます。
React がなぜ関数コンポーネントを推奨し、なぜ純粋性を重視するのか、
深掘りしていきましょう。
