---
title: "React の思想を考える - 第 1 回 はじめに: 宣言的 UI と UI フレームワーク"
emoji: "⚛️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react", "frontend", "javascript", "typescript"]
published: false
---

# はじめに

こんにちは。かろっく@calloc134 です。

皆さんは React を使っていて、なぜこのような設計になっているのか疑問に思ったことはありませんか？

「なぜ仮想 DOM なのか」「なぜ状態管理がこのような形式なのか」「useEffect は何のためにあるのか」

これらの疑問に対する答えは、React の設計思想を理解することで見えてきます。

この記事シリーズでは、React の設計思想を深掘りし、React がなぜこのような設計になっているのかを解説していきます。第 1 回では、React を含む UI フレームワーク全般に共通する「宣言的 UI」という考え方から始めていきましょう。

:::message
今回は、Web における UI フレームワークに絞って解説を行います。
そのため、React Native などについては言及を避けます。

また、誤りや間違いの指摘（いわゆるマサカリ）は大歓迎です。
気軽に Issue や Twitter（現 X）などで指摘してください。
:::

# 宣言的 UI とは

宣言的 UI とは、**How（UI をどう描くか）を記述せず、What（UI がどうあるべきか）を記述するスタイル**のことです。

従来の命令的な UI 構築では、「ボタンを作成して」「テキストを設定して」「クリックイベントを登録して」といった手順を逐一記述する必要がありました。一方、宣言的 UI では「この状態のときは、こういう UI であるべき」という最終的な姿だけを記述します。

## 要素という概念

宣言的 UI を採用するフレームワークには、**仮想的に UI の状態を表現したオブジェクト**である「要素」が存在します。

開発者は、この「要素」を生成する仕組みのみを実装すれば良いのです。要素を生成する仕組みは、関数で実装することもできますし、クラスで実装することもできます。

フレームワークは、開発者が定義した要素を生成する関数やクラスを実行し、要素を取得します。

## フレームワークによる差分検知と更新

何らかの方法で生成された「要素」をフレームワークが受け取ると、フレームワークは以下の 2 つを比較し、差分検知を行います。

1. フレームワーク内部に保持されている**過去の内部状態**
2. 今回新しく作成されフレームワークに与えられる**「要素」**

この比較の結果、以下のものが得られます。

- UI の差分情報
- 今回新しく作成した現在の内部状態

フレームワークは、洗い出した差分を実 DOM に適用することで実際の UI を更新します。また、今回新しく作成した現在の内部状態は、次回以降利用するためにフレームワーク内部に保持されます。

## 宣言的 UI の利点

この設計により、以下の利点が得られます。

- **UI 更新のロジックをフレームワークに任せることができる**
- **UI の状態を宣言的に記述できるため、コードの可読性・保守性が向上する**

開発者は「今この状態ならこういう見た目」という対応関係だけを記述すればよく、「前の状態からどう変更するか」という差分の計算はフレームワークが担当してくれます。

## 具体例

### React の場合

React では、開発者は要素を生成する仕組みを**関数（関数コンポーネント）**で実装します。

```tsx
function Counter({ count }: { count: number }) {
  return <div>Count: {count}</div>;
}
```

React が要素生成関数（関数コンポーネント）を呼び出し、要素を受け取ります。あとは React が要素の差分を検知し、実 DOM に最小限の変更を加えます。

### Vue の場合

Vue では、開発者は要素を生成する仕組みを**レンダリング関数**で実装します。

```javascript
render() {
  return h('div', {}, `Count: ${this.count}`)
}
```

Vue がレンダリング関数を呼び出し、要素を受け取ります。あとは Vue が要素の差分を検知し、実 DOM に最小限の変更を加えます。

## 差分検知アルゴリズム: Reconciliation

差分検知アルゴリズムは **Reconciliation** と呼ばれます。

Reconciliation とは UI のみに存在する単語ではなく、宣言的なシステムを構築する際に広く用いられる概念です。例えば、Kubernetes の Reconciliation Loop も同様の概念に基づいています。

「あるべき姿」と「現在の姿」を比較し、差分を埋めるという考え方は、宣言的システム全般に通じるものなのです。

# コンポーネント合成をベースとするアーキテクチャ

宣言的 UI と並んで重要なのが、**コンポーネント合成をベースとするアーキテクチャ**です。

これは、UI を**再利用可能な部品（コンポーネント）に分割し、組み合わせて UI を構築するスタイル**のことです。

```tsx
function App() {
  return (
    <div>
      <Header />
      <MainContent />
      <Footer />
    </div>
  );
}
```

このように、大きな UI を小さなコンポーネントに分割し、それらを組み合わせることで複雑な UI を構築していきます。

# React の思想を語る前に

ここまでは、React を含む UI フレームワーク全般に共通する考え方を解説してきました。これ以降は、React 特有の思想について解説していきます。

その前に、一つ重要な用語の整理をしておきます。

## 「仮想 DOM」という言葉を使わない理由

今回の解説では**「仮想 DOM」という言葉を使いません**。

「仮想 DOM」という言葉は、誤解を招きやすいためです。仮想 DOM という言葉は、以下の 2 つの異なる概念を混同してしまいます。

1. **React が受け取る要素**
   - React 要素（仮想的に UI を記述したオブジェクト）
2. **React が内部的に保持する内部状態**
   - Fiber ツリー（仮想的に状態を表現したデータ構造）

React の文脈においては、それぞれ**「React 要素」**と**「Fiber ツリー」**と呼んでいくことにします。

# おわりに

今回は、宣言的 UI と UI フレームワークの基本的な考え方について解説しました。

宣言的 UI では、開発者は「UI がどうあるべきか」を記述するだけでよく、「どう更新するか」はフレームワークが担当してくれます。この設計により、コードの可読性・保守性が向上し、複雑な UI の構築が容易になります。

次回は、React 特有の思想である**純粋関数性**について解説していきます。React がなぜ関数コンポーネントを推奨し、なぜ純粋性を重視するのかを深掘りしていきましょう。
