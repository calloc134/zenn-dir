---
title: "【OAuth】アクセストークンの検証をサボると成りすまし攻撃ができます"
emoji: "🎃"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["OAuth", "JWT", "セキュリティ"]
published: false
---

# はじめに

こんにちは。calloc134 です。

近年、Auth0 などの外部認証プロバイダを用いて、OAuth ベースでログインを実装するサービスが増えています。
その際、SPA (Single Page Application) のフロントエンドとバックエンド API が分かれている構成がよく見られます。
このような構成では、フロントエンドが OAuth プロバイダでログインし、アクセストークンを取得して、バックエンド API に送信し、バックエンド API がアクセストークンを検証して認可を行う、という流れになります。

しかし、そのアクセストークンの検証に不備があると、成りすまし攻撃が可能になる場合があります。

今回の記事では、
この脆弱性の根本的な問題はそもそも何なのか、この実装のどこに問題があるのか、OAuth 仕様から見てこの実装はお行儀が良いのか、などを解説します。

# 想定シナリオ

- ブラウザでログインのできるサービス A がある
  - サービス A はフロントエンドとバックエンドの API に分かれている
  - サービス A は Auth0 を用いてログイン
  - バックエンドにはアクセストークンを送信して API を呼び出す
  - バックエンド API はアクセストークンを検証する
- サービス B の開発者 は 成りすまし攻撃ができるかも と思い立つ
  - 被害者が サービス B にログインしている
  - サービス B の開発者は 被害者のアクセストークンを入手する
    - サービス B の運営なので、被害者のアクセストークンを入手できる
  - サービス B の開発者は 被害者のアクセストークンをサービス A のバックエンド API に送信する
- サービス A のバックエンドは サービス B のアクセストークンを受け入れてしまう
  - サービス B の開発者が、被害者になりすましてサービス A のバックエンド API を呼び出せる！
  - つまり、サービス B の開発者は 被害者になりすまして サービス A を利用できる！
  - → なりすましの完成！

# 今回の攻撃の概念実証を作った

- 攻撃の概念実証を作成した
  - 利用するサービス: Auth0, Hono
  - 攻撃の対象: OAuth アクセストークンの検証に不備があるバックエンド API
  - サービス A: フロントエンド + 脆弱なバックエンド API + セキュアなバックエンド API
  - サービス B: 同じくフロントエンド + 脆弱なバックエンド API + セキュアなバックエンド API
- サービス A と サービス B は同じ Auth0 テナントを使っている
- 攻撃の流れ
  - ユーザがサービス A にログイン
  - サービス A のアクセストークンを取得
  - ユーザがサービス A のアクセストークンを用いて
  - サービス A の 脆弱なバックエンド API ・ セキュアなバックエンド API を呼び出す
    - どちらも成功
  - ユーザがサービス A のアクセストークンを用いて
  - サービス B の 脆弱なバックエンド API ・ セキュアなバックエンド API を呼び出す
    - 脆弱なバックエンド API は成功 → なりすまし成功
    - セキュアなバックエンド API は失敗

アクセストークンが使い回せるため、
もし攻撃者のサービス B が多くのユーザに使われていたら
サービス B の管理人は
サービス B の利用者全員になりすまして
サービス A を利用することができてしまいます。

# バックエンド API がアクセストークンを検証する実装

- まずこの例ではフロントエンドとバックエンドがある
  - フロントエンドは Auth0 でログイン
  - フロントエンドはアクセストークンを取得
  - フロントエンドはバックエンド API にアクセストークンを送信
  - バックエンド API はアクセストークンを検証する
  - アクセストークンが正しければ※ API を実行する
- ※ の検証に不備があったのが今回の問題
  - アクセストークンの署名検証はしていた

# OAuth 仕様から見てこの実装はお行儀が良いか

- OAuth 仕様から見れば、今回の実装は以下の通り
  - フロントエンド = OAuth クライアント
    - public client といえる
  - バックエンド API = OAuth リソースサーバ
- OAuth 仕様では
  - リソースサーバはアクセストークンの発行元 (OAuth 認可サーバ) を検証する責務がある
  - また、どのリソースサーバ向けのアクセストークンかを検証する責務もある
  - 仕様にある通りに検証すれば、成りすましは発生しない
  - また仕様では、`scope` クレームの検証も MUST とされている
-

# 知識の前提となる OAuth の仕様

- OAuth においてアクセストークンを JWT 形式にする仕様
  - RFC 9068 OAuth 2.0 JWT Access Tokens
- Auth0 もほぼ同じような形式を利用する
  - 一部のクレームが異なるだけ
- ここでは重要なポイントのみを解説
  - アクセストークンは JWT 形式で発行される
  - JWT のクレームとして
  - 発行元 (issuer) を示す `iss` クレーム
  - 対象者 (audience) を示す `aud` クレーム
  - スコープを示す `scope` クレーム
  - などが含まれる
- アクセストークンにおける`aud`クレームは
  - アクセストークンがどのリソースサーバ向けに発行されたかを示す
  - 例えば、サービス A のバックエンド API 向けに発行されたアクセストークンは
  - `aud` クレームに サービス A のバックエンド API の識別子が含まれる
  - サービス B のバックエンド API 向けに発行されたアクセストークンは
  - `aud` クレームに サービス B のバックエンド API の識別子が含まれる
- リソースサーバは アクセストークンの `aud` クレームを検証し
  - 自分自身の識別子が含まれていることを確認する責務がある
  - これにより、他のリソースサーバ向けに発行されたアクセストークンを拒否できる
- これを怠ると、他のリソースサーバ向けに発行されたアクセストークンを受け入れてしまい
  - 成りすまし攻撃が可能になる

# Hono の JWT ミドルウェア に指摘された問題

- 今回の問題は、Hono が提供する JWT ミドルウェアを
- 開発者が誤って使ったことに起因する
- Hono の JWT ミドルウェアが作られた意図
  - 単なる JWT 検証ミドルウェアとして提供されている
  - つまり OAuth リソースサーバ向けに特化していない
  - OAuth リソースサーバ向けに使う場合は
    - 発行元 (issuer) の検証
    - 対象者 (audience) の検証
    - scope クレームの検証 (必要なら)
    - などを開発者が実装する必要がある
- しかし、今回の実装などで
  - JWT ミドルウェアを用いてバックエンド API を認可する場合
    - iss 検証は行うことができるが
    - aud パラメータを検証するオプションが存在しなかった
  - Hono 利用者が aud パラメータを検証せずそのまま利用すると
    - 他サービスのアクセストークンを受け入れてしまう
    - → 成りすまし攻撃が可能になる
  - CVE-2025-62610 として報告された
- Hono 側の修正
  - JWT ミドルウェアに対して aud 検証のオプションが追加された
  - これにより、backend api を認可する場合でも
  - aud 検証をミドルウェアで行い
  - 安全に利用できるようになった
- 開発者さん本人がブログを提供している
  - https://zenn.dev/okazu_dm/articles/d72419e2431761
  - コントリビュートありがとうございます！

# フレームワークの責務と利用者の責務

- 筆者の意見
  - この問題は フレームワークの責務と利用者の責務の境界に関する問題
  - フレームワーク側の意図は、単なる JWT 検証ミドルウェアを提供すること
- 本来であれば 利用者は JWT ミドルウェアの利用に加えて
  - 発行元 (issuer) の検証
  - 対象者 (audience) の検証
- の両方を行うミドルウェアを実装すべき
- 今回は CVE が降りたが
  - 利用者のミドルウェア利用の用法ミスに起因するものであり
  - Hono 自体に脆弱性があるとは言い難い

# 他フレームワークの対応

- Hono 以外のフレームワークではどうだろう
  - Express.js
    - https://auth0.github.io/node-oauth2-jwt-bearer/
    - AUth0 が提供するミドルウェア
    - `jose` をベースに開発されている
    - JWT の検証に加え、iss/aud 検証も行う
    - scope 検証にも対応している
  - Fastify
    - https://github.com/nearform/fastify-jwt-jwks
    - 有志によるプラグイン
    - `@fastify/jwt` をベースに開発されている
    - JWT の検証に加え、iss/aud 検証もサポート
    - scope 検証には未対応の模様
  - Elysia
    - https://github.com/ap-1/elysia-oauth2-resource-server
    - 有志によるプラグイン
    - `jose` をベースに開発されている
    - JWT の検証に加え、iss/aud 検証もサポート
    - `scope` 検証にも対応している
- まとめると
  - Express.js, Fastify, Elysia の各フレームワークでは
  - JWT 検証ミドルウェア において
    - iss/aud 検証をサポートしているものが多い
    - scope 検証をサポートしているものもある
      - これは仕様では必須だが、実装はまちまち

# できるならアクセストークンをセッションのように使わないでほしい

- そもそも、アクセストークンをセッションとして利用するのは
- OAuth の本来の使い方から外れている
  - セッションならクライアント-・サーバで別の仕組みを使うべき
    - クッキーベースのセッション
    - アクセストークンでは別の
    - バックエンドサーバが発行する JWT を用いたセッション
- OAuth アクセストークンは
  - API 間の認可を行うためのトークン
  - クライアント・サーバ間のセッションを管理するためのトークンではない
- OAuth アクセストークンを
- クライアント・サーバ間のセッションとして使うと
  - OAuth クライアントを Public Client として実装する必要がある
  - OAuth の行儀からしてみればこれは望ましくない
- フロントエンドを Public Client として動作させ、
  - アクセストークンをセッションのように使う例は
  - 実際のサービスでも見かけるが、
  - 可能であれば避け、
  - バックエンドで発行するクッキーや JWT を用いたセッション管理を推奨したい
  - OAuth アクセストークンは API 間の認可に使うべきものである！

# 結論

- そもそも
  - OAuth アクセストークンをセッションのように使うのは避けるべき
  - クライアント・サーバ間のセッション管理には
    - クッキーベースのセッション
    - バックエンド発行の JWT セッション
  - を使うべき
- もし OAuth アクセストークンをクライアント・サーバ間のセッションとして使う場合は
  - OAuth に対しての十分な理解を持ち
  - バックエンド API が OAuth リソースサーバとして動作することを踏まえた上で
  - 提供されるミドルウェアの用法を誤らずに実装すること
  - リソースサーバに必要な要件
    - 発行元 (issuer) 検証
    - 対象者 (audience) 検証
    - scope クレーム検証 (必要なら)
  - を必ず実装すること！
  - これを怠ると成りすまし攻撃が可能になる！

# プロバイダごとのテナント分離機能と攻撃困難さ

# 余談: Opaque トークンでもこの問題は発生するか？

# おわりに

今回は、アクセストークン検証不備による成りすまし攻撃について解説しました。
OAuth 仕様というのは複雑です。
また、OAuth をセッション管理に使うのは本来の使い方から外れていると、筆者は考えています。
それでも OAuth をセッション管理に使う場合は、ミドルウェアの用法を誤らないように、しっかりと公式ドキュメントや仕様を読み込む必要があります。

どちらにせよ、十分な理解のもとで、正しい実装を行うことが重要です。

皆さんも雰囲気で OAuth を使わず、仕様をよく理解した上で安全な実装を心がけましょう！
