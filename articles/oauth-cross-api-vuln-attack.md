---
title: "【OAuth】アクセストークンの検証をサボると成りすまし攻撃ができます"
emoji: "🎃"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["OAuth", "JWT", "セキュリティ"]
published: false
---

# はじめに

こんにちは。calloc134 です。

近年、Auth0 などの外部認証プロバイダを用いて、
OAuth/OIDC ベースでログインを実装するサービスが増えています。

その際、フロントエンドとバックエンド API を分けて実装し、
ログインをフロントエンドで済ませ、バックエンド API をアクセストークン付きで呼び出す形態を取ることが多いようです。

しかしそのアクセストークンの検証に不備がある場合、
**成りすまし攻撃が可能になること**があります。

今回の記事では、この脆弱性の根本的な問題はそもそも何なのか、
この実装のどこに問題があるのか、
そして OAuth 仕様から見てこの実装は果たして行儀が良いのか？

などを解説していきたいと思います。

# 想定シナリオ

今回の問題は、
**サービスがアクセストークンの検証を怠っていた場合に成りすまし攻撃が可能になる**
というものです。
具体的なシナリオを考えてみましょう。

まず、ブラウザでログインのできるサービス A があるとします。

サービス A はフロントエンドとバックエンドの API に分かれており、
Auth0 を用いてログインを実装しています。

フロントエンドからバックエンドにはアクセストークンを送信して API を呼び出し、
バックエンド API はそのアクセストークンを検証します。

また、同様にブラウザでログインのできるサービス B も存在します。
ここで前提として、**サービス B の開発者は悪意ある者である**という仮定を置きます。

攻撃の流れは以下のようになります。

1. 被害者が、サービス B にログインする
2. 悪意あるサービス B の開発者は、
   被害者がサービス B にログインしていることを利用して
   被害者のアクセストークンを入手する
   （サービス B の運営者なので、当然被害者のアクセストークンを入手できる）
3. サービス B の開発者は、
   被害者のアクセストークンをサービス A のバックエンド API に送信する
4. サービス A のバックエンドは検証を怠っているため
   サービス B 向けのアクセストークンを受け入れてしまう
5. つまり、サービス B の開発者が被害者になりすまして、
   サービス A のバックエンド API を呼び出せる
6. **なりすましの完成！**

このように、サービス B の開発者は被害者になりすまして
サービス A を利用できてしまうのです。

文字で解説されても、分かりづらいですね。

# 今回の攻撃の概念実証を作った

この攻撃の概念実証を作成しました。
以下の URL から動作を確認できます。

**サービス A**
https://frontend-client-a.calloc134personal.workers.dev/

**サービス B**
https://frontend-client-b.calloc134personal.workers.dev/

## 技術構成と設計

今回の概念実証では Auth0 と Hono を利用しています。

サービス A とサービス B はそれぞれ、

- フロントエンド（React）
- 脆弱なバックエンド API （Hono）
- セキュアなバックエンド API （Hono）

を持っています。

:::message
サービス A とサービス B は同じ Auth0 テナントを利用する、という前提です。
別テナントの際の挙動については後述します。
:::

## 攻撃の流れ

今回の概念実証では、ユーザ自身が動作検証を行えるようにしています。

概念実証では簡単のため、
被害者と攻撃者を同一ユーザが演じる形式になっています。

概念実証の流れを整理すると以下のようになります。

1. ユーザがサービス B にログインし
   サービス B のアクセストークンを取得する
2. 概念実証サイトでは、
   サービス A のバックエンド API と サービス B のバックエンド API を
   両方呼び出せるようになっている
3. サービス B の脆弱なバックエンド API・セキュアなバックエンド API を呼び出す
   → もちろんどちらも成功（正規用途の動作確認）
4. サービス A の脆弱なバックエンド API・セキュアなバックエンド API を呼び出す
   - 脆弱なバックエンド API は成功 → **なりすまし成功**
   - セキュアなバックエンド API は失敗 → 成りすまし失敗

脆弱なバックエンド API 側は検証不備により、アクセストークンが使い回せてしまいます。

もし攻撃者のサービス B が多くのユーザに使われていたら、
サービス B の管理人はサービス B でアクセストークンを発行したすべてのユーザについて
成りすまして サービス A を利用することができてしまいます。

# バックエンド API がアクセストークンを検証する実装

前提として、今回の実装を技術的にもう少し深掘りしてみましょう。

今回の例では、以下のような構成になっています。

- **フロントエンド**: Single Page Application（例: React）
- **バックエンド**: API サーバ（例: Hono）
- **OAuth/OIDC プロバイダ**: 任意の IDaaS プロバイダ（例: Auth0）

全体の流れは以下のようになります。

1. フロントエンドは Auth0 で OAuth/OIDC ログインを行う
2. フロントエンドはアクセストークンを取得する
3. フロントエンドはバックエンド API にアクセストークンを送信する
4. バックエンド API はアクセストークンを検証する
5. アクセストークンが正しければ API を実行する

今回の問題は、
5 の「アクセストークンが正しければ」という検証に不備があったことに起因します。
アクセストークンの署名検証自体は行っていたものの、それだけでは十分ではなかったのです。

どのような検証が不足していたのか、以降で詳しく解説します。

# OAuth 仕様から見てこの実装はお行儀が良いか

まず、前提の基礎固めをしましょう。
OAuth 仕様に照らすと、今回の実装は以下のように整理できます。

- **フロントエンド** = OAuth クライアント（Public Client といえる）
- **バックエンド API** = OAuth リソースサーバ

ところで、OAuth 仕様では、リソースサーバはアクセストークンを受け取ったとき、
アクセストークンの発行元（OAuth 認可サーバ）を検証する責務があります。
また、本当に自身宛てに発行されたアクセストークンなのかを確かめるために、
どのリソースサーバ向けに発行されたアクセストークンなのかを検証する責務もあります。

結論から言えば、仕様にある通りに検証すれば、アクセストークンの使いまわしによる成りすましは発生しません。

さらに仕様では、アクセストークンに紐づく `scope` の検証も MUST とされています。

:::message
余談ですが、筆者の意見では、一般的なリソースサーバではなく、
バックエンド API の認可のみに OAuth アクセストークンを使う場合は
`scope` クレームまで検証する必要は流石になさそうだと考えています。
:::

# JWT 形式のアクセストークン

OAuth はアクセストークンの形式を規定していませんが、
今回は Auth0 を採用したため、これに準拠して、
OAuth アクセストークンが JWT 形式で発行される場合を想定します。

OAuth においてアクセストークンを JWT 形式にする仕様としては、
**RFC 9068 OAuth 2.0 JWT Access Tokens** があります。

Auth0 もほぼ同じような形式を利用しており、
デフォルトでは Auth0 独自形式ですが、RFC 9068 との差異は一部のみであり、
今回の問題には影響しません。

ここでは重要なポイントのみに絞るため、RFC 9068 に準拠した説明を行います。

アクセストークンは JWT 形式で発行され、JWT のクレームとして以下のものが含まれます。

- 発行元（issuer）を示す `iss` クレーム
- 対象者（audience）を示す `aud` クレーム
- スコープを示す `scope` クレーム

アクセストークンにおける `aud` クレームは、
アクセストークンがどのリソースサーバ向けに発行されたかを示します。

例えば、サービス A のバックエンド API 向けに発行されたアクセストークンは、
`aud` クレームにサービス A のバックエンド API の識別子が含まれます。
同様に、サービス B のバックエンド API 向けに発行されたアクセストークンは、
`aud` クレームにサービス B のバックエンド API の識別子が含まれます。

リソースサーバはアクセストークンの `aud` クレームを検証し、
自分自身の識別子が含まれていることを確認する責務があります。
これにより、他のリソースサーバ向けに発行されたアクセストークンを拒否できます。

**この検証を怠ると、**
**他のリソースサーバ向けに発行されたアクセストークンを受け入れてしまい、**
**成りすまし攻撃が可能になってしまうのです。**

# Hono の JWT ミドルウェアに指摘された問題

今回の問題は、Hono が提供する JWT ミドルウェアを開発者が誤って使ったことに起因します。

Hono の JWT ミドルウェアは 単なる JWT 検証ミドルウェアとして提供されており、OAuth リソースサーバ向けに特化していません。OAuth リソースサーバ向けに使う場合は、発行元（issuer）の検証、対象者（audience）の検証、scope クレームの検証（必要なら）などを開発者が実装する必要があります。

しかし、今回の実装のように JWT ミドルウェアを用いてバックエンド API を認可する場合、`iss` 検証は行うことができるものの、**`aud` パラメータを検証するオプションが存在しませんでした**。Hono 利用者が、`aud` パラメータのオプションがないという理由で `aud` パラメータを検証せずそのまま利用すると、他サービスのアクセストークンを受け入れてしまい、成りすまし攻撃が可能になります。

この問題は **CVE-2025-62610** として報告されました。正しい脆弱性の表現としては、`token mix-up` 攻撃と呼称します。

## Hono 側の修正

JWT ミドルウェアに対して `aud` 検証のオプションが追加されました。これにより、バックエンド API を認可する場合でも、`aud` 検証をミドルウェアで行う設定にすれば、安全に利用できるようになりました。

## 注意点

重要なのは、**デフォルトで自動的に安全になるわけではない**ということです。開発者が `aud` 検証を有効にし、正しく活用する必要があります。開発者のリテラシー向上が求められます。

なお、ドキュメントにはまだ反映されていないようです。筆者は Hono のコントリビューターではないので、コントリビューターの方がやってくれるのが一番ですが、ドキュメントに反映される見通しが少ない場合は、自分が PR を出そうかなと考えています。その場合、どのように開発者に `aud` 検証の重要性を伝えるかが課題です。

この問題に対応してくださった開発者さん本人がブログを公開されています。コントリビュートありがとうございます！

https://zenn.dev/okazu_dm/articles/d72419e2431761

# フレームワークの責務と利用者の責務

筆者の意見では、根本的な問題はフレームワークの責務と利用者の責務の境界に関する問題です。フレームワーク側の意図は、単なる JWT 検証ミドルウェアを提供することだと考えています。これは推測ですが、「JWT ミドルウェア」という名称からしてそのように読み取れます。

本来であれば、利用者は OAuth 認可の用途でアクセストークン検証を行う場合、JWT ミドルウェアの利用で署名検証と発行元（issuer）の検証を行うことを前提に、JWT ミドルウェアでは行われない対象者（audience）の検証を自分で実装する必要があります。ペイロードをデコードして検証するミドルウェアを自分の手で実装すべきなのです。

今回は CVE が降りましたが、根本的原因は利用者のミドルウェア利用の用法ミスに起因するものであり、Hono 自体の脆弱性、あるいは Hono の JWT ミドルウェアの脆弱性とは考えづらいというのが筆者の意見です。

`aud` を検証可能なオプションを追加したという修正は、利用者のミドルウェア利用の用法ミスを防ぐための Hono 側の配慮であって、Hono の JWT ミドルウェアの脆弱性ではないし、自動的に脆弱な実装が防がれるものでもありません。

もうひとつの世界線として、バックエンド API の認可を行う用途であれば、Hono が JWT ミドルウェアとは別に OAuth リソースサーバ用にアクセストークンを検証するためのミドルウェアを提供し、そのミドルウェアを利用することを推奨するという手もあるかもしれません。ただ、今回の解決策でも対応は十分かなと考えています。

他のフレームワークでも、OAuth リソースサーバ向けに特化したアクセストークン検証ミドルウェアはあまり提供されていないように思います（筆者の知る限りでは）。逆に、JWT 検証ミドルウェアにおいて `aud` 検証をサポートしているものが多いです。

# 他フレームワークの対応

Hono 以外のフレームワークではどのような対応がされているでしょうか。

## Express.js

Auth0 が提供するミドルウェア [node-oauth2-jwt-bearer](https://auth0.github.io/node-oauth2-jwt-bearer/) があります。`jose` をベースに開発されており、JWT の検証に加え、`iss`/`aud` 検証も行います。`scope` 検証にも対応しています。

## Fastify

サードパーティによるプラグイン [fastify-jwt-jwks](https://github.com/nearform/fastify-jwt-jwks) があります。`@fastify/jwt` をベースに開発されており、JWT の検証に加え、`iss`/`aud` 検証もサポートしています。`scope` 検証には未対応の模様です。

## Elysia

有志によるプラグイン [elysia-oauth2-resource-server](https://github.com/ap-1/elysia-oauth2-resource-server) があります。`jose` をベースに開発されており、JWT の検証に加え、`iss`/`aud` 検証もサポートしています。`scope` 検証にも対応しています。

## まとめ

Express.js、Fastify、Elysia の各フレームワークでは、JWT 検証ミドルウェアにおいて `iss`/`aud` 検証をサポートしているものが多く、`scope` 検証をサポートしているものもあります。

# できるならアクセストークンをセッションのように使わないでほしい

そもそも、アクセストークンをセッションとして利用するのは OAuth の本来の使い方から外れています。セッション用途なら、OAuth の仕組みを無理に利用せず、クライアント・サーバ間で別の仕組みを使うべきです。例えば、クッキーベースのセッションや、バックエンドサーバが発行する JWT を用いたセッションなどが挙げられます。

OAuth アクセストークンは API 間の認可を行うためのトークンであり、クライアント・サーバ間のセッションを管理するためのトークンではありません。OAuth アクセストークンをクライアント・サーバ間のセッションとして使うと、OAuth クライアントを Public Client として実装する必要があり、OAuth の行儀からしてみればこれは望ましくありません（詳細は別の記事で解説予定です）。

フロントエンドを Public Client として動作させ、アクセストークンをセッションのように使う例は実際のサービスでも頻繁に見られますが、可能であれば避けるべきです。バックエンドで発行するクッキーや JWT を用いたセッション管理を推奨したいと思います。**OAuth アクセストークンは API 間の認可に使うべきものです！**

# 結論

筆者の意見では、そもそも OAuth アクセストークンをセッションのように使うのは避けるべきです。クライアント・サーバ間のセッション管理には、クッキーベースのセッションやバックエンド発行の JWT セッションを使うべきです。

もし OAuth アクセストークンをクライアント・サーバ間のセッションとして使う場合は、OAuth に対しての十分な理解を持ち、バックエンド API が OAuth リソースサーバとして動作することを踏まえた上で、提供されるミドルウェアの用法を誤らずに実装することが重要です。

リソースサーバに必要な要件として、以下を必ず実装してください。

- 発行元（issuer）検証
- 対象者（audience）検証
- scope クレーム検証（必要なら）

**これを怠ると成りすまし攻撃のリスクがあります！**

# 余談: プロバイダごとのテナント分離機能と攻撃困難さ

実は、IDaaS プロバイダにはテナントという概念が存在します。テナントとは、アプリケーションが所属する論理的なグループで、同一テナント内では同一 Issuer / 同一の JWT 署名鍵が使われます。

今まで解説したのは、同一テナントである前提でした。もし Auth0 を利用しており、サービス A とサービス B が異なるテナントに所属している場合は、JWT 署名検証で異なる署名鍵を使っているため攻撃不可能です。署名鍵が同じでも Issuer が異なるため攻撃不可能です（ちなみに、Auth0 の場合は Issuer はテナントのドメインです）。Auth0 の場合、テナントの違いが攻撃困難の要因となります。

では、Auth0 以外の IDaaS プロバイダではどうでしょうか？具体的に調査してみると、プロバイダの設定によっては脆弱になる場合があります。

## 注意が必要なプロバイダ

**OneLogin（generic issuer 利用時）**

generic issuer を使うと、issuer が `https://openid-connect.onelogin.com/oidc` で固定、公開鍵も `https://openid-connect.onelogin.com/oidc/certs` で固定になります。つまり、テナントが異なっても同一の issuer / 署名鍵になるため、同一テナントでなくても攻撃可能です。ただし、敢えてこの設定にした場合のみです。

**Firebase Auth**

Firebase プロジェクトがテナントに相当しますが、署名鍵は共通です。Issuer はプロジェクトごとに異なるため、署名鍵の検証のみの場合は攻撃可能ですが、Issuer 検証を行えば攻撃不可能です。

## 大半の場合は攻撃困難

しかし、大半の場合はテナント分離が適切に行われていれば、攻撃は困難になります。

**マネージド IDaaS プロバイダの例**

- **Okta**: Organization という概念がテナントに相当。Issuer と署名鍵が Organization ごとに異なる
- **AWS Cognito**: User pool という概念がテナントに相当。Issuer と署名鍵が User pool ごとに異なる

**セルフホスト系 IDaaS プロバイダの例**

- **Keycloak**: Realm という概念がテナントに相当。Issuer と署名鍵が Realm ごとに異なる
- **ZITADEL**: Instance という概念がテナントに相当。Issuer と署名鍵が Instance ごとに異なる
- **Logto**: Logto tenant という概念がテナントに相当。Issuer と署名鍵が Logto tenant ごとに異なる

## 結論

テナントが別ならこの脆弱性は起こりづらいです。署名鍵と Issuer が異なるためです。とはいえ、IDaaS プロバイダの設定によっては脆弱になる場合があるため、どのような挙動になるかは各自で確認する必要があります。

また、**テナントが同一の場合は、どのプロバイダであっても今回の脆弱性が発生する可能性を考慮しなければなりません**。

# 余談: Opaque トークンでもこの問題は発生するか？

Opaque トークン（非 JWT 形式のアクセストークン）でも同様の問題は発生する可能性があります。どのようなトークンであっても、リソースサーバは誰が発行したか（発行元）と、どのリソースサーバ向けか（対象者）を検証する責務があります。

Opaque トークンの場合、トークンの内容を直接検証できないため、トークン情報を取得するために認可サーバに問い合わせる必要があります。しかし、認可サーバに問い合わせる際に発行元（issuer）や対象者（audience）の検証を怠ると、同様の成りすまし攻撃が可能になります。

したがって、Opaque トークンであっても、リソースサーバは発行元と対象者に該当する情報の検証を必ず行う必要があります。

# おわりに

今回は、アクセストークン検証不備による成りすまし攻撃について解説しました。
OAuth 仕様というのは複雑です。
また、OAuth をセッション管理に使うのは本来の使い方から外れていると、筆者は考えています。
それでも OAuth をセッション管理に使う場合は、ミドルウェアの用法を誤らないように、しっかりと公式ドキュメントや仕様を読み込む必要があります。

どちらにせよ、十分な理解のもとで、正しい実装を行うことが重要です。

皆さんも雰囲気 OAuth を避け、仕様をよく理解した上で安全な実装を心がけましょう！
