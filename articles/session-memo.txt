
# 今回の前提条件

- フロントエンド: SPA (Single Page Application)
  - ブラウザ上で動作する JavaScript アプリケーション
- バックエンド: API サーバ
  - REST API をイメージ
  - JSON を受け取り JSON を返すことを前提
  - そのため クッキーを利用する場合は 以下の属性となる
    - Secure 属性: true
    - HttpOnly 属性: 場合による (後述)
    - SameSite 属性: ドメインに依る
      - 今回は解説しない
- 認証は 既に完了しており
  - これからセッションを開始する段階

# セッション管理における 2 つのレイヤ

- 巷では、クッキーか JWT か、などの議論が行われる
- しかし、その議論は 対立軸を誤っている
- セッション管理には 2 つのレイヤが存在する
  - トークン文字列がどのような形式か
  - トークン文字列をどこに保存し どのように取り出して送信するか
- この 2 つのレイヤを分けて考えることが重要
- 1. トークン形式

  - A. handle 型トークン
    - API 側のデータベースに セッション情報を保存し
    - トークン文字列は そのセッション情報を一意に指し示す ID のみ
    - API 側は トークン文字列を受け取ると
    - データベースを参照し セッション情報を取得する
      - 例: セッション ID、ランダム文字列トークン
    - ただ一意に指し示すだけであるため
      - トークン文字列自体は 十分にランダムに生成された 文字列であることが好ましい
    - 利点
      - API 側 で セッション情報を管理できるため、セッションの失効が可能
      - API 側 で セッション情報を管理できるため、セッション情報が古くならない
    - 欠点
      - API 側 で セッション情報を管理するため、情報を保存するインフラコストが発生する
      - API 側 で セッション情報を管理するため、スケーラビリティが低下する可能性がある
      - API 側 で セッション情報を管理するため、トークンの情報取得に DB アクセスが発生し レイテンシが増加する
  - B. assertion 型トークン
    - トークン文字列自体に セッション情報を含む
    - API 側は トークン文字列を受け取ると
    - トークン文字列を解析し セッション情報を取得する
      - 例: JWT
    - トークン文字列自体に セッション情報を含むため、トークン文字列は 長く 複雑になる
    - ほとんどの場合、暗号化や署名が施される
    - 利点
      - API 側 で セッション情報を管理しないため、インフラコストが発生しない
      - API 側 で セッション情報を管理しないため、スケーラビリティが向上する
      - API 側 で セッション情報を管理しないため、トークンの情報取得に DB アクセスが発生せず レイテンシが低減する
    - 欠点
      - API 側 で セッション情報を管理しないため、セッションの失効が困難
      - API 側 で セッション情報を管理しないため、セッション情報が古くなる可能性がある
        - これらの欠点の解消も不可能ではないが、
        - 結局これらの欠点を解消しようとすると DB アクセスが必要となり
        - handle 型 トークン の性質と似通ってしまう
  - 一般的には以上のとおりだが
  - 2 つのトークンを組み合わせて利用することで、お互いの欠点を補うことも可能
  - C. 短命 assertion 型トークン + 長命 handle 型トークン
    - assertion 型トークンを 短命に設定し
    - 長命の handle 型トークンで assertion 型トークンを再発行する
    - 同時に 新しい 長命 handle 型トークンを発行し、古いものを無効化する
    - このように設計することで、assertion 型と handle 型の利点を組み合わせることが可能
      - assertion 型 トークンの欠点:
        - セッションの失効が困難
          - assertion 型トークンを 短命に設定することで
          - 短命 assertion 型 トークンが 盗まれた場合でも 短期間で無効化され 悪用が困難
          - また 長命 handle 型トークンは 失効可能であるため
          - 長命 handle 型トークンが 盗まれた場合でも
          - API 側で 失効させることで セッションを無効化可能
      - handle 型 トークンの欠点:
        - インフラコストが発生・スケーラビリティが低下・レイテンシが増加
          - セッションとしては 頻繁にアクセスする 短命 assertion 型トークンを利用することで
          - 普段のアクセスにおける DB アクセスを低減し インフラコストを抑制・スケーラビリティを向上・レイテンシを低減
          - 長命 handle 型トークンは 短命 assertion 型トークンの再発行時にのみ利用されるため
          - 頻繁にアクセスされることがなく インフラコストを抑制可能

- 2. トークン保存場所・送信方法

  - α. httpOnly クッキー に保存し ブラウザが自動送信
    - ブラウザの提供するクッキー機能を利用
    - httpOnly 属性を付与することで JavaScript からのアクセスを防止
    - API へのリクエスト時に ブラウザが自動的にクッキーを送信
    - 古き良き セッション管理手法 といえる
    - 利点
      - 攻撃者によって ブラウザに 悪意のある JavaScript コードが送り込まれた場合でも
        - JavaScript から クッキーにアクセスできないため
        - セッション情報そのものが盗まれるリスクを低減できる
          - 捕捉: ただし 悪意ある JavaScript から
          - クッキーを付けて API にアクセスすることは可能なことに注意
          - あくまでも 永続的に セッション情報が盗まれるリスクを低減できる、という意味であり
          - 悪意ある JavaScript が ブラウザで動作している間は セッションが乗っ取られるリスクがあることに注意
          - httponly が付いていても 被害が拡大する例:
            - パスワード変更 API を呼び出し パスワードを変更される
          - このような アカウントアクセス拡大に繋がる API 呼び出しは、
          - 事前に パスワード再認証を要求するなどの 対策が必要
    - 欠点
      - しっかり CSRF 対策を行う必要がある
        - CSRF は 設定を誤らなければ 防げる攻撃であるため
        - 十分に注意して対策を行うこと
        - SPA + API の場合の CSRF 対策については、別記事で解説予定
    - クッキーの属性
      - 前提条件より
        - SameSite: None
        - Secure: true
        - HttpOnly: true
  - β. ブラウザの提供するストレージやメモリに保存し JavaScript でその都度 取り出して 送信
    - JavaScript を用いて ストレージやメモリに トークン文字列を保存し
    - API へのリクエスト時に JavaScript で トークン文字列を取り出し
    - API リクエストヘッダなどに トークン文字列を付与して 送信
    - 近年の SPA で よく利用される手法
    - トークンは以下のような場所に保存
      - ストレージ
        - localStorage
        - sessionStorage
        - IndexedDB
      - メモリ
        - React の state
        - JavaScript の変数
    - 利点
      - CSRF 対策が不要
        - JavaScript で API リクエストヘッダなどに トークン文字列を付与して 送信するため
        - 悪意ある第三者の オリジンからの リクエストでは トークン文字列を付与できない
        - そのため CSRF 攻撃を防げる
    - 欠点
      - 攻撃者によって ブラウザに 悪意のある JavaScript コードが送り込まれた場合
        - その JavaScript から ストレージやメモリに保存された トークン文字列にアクセスできるため
        - 永続的に セッション情報が盗まれるリスクがある
        - この手法では トークン文字列の保存・取り出しを JavaScript が担うため
        - 悪意ある JavaScript の実行による トークン奪取問題を 根本的に防ぐことはできない
        - そのため、対処療法ではあるが
        - 悪意ある JavaScript の実行を防ぐ対策が重要
  - 非推奨: httponly でないクッキー
    - クッキーの利点が活かせない上に
    - JavaScript からアクセス可能であるため β の手法と同様の欠点を持つ
    - そのため、今回はこれを最初から非推奨とする

## セッション管理の安全性ランキング

- 上記の 2 つのレイヤを組み合わせた場合の 安全性 Tier 表
- なお、簡単に比較できないものも存在する
  - ハッセ図 という概念を利用し、安全性の高低を表現
  - 高低差を 単純に比較できないものは、枝分かれで表現する
- また CSRF 脅威 は 適切に対策すれば 問題ないものとする
  - そのため ランキングにおいて CSRF 脅威は考慮していない
  - ただし CSRF 脅威に対して 適切に対策を行う必要があることは 念のため 付記しておく
  - 前述のとおり、CSRF対策については別記事で解説予定
- 1 位: A on α
  - handle 型トークン on httpOnly クッキー
  - API 側で セッション情報を管理し 失効可能
  - JavaScript からのアクセスを防止可能
  - 昔ながらの 安全なセッション管理手法
    - 昔は サーバが一台のことも多く
    - バックエンドサーバ による スケーラビリティの問題が今より少なかったため
    - この手法で何ら問題はなく、一般的な構成であった
  - メリット:
    - セッションの失効が可能
      - 永続的なトークン奪取リスクを低減
  - デメリット:
    - インフラコストが発生
    - スケーラビリティが低下
    - レイテンシが増加
    - CSRF 対策が必要(適切に対策すれば問題なし)
  - 具体的なライブラリ
    - Express.js: express-session
      - https://github.com/expressjs/session
      - DB を抽象化した ストア という概念を持ち サーバ側に セッション情報を保存可能
      - 様々な DB 用の ストア実装が存在
      - httpOnly 属性付きクッキーに handle 型トークンを保存
    - Spring Boot: Spring Session
      - https://spring.pleiades.io/spring-session/reference/guides/boot-redis.html
      - Redis などの DB に セッション情報を保存可能
      - httpOnly 属性付きクッキーに handle 型トークンを保存
    - Auth.js: Database Session
      - https://authjs.dev/concepts/session-strategies#database-session
      - HttpOnly クッキーに handle 型トークンを保存
      - 対応する DB に セッション情報を保存可能
        - https://authjs.dev/getting-started/database
- 2 位: C on α
  - 短命 assertion 型トークン + 長命 handle 型トークン on httponly クッキー
  - API 側で セッション情報を管理し 長命側は失効可能
  - 比較的安全なセッション管理手法
  - メリット:
    - 長命側トークンであれば失効が可能
      - 永続的なトークン奪取リスクを低減
    - 普段のアクセスにおける DB アクセスを低減し
      - インフラコストを抑制
      - スケーラビリティを向上
      - レイテンシを低減
  - デメリット:
    - 短命側トークンが 盗まれた場合のリスクは残る
      - ただし 短命であるため リスクは できるだけ低減
    - CSRF 対策が必要(適切に対策すれば問題なし)
  - 具体的なライブラリ
    - SuperTokens
      - https://supertokens.com/docs/references/how-supertokens-works
      - 内部的に 短命 assertion 型トークン + 長命 handle 型トークン の組み合わせを利用
        - 短命 assertion 型トークン = アクセストークン (JWT)
        - 長命 handle 型トークン = リフレッシュトークン (ランダム文字列)
      - 双方ともに HttpOnly 属性付きクッキーに保存
        - 長命側トークンで 短命側トークンを再発行し
        - 同時に 新しい 長命側トークンを発行し 古いものを無効化する
      - SuperTokens は 外部サーバ として動作するが
        - SPA と直接通信はせず API サーバのみと通信する
        - API サーバは トークンの発行・検証を SuperTokens サーバに委託する形
        - とはいえ SPA から見れば API サーバが セッション管理を行っているのと変わらない
  - 問題点: この形を実装するフレームワークが ほとんどない
    - かろうじて supertokens が 対応している程度
      - 筆者の意見では この形が 最もバランスの良いセッション管理手法であると考えるが
      - 現状で対応しているフレームワークは ほとんどない
    - 自前で対応しようとすると独自実装となり コストが高い
    - また セキュリティにおける独自実装は、それ自体が セキュリティリスクを招く可能性があるため 注意が必要
- 3 位: B on α
  - assertion 型トークン on httpOnly クッキー
  - JavaScript からのアクセスを防止可能
  - モダンな API フレームワーク でセッション管理のミドルウェアを利用すると この形になることが多い
  - メリット:
    - JavaScript からのアクセスを防止可能
      - 永続的なトークン奪取リスクを低減
  - デメリット:
    - API 側で セッション情報を管理しないため 失効が困難
      - 永続的なトークン奪取リスクが残る
    - CSRF 対策が必要(適切に対策すれば問題なし)
  - 具体的なライブラリ
    - Hono: hono/session
      - https://github.com/honojs/middleware/tree/main/packages/session
      - 内部的に JWE 形式の assertion 型トークンを保存
      - デフォルトで HttpOnly 属性付きクッキーに保存
    - Auth.js: JWT Session
      - https://authjs.dev/concepts/session-strategies#jwt-session
      - HttpOnly クッキーに assertion 型トークンを保存
- 4 位: C on β
  - 短命 assertion 型トークン + 長命 handle 型トークン on ブラウザストレージやメモリ
  - API 側で セッション情報を管理し 長命側は失効可能
  - Auth0 などの 外部認可サーバを用いた SPA + API のセッション管理で よく利用される手法
  - 以下のような対応
    - 短命 assertion 型トークン = アクセストークン (JWT)
    - 長命 handle 型トークン = リフレッシュトークン (ランダム文字列)
    - トークンはそれぞれ メモリに保存されるが 指定が可能
    - 緩和策: Web Worker のメモリへの保存
      - リフレッシュトークンは Web Worker のメモリ内に保存されるため 悪意ある JavaScript からのアクセスが比較的困難
  - トークン自体の発行は API サーバではなく 外部の Auth0 サーバが担当する
    - SPA が Auth0 サーバと 直接やり取りし
    - アクセストークン・リフレッシュトークンを受け取り メモリに保存する
    - その後 SPA が API サーバに アクセストークンを付与して リクエストを送信
    - API サーバが アクセストークンを受け取り それを検証する
    - 検証の手順を間違えると 脆弱性を招くリスクがあるため 注意が必要
  - メリット:
    - 長命側トークンであれば失効が可能
      - 永続的なトークン奪取リスクを低減
    - 短命側トークンが 盗まれた場合のリスクは残る
      - ただし 短命であるため リスクは できるだけ低減
    - 双方ともに CSRF 対策が不要
  - デメリット:
    - 短命側トークン 及び 長命側トークンが JavaScript からアクセス可能であるため
      - 永続的なトークン奪取リスクが残る
      - 特に 長命側トークンは 永続的に奪取されるリスクが高い
    - 悪意ある JavaScript の実行を防ぐ対策が重要
  - 具体的なライブラリ
    - Auth0 SDK: auth0-spa-js (リフレッシュトークン利用)
      - https://authjs.dev/concepts/session-strategies#jwt-session
      - `useRefreshTokens: true` オプションを指定することで対応可能
      - 以下のような対応
        - 短命 assertion 型トークン = アクセストークン (JWT)
        - 長命 handle 型トークン = リフレッシュトークン (ランダム文字列)
        - トークンはそれぞれ メモリに保存されるが 指定が可能
        - リフレッシュトークン奪取への緩和策
          - この方式では リフレッシュトークンを奪取されると 永続的にアクセスされるリスクが高い
          - そのため 緩和策として Web Worker のメモリへの保存が利用される
          - リフレッシュトークンは Web Worker のメモリ内に保存され 悪意ある JavaScript からのアクセスが比較的困難
      - トークン自体の発行は API サーバではなく 外部の Auth0 サーバが担当する
        - SPA が Auth0 サーバと 直接やり取りし
        - アクセストークン・リフレッシュトークンを受け取り メモリに保存する
        - その後 SPA が API サーバに アクセストークンを付与して リクエストを送信
        - API サーバが アクセストークンを受け取り それを検証する
        - 検証の手順を間違えると 脆弱性を招くリスクがあるため 注意が必要
  - 余談: OAuth との関連性と注意点
    - この手法は、API サーバ単体というよりも
      - Auth0 などの 外部認可サーバを用いた SPA + API のセッション管理で よく利用される手法
      - この実装において OAuth のアクセストークン・リフレッシュトークンが流用されるケースが非常に多い
    - OAuth は 仕様上 アクセストークン・リフレッシュトークンを発行する
      - access token は 短命 assertion 型トークンに該当
      - refresh token は 長命 handle 型トークンに該当
      - このアクセストークンをセッショントークンとして流用しているイメージ
    - OAuth のアクセストークン・リフレッシュトークンを セッション管理に流用すると、
      - 自然と C on β/α の形にたどり着く
    - しかし、筆者の意見では OAuth のアクセストークンをセッションに流用するのは推奨しない
      - OAuth のアクセストークンは 本来 リソースサーバーへのアクセス権を示すものであり
      - セッション管理のために設計されていないため
      - セッション管理の要件を満たさないと考える
    - また、検証を怠ると 脆弱性を招くリスクもある
    - 詳しくは 以前の記事を参照
      - 【OAuth】アクセストークンの検証を誤ると成りすまし攻撃ができます
      - https://zenn.dev/calloc134/articles/oauth-cross-api-vuln-attack
- 同率 4 位: B on β
  - assertion 型トークン on ブラウザストレージやメモリ
  - SPA で よく利用される手法だが 安全性は低い
  - メリット:
    - CSRF 対策が不要
  - デメリット:
    - API 側で セッション情報を管理しないため 失効が困難
      - 永続的なトークン奪取リスクが残る
    - トークン文字列が JavaScript からアクセス可能であるため
      - 永続的なトークン奪取リスクが残る
    - 悪意ある JavaScript の実行を防ぐ対策が重要
  - 具体的なライブラリ
    - Auth0 SDK: auth0-spa-js (リフレッシュトークン不使用)
    - https://authjs.dev/concepts/session-strategies#jwt-session
    - `useRefreshTokens: false` (デフォルト) オプションを指定することで対応可能
      - assertion 型トークン = アクセストークン (JWT)
      - リフレッシュトークンが 存在しないこと以外は C on β と同じ
  - 余談: B on β と C on β の安全性比較
    - B on β の場合、assertion 型トークン しか存在しないため トークンを奪取されると永続的にアクセスされる
    - ただし C on β も 長命 handle 型 トークンが 奪取された場合は 同等のリスク
    - どちらの手法も β であるため、
      - どのみち 悪意ある JavaScript による トークン奪取による 永続的アクセスのリスクが存在する
      - assertion 型 トークンの有効期限に左右されるため 一概に比較できない
      - そのため 同率とした
      - B on β において assertion 型トークンを 短命に設定している場合、
        - C on β よりも安全といえる可能性もある
      - 逆に Web Worker による長命 handle 型 トークン奪取の緩和策を用いている場合は
        - C on β の方が 安全といえる可能性もある
- 非推奨: B on non-httponly cookie
  - assertion 型トークン on httponly でないクッキー
  - JavaScript からアクセス可能であるため β の手法と同様の欠点を持つ
  - 更に CSRF 対策も必要となるため これを採用するメリットはほとんどない
  - α を利用する場合も同様

## 安全性 ランキング考察

- 先程のランキングの強さを比較する
  - 1 位 → 2 位:
    - handle 型トークン on httpOnly クッキー から
    - 短命 assertion 型トークン + 長命 handle 型トークン on httpOnly クッキー へ
    - 増えた欠点: assertion 型トークンが 盗まれた場合のリスク (低)
      - 短命 assertion 型トークンが 盗まれた場合、
      - assertion 型トークンは API 側で 失効させることができず、永続的アクセスのリスクがある という欠点が増える
      - ただし、短命であるため リスクは 低い
  - 2 位 → 3 位:
    - 短命 assertion 型トークン + 長命 handle 型トークン on httpOnly クッキー から
    - assertion 型トークン on httpOnly クッキー へ
    - 増えた欠点: assertion 型トークンが 盗まれた場合のリスク (高)
      - assertion 型トークンが 盗まれた場合、
      - assertion 型トークンは API 側で 失効させることができず、永続的アクセスのリスクがある という欠点が増える
      - またこの場合、assertion 型トークンは 長命であることが多いため リスクが高い
  - 2 位 → 4 位:
    - 短命 assertion 型トークン + 長命 handle 型トークン on httpOnly クッキー から
    - 短命 assertion 型トークン + 長命 handle 型トークン on ブラウザストレージやメモリ へ
    - 増えた欠点: トークン文字列が JavaScript からアクセス可能であること
      - 悪性 JavaScript が ブラウザに送り込まれた場合、
        - JavaScript から トークン文字列にアクセスできるため
        - 永続的に セッション情報が盗まれるリスクがある という欠点が増える
      - 長命 handle 型トークンが 盗まれた場合のリスク自体は 2 位と 変わらない
  - 3 位 → 4 位(2):
    - assertion 型トークン on httpOnly クッキー から
    - assertion 型トークン on ブラウザストレージやメモリ へ
    - 増えた欠点: トークン文字列が JavaScript からアクセス可能であること
      - 悪性 JavaScript が ブラウザに送り込まれた場合、
        - JavaScript から トークン文字列にアクセスできるため
        - 永続的に セッション情報が盗まれるリスクがある という欠点が増える
    - assertion 型 トークン奪取による 永続的アクセスのリスク自体は 3 位と 変わらない
  - 4 位 → 非推奨:
    - assertion 型トークン on ブラウザストレージやメモリ から
    - assertion 型トークン on httponly でないクッキー へ
    - 増えた欠点: CSRF 対策が必要となること
      - CSRF 対策が不要である という利点が失われる という欠点が増える
- これを図に表すと 以下のハッセ図のようになる
  - 安全性の高いものほど 上位に位置し
  - 単純に比較できないものは 枝分かれで表現
  - (ここに図を記述)