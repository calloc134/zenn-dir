
# 忙しい人向けの結論

hono を利用するベースで解説

- `hono/cors` で正しく CORSポリシーを設定する
  - ブラウザの 同一オリジンポリシー(SOP) による防御機構を有効にする
- `hono/csrf` ミドルウェアを利用して Originヘッダ検証を行う
  - simple request と認識されるリクエストに対して耐性がある
- クッキーの SameSite属性を適切に設定する
  - 完全同一ドメイン・サブドメインの場合: SameSite=Lax
  - 完全別ドメインの場合: SameSite=None + Secure 属性
  - CSRFとは関係ないが、以下の属性は必ず設定すること
    - HttpOnly 属性
    - Secure 属性
- データを変更するAPI (副作用あり) と データを取得するAPI (副作用なし) で メソッドを分離する
  - データを変更するAPI (副作用あり): unsafe method (POST, PUT, PATCH, DELETE)
  - データを取得するAPI (副作用なし): safe method (GET, HEAD, OPTIONS, TRACE)
- 以上に気をつけて実装すれば CSRFは基本的に防御できる

# 前提知識

- CSRF攻撃・クロスサイト読み取り攻撃 に関する前提知識は非常に多岐に渡る
  - 前提知識をここで整理する
- CSRF攻撃とは
  - クロスサイトリクエストフォージェリ (Cross-Site Request Forgery) の略
  - 攻撃者が攻撃用サイトを用意し
  - 被害者がその攻撃用サイトにアクセスした際に
  - 被害者のブラウザが正規サイトに対して意図しないリクエストを送信させ
  - 結果として 被害者の認証情報で 不正な状態変更操作が行われる攻撃手法
  - 今回は、正規APIに対して意図しないリクエストを送信させるケースを想定する
  - 認証情報が自動で付与される場合に攻撃が成立する
    - 例: クッキーを用いたセッション管理が行われている場合 クッキーはブラウザによって自動で付与される認証情報なので
- クロスサイト読み取り攻撃
  - 重要: クロスサイト読み取り攻撃攻撃が発生する前提で記述しているが、
    - 実際は後述の同一オリジンポリシー (SOP) の仕組み上 多くの場合で防止される
  - 攻撃者が攻撃用のサイトを用意し
  - 被害者がその攻撃用サイトにアクセスした際に
  - 被害者のブラウザが正規サイトに対してリクエストを送信し
  - 攻撃用サイトで そのレスポンス内容を取得することで
  - 結果として 被害者の認証情報で 正規サイトの情報が攻撃者に漏洩する攻撃手法
  - 今回は、正規APIに対してリクエストを送信し
  - そのレスポンス内容を攻撃者に漏洩させるケースを想定する
  - これも 認証情報が自動で付与される場合に攻撃が成立する
    - 例: クッキーを用いたセッション管理が行われている場合
  - 余談: XS-Leak とは区別する
    - 同一オリジンポリシー(SOP) によってデータ読み取りが防止される場合でも
    - レスポンスの有無やレスポンス時間などの副次的情報を利用して
    - 間接的に情報を漏洩させる攻撃手法
    - 今回は XS-Leak は考慮しない
- HTTP メソッドの使い分け
  - unsafe method
    - POST, PUT, PATCH, DELETE
    - このメソッドで呼び出されるAPIは
    - データベースの更新など 副作用が発生する操作を行うものと期待される
    - 予測される脅威: CSRF攻撃
  - safe method
    - GET, HEAD, OPTIONS, TRACE
    - このメソッドで呼び出されるAPIは
    - データの取得など 副作用が発生しない操作を行うものと期待される
    - 予測される脅威: クロスサイト読み取り攻撃
  - APIで行う処理に応じて 適切なメソッドを選択することが重要
    - 詳細は後述
- オリジンとは
  - スキーム + ホスト + ポート(省略された場合はスキームから導出) の組み合わせ
  - 例:
    - https://example.com と https://example.com は同一オリジン
    - https://example.com と https://api.example.com は別オリジン
    - https://example.com と https://example.org は別オリジン
- サイトとは
  - スキーム + registrable ドメイン の組み合わせ
    - registrable ドメインとは
      - 第三者が自由に登録できるサフィックス (public suffix) と その一つ左側のラベルを組み合わせたもの
      - 一つ左側 であることが重要
      - 例:
        - A: public suffix が ICANN ドメイン
          - トップレベルドメイン (TLD) であり、レジストラが管理するドメイン
          - (ラベル).com
          - (ラベル).co.uk
        - B: public suffix が 非ICANN ドメイン (PRIVATE ドメイン)
          - TLDではないが、単一サービスが利用者にサブドメインを提供するドメイン
          - (ラベル).github.io
          - (ラベル).workers.dev
  - 例:
    - https://example.com と https://api.example.com は同一サイト
    - https://example.com と https://example.org は別サイト
    - https://app1.user1.workers.dev と https://app2.user1.workers.dev は同一サイト
      - 一つ左側のラベルが同じであるため
    - https://app.user1.workers.dev と https://app.user2.workers.dev は別サイト
      - 一つ左側のラベルが異なるため
- 同一オリジンポリシー(SOP) ・ CORSポリシーとは
  - クロスオリジンリクエストにおける ブラウザの挙動を制御する仕組み
  - ブラウザには 同一オリジンポリシー (SOP) というポリシーが存在する
    - 別オリジンのリソースにアクセスすることを制限する
  - クロスオリジンリクエストを行った場合の 同一オリジンポリシーの挙動は以下の通り
    - unsafe methodの場合
      - リクエストの送信自体の可否 を制御する
      - APIが呼び出された際に副作用が発生する可能性があるため
      - リクエストの送信自体を制御・制限し CSRF攻撃を防止する
      - 注意点
        - unsafe method の場合でも 特定の条件(トップレベル遷移)を満たす場合、safe method と同じ挙動となることがある
        - 条件は後述
    - safe methodの場合
      - レスポンスの閲覧可否 を制御・制限する
      - APIが呼び出された際に副作用が発生しないため、
      - リクエストの送信自体は許可するが
      - レスポンスの閲覧可否を制御・制限し クロスサイト読み取り攻撃を防止する
  - CORS ポリシーは このSOPを緩和するための仕組みである
    - `Access-Control-*` ヘッダを用いて
    - リクエスト先のオリジンが許可リストに含まれている場合に限り
    - リクエスト送信・レスポンス閲覧を例外的に許可する
  - 主なヘッダ
    - Access-Control-Allow-Origin
      - クロスオリジンのリクエスト送信・レスポンス閲覧を 許可するオリジンを指定する
      - ワイルドカード `*` も指定可能だが 後述の制約がある
    - Access-Control-Allow-Credentials
      - クロスオリジンのリクエストにおいて
      - クレデンシャル (Cookie, Authorization ヘッダなど) を含めることを許可するかを指定する
      - 含める場合は `true` を指定する
      - 含めない場合はヘッダ自体を省略する
      - Access-Control-Allow-Origin に ワイルドカード `*` を指定している場合は
      - このヘッダを `true` に設定できないという制約がある
      - これにより CORSポリシーの設定ミスによる CSRF攻撃・クロスサイト読み取り攻撃を防止できる
  - CORS ポリシーが有効な場合の挙動
    - unsafe method かつ 後述の条件を満たさないリクエストの場合
      - 1. ブラウザの JavaScriptが fetch APIを用いて unsafe method のリクエストを送信しようとする
      - 2. ブラウザが CORS ポリシーを確認するためのリクエストを送信
        - プリフライトリクエストと呼ばれるもの
        - OPTIONS メソッド
      - 3. サーバーがCORSポリシーを含むレスポンスを返す
      - 4. ブラウザがレスポンスを確認し CORSポリシーに従って送信可否をチェック
        - `Access-Control-Allow-Origin` ヘッダ等を確認
      - 5. 送信が許可されていれば 本リクエストを送信
        - 許可されていなければ 送信をブロックし その時点で fetch API がエラーを返す
        - これにより リクエストの送信自体を制御・制限し CSRF攻撃を防止できる
    - safe method の場合
      - 1. JavaScriptが fetch APIを用いて safe method のリクエストを送信しようとする
      - 2. ブラウザがリクエストを送信
        - リクエストの送信自体は制限されないことに注意
      - 3. サーバーがCORSポリシーを含むレスポンスを返す
      - 4. ブラウザがレスポンスを確認し CORSポリシーに従って閲覧可否をチェック
        - `Access-Control-Allow-Origin` ヘッダ等を確認
      - 5. 閲覧が許可されていれば レスポンスがJavaScriptに渡される
        - 許可されていなければ レスポンスがJavaScriptに渡されず その時点で fetch API がエラーを返す
        - これにより レスポンスの閲覧可否を制御・制限し クロスサイト読み取り攻撃を防止できる
      - 余談: 副作用の発生するAPIが safe method で実装されている場合
        - 挙動の流れを見るとわかるように
        - CORSポリシーは レスポンスの閲覧可否のみを制御・制限するため
        - API へのアクセス自体は防止されない
        - したがって CSRF攻撃が成立してしまう可能性がある
    - unsafe method であっても特定の条件を満たす場合 (例外)
      - 以下の条件を満たす場合は safe method と同じ挙動になる
        - POST メソッドである
        - リクエストヘッダが 以下のもの のみで構成されている
          - Accept
          - Accept-Language
          - Content-Language
          - Content-Type (ただし 以下のいずれかの値に限る)
            - application/x-www-form-urlencoded
            - multipart/form-data
            - text/plain
      - この場合のリクエストを simple request と呼ぶ
      - 送信の流れは safe method と同じ
      - この仕組みは ブラウザが互換性のために備えているレガシーな仕組みであり
      - セキュリティ上の観点からは望ましくない
      - もちろん CSRF攻撃に悪用されるリスクがある
      - したがって 開発者は
      - 要件に不要な場合は これらの条件に該当するリクエストを APIで受け入れないようにすることが望ましい
- SameSite 属性とは
  - クッキーの属性の一つであり
  - クロスサイトリクエストにおけるクッキーの送信挙動を制御する
  - 主な設定値
    - Strict
      - クロスサイトリクエストではクッキーを送信しない
    - Lax
      - 一部のクロスサイトリクエストでのみクッキーを送信する
        - safe method (GET, HEAD, OPTIONS, TRACE) かつ 特定の条件に当てはまる場合はクッキーを送信する
          - 今回想定するクロスサイト読み取り攻撃は fetch apiを用いたリクエスト送信を想定しているため
          - 先程の条件に当てはまらない
          - したがって クロスサイトリクエストによるクッキー送信は考える必要がない
      - SameSite 属性を設定しない場合のデフォルト値になるが、
        - 明示的に指定した場合と比べて挙動が異なる場合があるので注意
        - 今回は SameSite属性を設定しない場合を考えず 明示的に Lax を設定した場合を想定する
    - None
      - クロスサイトリクエストでもクッキーを送信する
      - Noneを設定する場合 Secure 属性も設定する必要がある

# 想定する状況

想定する状況について、

- 完全同一ドメイン
  - app.example.com と app.example.com
  - 同一オリジン
  - 同一サイト
- サブドメイン
  - api.example.com と app.example.com
  - 別オリジン
  - 同一サイト
- 完全別ドメイン
  - api.example.org と app.example.com
  - 別オリジン
  - 別サイト
- の 3パターンについて考える

# 想定するケースの前提

- CSRF攻撃・クロスサイト読み取り攻撃の防御機構を正常に作用させるため
- 開発者は前提として 以下の設計を守るものとする
- API のセッション管理は httponly クッキーを利用する
  - クッキーが存在していないとAPI呼び出しが行えないものとする
  - fetch apiにおいて credentials: includeを設定した呼び出しを想定する
- データを変更するAPI (副作用あり) と データを取得するAPI (副作用なし) で メソッドを分離する
  - API 設計の段階で考慮する
  - メソッド分離の重要性は前述の通り
  - データを変更するAPI (副作用あり)
    - unsafe method を用いる
      - POST, PUT, PATCH, DELETE
  - データを取得するAPI (副作用なし)
    - safe method を用いる
      - GET, HEAD, OPTIONS, TRACE
- クッキーのSameSite属性について
  - 完全同一ドメイン・サブドメインの場合
    - SameSite=Lax を設定する
  - 完全別ドメインの場合
    - SameSite=None を設定し Secure 属性も設定する

# 根本的解決は Originヘッダ検証

- CSRF攻撃の防御の一番根本的解決はOriginヘッダ検証
- Originヘッダを検証していれば
  - 完全同一ドメイン・サブドメイン・完全別ドメイン のいずれの場合でも
  - CSRF攻撃を防御できる
  - なお、CSRF攻撃とは 主に unsafe method が前提となる攻撃なので
  - 以後のヘッダ検証対策は unsafe method (POST, PUT, PATCH, DELETE) の場合を想定する
  - 逆に safe method (GET, HEAD, OPTIONS, TRACE) の場合は これらの検証を省略しても問題ない
- Origin ヘッダ検証の流れ
  - Originヘッダの値が 予期されるオリジンと一致するかを確認
    - 一致すれば許可
    - 一致しなければ拒否
- しかし今回は
  - Originヘッダ検証を怠った場合
  - つまりOriginヘッダ検証のない場合において、
  - CookieのSameSite属性や CORSポリシーによる CSRF攻撃の副次的防御の影響について考察することを目的とする
- 余談: Sec-Fetch-Site ヘッダ検証について
  - 最近のブラウザでは Sec-Fetch-Site ヘッダが送信される
  - Origin ヘッダ検証の補助として Sec-Fetch-Site ヘッダ検証を利用することで
  - Origin ヘッダ検証よりもパフォーマンスの良い CSRF防御を実現できる可能性がある
  - Sec-Fetch-Site ヘッダを検証するときは以下のような実装となる
    - 1. もし Sec-Fetch-Siteヘッダが存在するのであれば
      - 前提: Sec-Fetch-Site ヘッダの値が `none` の場合は一括で拒否
      - その場合 Sec-Fetch-Site ヘッダの値は以下の3種類となる
        - `same-origin`
        - `same-site`
        - `cross-site`
      - a. 完全同一ドメインの場合
        - 正規のリクエスト: `same-origin`
        - Sec-Fetch-Site ヘッダの値が `same-origin` であれば許可
        - Sec-Fetch-Site ヘッダの値が `same-site` または `cross-site` であれば CSRF攻撃の可能性が高いので拒否
      - b. サブドメインの場合
        - 正規のリクエスト: `same-site`
        - Sec-Fetch-Site ヘッダの値が `same-origin` または `same-site` であれば より厳密な検証が必要なので Originヘッダ検証に移行
        - Sec-Fetch-Site ヘッダの値が `cross-site` であればCSRF攻撃の可能性が高いので拒否
      - c. 完全別ドメインの場合
        - 正規のリクエスト: `cross-site`
        - Sec-Fetch-Site ヘッダ検証は基本的に効力がないため すべての場合で Originヘッダ検証に移行
    - 2. Sec-Fetch-Siteヘッダが存在しない場合
      - 古いブラウザ等では送信されないことがあるためフォールバック処理が必要
      - Originヘッダ検証にフォールバック
  - Sec-Fetch-Site ヘッダ検証を行っていても、Origin ヘッダ検証との併用が前提となる
    - Sec-Fetch-Site ヘッダはブラウザによって送信されない場合があるため
    - また `same-site` や `cross-site` の場合は より厳密な検証が必要となるため

# Origin ヘッダ検証を怠った場合の CSRF攻撃の成立可否

横軸→被害者に踏ませるための攻撃者のページ
縦軸→本来の通信元である正規のSPAページ

また、
適切な SameSite属性を設定した際の クッキーの送信挙動によるCSRF耐性 → A
適切な CORSポリシーを設定した際の 同一オリジンポリシー(SOP) によるCSRF耐性 → B

とする。

## α. 攻撃者ページからの fetch apiを用いた unsafe methodによるCSRF攻撃

攻撃に成功したとされる条件は以下の通り

- 攻撃者ページからの fetch apiを用いた unsafe method によるリクエスト送信が成功すること
  - 送信自体がブロックされないこと

それぞれの条件において、CSRF攻撃を防御する防御機構が働くかを以下の表に示す。

| ＼ | サブドメイン(ただし本家とは別のサブドメインとする) | 完全別ドメイン |
| 完全同一ドメイン SameSite=Lax | B | A,B |
| サブドメイン SameSite=Lax Access-Control-Allow-Credentials有 | B | A, B |
| 完全別ドメイン SameSite=none Access-Control-Allow-Credentials有 | B | B |

- この表のように
  - すべての例において 同一オリジンポリシー(SOP) による防御機構 (CORSポリシー) が働くことがわかる
  - また 本来の通信元である正規のSPAページが完全同一ドメイン・サブドメインであり、かつ 攻撃者ページが完全別ドメインである場合には
    - クッキーのSameSite属性による防御機構も働くことがわかる
  - したがって Originヘッダ検証を怠った場合でも
    - CSRF攻撃は成立しないことがわかる

## β. text/plain等の simple requestと認識されるコンテンツタイプを用いた POSTでJSONデータを無理やり送信させるタイプの CSRF攻撃

攻撃に成功したとされる条件は以下の通り

- 攻撃者ページからの fetch api もしくは フォーム送信を用いた POST によるリクエスト送信が成功すること
  - 送信自体がブロックされないこと

それぞれの条件において、CSRF攻撃を防御する防御機構が働くかを以下の表に示す。

| ＼ | サブドメイン(ただし本家とは別のサブドメインとする) | 完全別ドメイン |
| 完全同一ドメイン SameSite=Lax | なし | A |
| サブドメイン SameSite=Lax Access-Control-Allow-Credentials有 | なし | A |
| 完全別ドメイン SameSite=none Access-Control-Allow-Credentials有 | なし | なし |

- この表のように
  - 「なし」と示されている部分では、CSRF攻撃を防御する防御機構が働かないことがわかる
  - したがって CSRF攻撃に脆弱である
  - なお、本来の通信元である正規のSPAページが完全同一ドメイン・サブドメインであり、かつ 攻撃者ページが完全別ドメインである場合には
    - クッキーのSameSite属性による防御機構が働くことがわかる
    - したがって CSRF攻撃は成立しないことがわかる
- この攻撃方法の一番の特徴
  - JSON データのみを受け付けるべきである API に対して
  - simple request の範疇に収まる条件のリクエストを送信できてしまう点が問題
  - したがって、以下の条件に該当するものは そもそもAPIで受け入れないことが望ましい
    - POST メソッドである
    - リクエストヘッダが 以下のもの のみで構成されている
      - Accept
      - Accept-Language
      - Content-Language
      - Content-Type (ただし 以下のいずれかの値に限る)
        - application/x-www-form-urlencoded
        - multipart/form-data
        - text/plain
  - 前述の通り 開発者は
    - API の要件に不要な場合は
    - simple requestと認識されるリクエストを APIで受け入れないようにすることが望ましい
  - API フレームワークの実装によっては
    - JSON を受け取る際に 本当にコンテンツタイプが application/json であるかを検証するものもある
    - しかし、そのような実装になっていない場合も多い
    - 例: Hono の `c.req.json()` メソッドはコンテンツタイプを検証しない
      - パフォーマンス低下するから、という理由だろうか？
    - 開発者がしっかり自衛を行うことが大事
  - ただし、Hono の場合は `hono/csrf` ミドルウェアを提供している
    - simple request と認識されるリクエストに対して
    - `Origin` ヘッダ検証 (+ Sec-Fetch-Site ヘッダ検証)を行うことで 実質的に このタイプのCSRF攻撃を防止できる
    - このような設計により 最小限のパフォーマンス低下で 現実的なCSRF攻撃の脅威を防止している
- 余談: 他コンテンツタイプの悪用可能性
  - ここでは、一番想定される例として コンテンツタイプ例にtext/plainを提示した
    - ただし API側が以下のコンテンツタイプを受け付ける場合
    - これらも悪用される可能性がある
      - multipart/form-data または
      - application/x-www-form-urlencoded の悪用も同様に考えられる
- 余談2: 他の送信手段の悪用可能性
  - 以下の手段が考えられる
    - フォーム送信
      - `<form>` タグを用いてフォームを作成し submit() メソッドを呼び出す もしくは ボタンをクリックさせることで リクエスト送信
    - fetch api
      - fetch apiを用いて text/plain 等の simple requestと認識されるコンテンツタイプを用いたリクエスト送信

## γ. 攻撃者ページからのfetch apiを用いたsafe methodによるクロスサイト読み取り攻撃

攻撃に成功したとされる条件は以下の通り

- 攻撃者ページからの fetch apiを用いた safe method によるリクエスト送信が成功し
- レスポンスの内容が攻撃者ページの JavaScript に渡されること

- 注意点
  - この場合はsafe methodなので、CORSの防衛ラインの軸足が
  - 「APIを呼び出さない」から「API呼び出しは許容するがそのデータは閲覧できない」に 変化することに注意

このそれぞれの条件において、クロスサイト読み取り攻撃を防御する防御機構が働くかを以下の表に示す。

| ＼ | サブドメイン(ただし本家とは別のサブドメインとする) | 完全別ドメイン |
| 完全同一ドメイン SameSite=Lax | B | A,B |
| サブドメイン SameSite=Lax Access-Control-Allow-Credentials有 | B | A, B |
| 完全別ドメイン SameSite=none Access-Control-Allow-Credentials有 | B | B |

- この表のように
  - すべての例において 同一オリジンポリシー(SOP) による防御機構 (CORSポリシー) が働くことがわかる
  - また 本来の通信元である正規のSPAページが完全同一ドメイン・サブドメインであり、かつ 攻撃者ページが完全別ドメインである場合には
    - クッキーのSameSite属性による防御機構も働くことがわかる
  - したがって Originヘッダ検証を怠った場合でも
    - クロスサイト読み取り攻撃は成立しないことがわかる

- 余談1:
  - 副作用の発生するAPI は safe method で実装しないことが重要
  - safe methodにおいて、同一オリジンポリシー (SOP) の防御機構は
  - レスポンスの取得に関しては制限するが、リクエストの送信自体は制限しない
  - そのため、safe method で副作用を発生させるAPIが存在している場合
  - CSRF攻撃が成立してしまう可能性がある
- 余談2:
  - `Access-Control-Allow-Origin` に ワイルドカード `*` を設定し、かつ
  - `Access-Control-Allow-Credentials` ヘッダが `true` に設定されている場合は
  - ブラウザは レスポンス内容を JavaScript に渡さずエラーにするのは前述の通り
  - ただし、`Access-Control-Allow-Origin` に ワイルドカード `*` を設定してしまっており、かつ
  - クッキー情報無しでアクセスできるAPIが存在した場合は
  - クロスサイト読み取り攻撃が成立してしまう可能性がある
  - ただしそもそも、そのようなAPI設計は今回の前提条件に反するため ここでは考慮しない
- 余談3:
  - Originヘッダは、同一オリジン = 完全同一ドメインでGET, HEAD のみ付属しないという特徴がある
  - これは、完全同一ドメインかつsafe methodの場合 CSRF攻撃の危険性が極めて少なく、心配する必要がないと判断されるからである
  - したがって、同一オリジンかつsafe methodの場合には Originヘッダ検証を省略することができる

# 結論

- α: 攻撃者ページからの fetch apiを用いた unsafe methodによるCSRF攻撃
  - Originヘッダ検証を怠った場合でも CSRF攻撃が成立しないことが多い
- β: text/plain等の simple requestと認識されるコンテンツタイプを用いた POSTでJSONデータを無理やり送信させるタイプの CSRF攻撃
  - Originヘッダ検証を怠った場合に CSRF攻撃が成立する可能性がある
  - したがって 開発者は
    - API の要件に不要な場合は
    - simple requestと認識されるリクエストを APIで受け入れないようにすることが望ましい
  - もしくは Hono の `hono/csrf` ミドルウェアを利用して simple request と認識されるリクエストに対して Originヘッダ検証を行うことが望ましい
- γ: 攻撃者ページからのfetch apiを用いたsafe methodによるクロスサイト読み取り攻撃
  - Originヘッダ検証を怠った場合でも クロスサイト読み取り攻撃が成立しないことが多い
- 以上より、Originヘッダ検証を怠った場合においても
  - 基本的には 適切な CORSポリシーを設定した際の 同一オリジンポリシー(SOP) によるCSRF耐性
  - が働くことで、CSRF攻撃・クロスサイト読み取り攻撃を防御できる場合が多いことがわかる
  - SameSite属性によるCSRF耐性も副次的に働く場合があるが、同一オリジンポリシーよりは防御効果が低い
  - どちらの場合も、βの攻撃方法に対しては防御効果がない場合がある
    - その部分のみ `hono/csrf` ミドルウェアで 狙い撃ちの防御を行うことが望ましい
- 基本的には 最初に述べた通り
  - `hono/cors` で正しく CORSポリシーを設定し
  - クッキーの SameSite属性を適切に設定し
  - データを変更するAPI (副作用あり) と データを取得するAPI (副作用なし) で メソッドを分離し
  - 以上に気をつけて実装すれば CSRFは基本的に防御できる
- 更に安全を期すのであれば
  - `hono/csrf` ミドルウェアの代わりに
    - すべてのリクエストに対して Originヘッダ検証を行う
      - ただし 同一ドメイン = 同一オリジンかつ GET/HEAD の場合は Originヘッダが付属しないため 例外的に検証をスキップする
    - コンテンツタイプを application/json のみ受け入れる
  - といった対策を追加することが望ましい
  - ただし この場合は独自実装になるため 注意が必要

