


# 想定シナリオ

- 今回の問題は
  - サービスがアクセストークンの検証を怠っていた場合
  - 成りすまし攻撃が可能になる
- 具体的なシナリオを考える

- ブラウザでログインのできるサービス A がある
  - サービス A はフロントエンドとバックエンドの API に分かれている
  - サービス A は Auth0 を用いてログイン
  - バックエンドにはアクセストークンを送信して API を呼び出す
  - バックエンド API はアクセストークンを検証する
- また、ブラウザでログインのできるサービス B もある
- サービス B の開発者は悪意ある者である
-
- 被害者が、サービス B にログインする
- 悪意あるサービス B の開発者 は
  - 被害者が サービス B にログインしていることを利用して
  - 被害者のアクセストークンを入手する
    - サービス B の運営なので、被害者のアクセストークンを入手できる
- サービス B の開発者は 被害者のアクセストークンをサービス A のバックエンド API に送信する
  - サービス A のバックエンドは 検証を怠っているため
  - サービス B のアクセストークンを受け入れてしまう
- つまり、サービス B の開発者が、被害者になりすましてサービス A のバックエンド API を呼び出せる！
- =サービス B の開発者は 被害者になりすまして サービス A を利用できる！
  - → なりすましの完成！

(この流れを、1. 2. のような箇条書きで、ストーリーとしてわかりやすく解説する。)

# 今回の攻撃の概念実証を作った

- 攻撃の概念実証を作成した
  - https://frontend-client-a.calloc134personal.workers.dev/
  - https://frontend-client-b.calloc134personal.workers.dev/
- 技術構成と設計
  - 利用するサービス: Auth0, Hono
  - 攻撃の対象: OAuth アクセストークンの検証に不備があるバックエンド API
  - サービス A: フロントエンド(react) + 脆弱なバックエンド API + セキュアなバックエンド API
  - サービス B: フロントエンド(react) + 脆弱なバックエンド API + セキュアなバックエンド API (同じ)
- サービス A と サービス B は同じ Auth0 テナントを使っている
-
- 攻撃の流れ
  - 今回はユーザが動作検証を行うため、
  - 被害者と攻撃者を同一ユーザが演じる
  - ユーザがサービス B にログイン
  - サービス B のアクセストークンを取得
  - 概念実証サイトでは
  - サービス A のバックエンド API と サービス B のバックエンド API を
  - 両方呼び出せるようになっている。
  -
  - サービス B の 脆弱なバックエンド API ・ セキュアなバックエンド API を呼び出す
    - もちろんどちらも成功
    - 正規用途の動作確認
  - サービス A の 脆弱なバックエンド API ・ セキュアなバックエンド API を呼び出す
    - 脆弱なバックエンド API は成功 → なりすまし成功
    - セキュアなバックエンド API は失敗 → 成りすまし失敗

脆弱なバックエンド API 側は検証不備によりアクセストークンが使い回せるため、
もし攻撃者のサービス B が多くのユーザに使われていたら
サービス B の管理人は
サービス B でアクセストークンを発行した被害者
すべてのユーザについて
サービス A を利用することができてしまう

(この内容を、同じく箇条書きでわかりやすく解説する。)

# バックエンド API がアクセストークンを検証する実装

- 前提として、今回の実装を技術的にもっと深ぼる
- 例ではフロントエンドとバックエンドがある
  - フロントエンド ⇒ single page application (例: React)
  - バックエンド ⇒ API サーバ (例: Hono)
  - OAuth/OIDC プロバイダ ⇒ 任意の IDaaS プロバイダ (例: Auth0)
- 全体の流れ
- フロントエンドは Auth0 で OAuth/OIDC ログイン
- フロントエンドはアクセストークンを取得
- フロントエンドはバックエンド API にアクセストークンを送信
- バックエンド API はアクセストークンを検証する
- アクセストークンが正しければ※ API を実行する
- ※ の検証に不備があったのが今回の問題
  - アクセストークンの署名検証はしていた

# OAuth 仕様から見てこの実装はお行儀が良いか

- OAuth 仕様に照らすと、今回の実装は以下の通り
  - フロントエンド = OAuth クライアント
    - public client といえる
  - バックエンド API = OAuth リソースサーバ
- OAuth 仕様では
  - リソースサーバはアクセストークンの発行元 (OAuth 認可サーバ) を検証する責務がある
  - また、どのリソースサーバ向けのアクセストークンかを検証する責務もある
  - 仕様にある通りに検証すれば
  - アクセストークンの使いまわしによる成りすましは発生しない
  - また仕様では、アクセストークンに紐づく`scope` の検証も MUST とされている
- 余談
  - 筆者の意見では、
  - 一般的なリソースサーバではなく
  - Backend API の認可のみに OAuth アクセストークンを使う場合は
  - `scope`クレームまで検証する必要は流石になさそうだが…と考える
-

# 知識の前提となる OAuth の仕様

- OAuth はアクセストークンの仕様を規定しないが、
  - 今回は Auth0 に準拠して
  - OAuth アクセストークンが JWT 形式で発行される場合を想定する
- OAuth においてアクセストークンを JWT 形式にする仕様
  - RFC 9068 OAuth 2.0 JWT Access Tokens
- Auth0 もほぼ同じような形式を利用する
  - デフォルトでは Auth0 独自形式だが
  - RFC 9068 との差異は一部のクレームだけ
- ここでは重要なポイントのみを解説
  - アクセストークンは JWT 形式で発行される
  - JWT のクレームとして
  - 発行元 (issuer) を示す `iss` クレーム
  - 対象者 (audience) を示す `aud` クレーム
  - スコープを示す `scope` クレーム
  - などが含まれる
- アクセストークンにおける`aud`クレームは
  - アクセストークンがどのリソースサーバ向けに発行されたかを示す
  - 例えば、サービス A のバックエンド API 向けに発行されたアクセストークンは
  - `aud` クレームに サービス A のバックエンド API の識別子が含まれる
  - サービス B のバックエンド API 向けに発行されたアクセストークンは
  - `aud` クレームに サービス B のバックエンド API の識別子が含まれる
- リソースサーバは アクセストークンの `aud` クレームを検証し
  - 自分自身の識別子が含まれていることを確認する責務がある
  - これにより、他のリソースサーバ向けに発行されたアクセストークンを拒否できる
- これを怠ると、他のリソースサーバ向けに発行されたアクセストークンを受け入れてしまい
  - 成りすまし攻撃が可能になる

# Hono の JWT ミドルウェア に指摘された問題

- 今回の問題は、Hono が提供する JWT ミドルウェアを
- 開発者が誤って使ったことに起因する
- Hono の JWT ミドルウェアが作られた意図
  - 単なる JWT 検証ミドルウェアとして提供されている
  - つまり OAuth リソースサーバ向けに特化していない
  - OAuth リソースサーバ向けに使う場合は
    - 発行元 (issuer) の検証
    - 対象者 (audience) の検証
    - scope クレームの検証 (必要なら)
    - などを開発者が実装する必要がある
- しかし、今回の実装などで
  - JWT ミドルウェアを用いてバックエンド API を認可する場合
    - iss 検証は行うことができるが
    - aud パラメータを検証するオプションが存在しなかった
  - Hono 利用者が、aud パラメータがないという理由で
  - aud パラメータを検証せずそのまま利用すると
  - 他サービスのアクセストークンを受け入れてしまう
    - → 成りすまし攻撃が可能になる
- CVE-2025-62610 として報告された
  - 正しい脆弱性の表現としては
  - `token mix-up`攻撃 と呼称する
- Hono 側の修正
  - JWT ミドルウェアに対して aud 検証のオプションが追加された
  - これにより、backend api を認可する場合でも
  - aud 検証をミドルウェアで行う設定にすれば
  - 安全に利用できるようになった
- 注意しなければならないこと
  - デフォルトで自動的に安全になるわけではない
  - 開発者が aud 検証を有効にし、
  - 正しく活用する必要がある
  - 開発者のリテラシー向上が必要
- なお、ドキュメントにはまだ反映されていない
  - 筆者は Hono のコントリビューターではないので
  - コントリビューターがやってくれるのが一番だが
  - ドキュメントに反映される見通しが少ない場合は
  - 自分が PR を出そうかなと考えている
  - その場合、どのように開発者に
  - aud 検証の重要性を伝えるかが課題
- 開発者さん本人がブログを提供している
  - https://zenn.dev/okazu_dm/articles/d72419e2431761
  - コントリビュートありがとうございます！

# フレームワークの責務と利用者の責務

- 筆者の意見
  - 根本的な問題は フレームワークの責務と利用者の責務の境界に関する問題
  - フレームワーク側の意図は、単なる JWT 検証ミドルウェアを提供することだと考える
    - これは推測だが、JWt ミドルウェア という名称からして
- 本来であれば 利用者は
  - OAuth 認可の用途でアクセストークン検証を行う場合は
  - JWT ミドルウェアの利用で
    - 署名検証
    - 発行元 (issuer) の検証
  - を行うことを前提に、
  - JWT ミドルウェアでは行われない
    - 対象者 (audience) の検証
  - を自分で実装する必要がある
    - ペイロードをデコードして検証するミドルウェアを
    - 自分の手で実装すべき
- 今回は CVE が降りたが
  - 根本的原因は
  - 利用者のミドルウェア利用の用法ミスに起因するものであり
  - Hono 自体の脆弱性、あるいは Hono の JWT ミドルウェアの脆弱性とは
  - 考えづらいというのが筆者の意見
- aud を検証可能なオプションを追加したという修正は
  - 利用者のミドルウェア利用の用法ミスを防ぐための
  - Hono 側の配慮であって
  - Hono の JWT ミドルウェアの脆弱性ではないし、
  - 自動的に脆弱な実装が防がれるものではない
  -
- もうひとつの世界線として、
  - バックエンド API の認可を行う用途であれば、
  - Hono が JWT ミドルウェアとは別に
  - OAuth リソースサーバ用に
  - アクセストークンを検証するための
  - ミドルウェアを提供し、
  - そのミドルウェアを利用することを推奨する
  - という手もあるかも
- Hono の解決策を考える
  - ただ、今回の解決策でも
  - 対応は十分かなと考えている
- 他フレームワークでも、
  - OAuth リソースサーバ向けに特化した
  - アクセストークン検証ミドルウェアは
  - あまり提供されていないように思う
  - (筆者の知る限りでは)
  - 逆に、JWT 検証ミドルウェアにおいて
  - aud 検証をサポートしているものが多い

# 他フレームワークの対応

- Hono 以外のフレームワークではどうだろうか
  - Express.js
    - https://auth0.github.io/node-oauth2-jwt-bearer/
    - AUth0 が提供するミドルウェア
    - `jose` をベースに開発されている
    - JWT の検証に加え、iss/aud 検証も行う
    - scope 検証にも対応している
  - Fastify
    - https://github.com/nearform/fastify-jwt-jwks
    - サードパーティによるプラグイン
    - `@fastify/jwt` をベースに開発されている
    - JWT の検証に加え、iss/aud 検証もサポート
    - scope 検証には未対応の模様
  - Elysia
    - https://github.com/ap-1/elysia-oauth2-resource-server
    - 有志によるプラグイン
    - `jose` をベースに開発されている
    - JWT の検証に加え、iss/aud 検証もサポート
    - `scope` 検証にも対応している
- まとめると
  - Express.js, Fastify, Elysia の各フレームワークでは
  - JWT 検証ミドルウェア において
    - iss/aud 検証をサポートしているものが多い
    - scope 検証をサポートしているものもある

# できるならアクセストークンをセッションのように使わないでほしい

- そもそも、アクセストークンをセッションとして利用するのは
- OAuth の本来の使い方から外れている
  - セッション用途なら
  - OAuth の仕組みを無理に利用せず
  - クライアント-・サーバで別の仕組みを使うべき
    - クッキーベースのセッション
    - アクセストークンでは別の
    - バックエンドサーバが発行する JWT を用いたセッション
- OAuth アクセストークンは
  - API 間の認可を行うためのトークン
  - クライアント・サーバ間のセッションを管理するためのトークンではない
- OAuth アクセストークンを
- クライアント・サーバ間のセッションとして使うと
  - OAuth クライアントを Public Client として実装する必要がある
  - OAuth の行儀からしてみればこれは望ましくない
    - 詳細は別の記事で
- フロントエンドを Public Client として動作させ、
  - アクセストークンをセッションのように使う例は
  - 実際のサービスでも頻繁に見られる
- しかし、可能であれば避けるべき
  - バックエンドで発行するクッキーや JWT を用いたセッション管理を推奨したい
  - OAuth アクセストークンは API 間の認可に使うべきものである！

# 結論

- 筆者の意見では、そもそも
  - OAuth アクセストークンをセッションのように使うのは避けるべき
  - クライアント・サーバ間のセッション管理には
    - クッキーベースのセッション
    - バックエンド発行の JWT セッション
  - を使うべき
- もし OAuth アクセストークンをクライアント・サーバ間のセッションとして使う場合は
  - OAuth に対しての十分な理解を持ち
  - バックエンド API が OAuth リソースサーバとして動作することを踏まえた上で
  - 提供されるミドルウェアの用法を誤らずに実装すること
  - リソースサーバに必要な要件
    - 発行元 (issuer) 検証
    - 対象者 (audience) 検証
    - scope クレーム検証 (必要なら)
  - を必ず実装すること！
  - これを怠ると成りすまし攻撃のリスクがある！

# 余談: プロバイダごとのテナント分離機能と攻撃困難さ

- 実は、IDaaS プロバイダにはテナントという概念が存在する
  - テナント: アプリケーションが所属する論理的なグループ
  - 同一 Issuer / 同一の JWT 署名鍵
- 今まで解説したのは、同一テナントである前提
- もし Auth0 を利用しており、
- サービス A とサービス B が異なるテナントに所属している場合
  - JWT 署名検証で異なる署名鍵を使っているため攻撃不可能
  - 署名鍵が同じでも Issuer が異なるため攻撃不可能
    - ちなみに、Auth0 の場合は Issuer はテナントのドメイン
- Auth0 の場合、テナントの違いが攻撃困難の要因となる
- では、Auth0 以外の IDaaS プロバイダではどうか？
-
- 具体的に調査してみると、プロバイダの設定によっては脆弱になる
  - OneLogin (generic issuer 利用時)
    - generic issuer を使うと
    - issuer: `https://openid-connect.onelogin.com/oidc`で固定
    - 公開鍵: `https://openid-connect.onelogin.com/oidc/certs`で固定
    - つまり、テナントが異なっても同一の issuer / 署名鍵になる
    - したがって、同一テナントでなくても攻撃可能
    - ただし、敢えてこの設定にした場合のみ
  - Firebase Auth
    - Firebase プロジェクトが テナントに相当
    - 署名鍵は共通
    - Issuer は プロジェクトごとに異なる
    - つまり、署名鍵の検証のみの場合は攻撃可能
      - Issuer 検証を行えば攻撃不可能
- しかし、大半の場合はテナント分離が適切に行われていれば
- 攻撃は困難になる
- マネージド IDaaS プロバイダの例
  - Okta
    - Organization という概念が テナントに相当
    - Issuer と署名鍵が Organization ごとに異なる
  - AWS Cognito
    - User pool という概念が テナントに相当
    - Issuer と署名鍵が User pool ごとに異なる
- セルフホスト系 IDaaS プロバイダの例
  - Keycloak
    - Realm という概念が テナントに相当
    - Issuer と署名鍵が Realm ごとに異なる
  - ZITADEL
    - Instance という概念が テナントに相当
    - これも Issuer と署名鍵が Instance ごとに異なる
  - Logto
    - Logto tenant という概念が テナントに相当
    - これも Issuer と署名鍵が Logto tenant ごとに異なる
- 結論: テナントが別ならこの脆弱性は起こりづらい
  - 署名鍵と Issuer が異なるため
  - とはいえ、IDaaS プロバイダの設定によっては脆弱になる
  - どのような挙動になるかは各自で確認する必要
- また、テナントが同一の場合は
  - どのプロバイダであっても
  - 今回の脆弱性が発生する可能性を考慮しなければならない

# 余談: Opaque トークンでもこの問題は発生するか？

- Opaque トークン (非 JWT 形式のアクセストークン) でも同様の問題は発生する可能性がある
- どのようなトークンであっても
  - リソースサーバは
    - 誰が発行したか(発行元)
    - どのリソースサーバ向けか(対象者)
  - を検証する責務がある
- Opaque トークンの場合
  - トークンの内容を直接検証できないため
  - トークン情報を取得するために
  - 認可サーバに問い合わせる必要がある
- しかし、認可サーバに問い合わせる際に
  - 発行元 (issuer) や 対象者 (audience) の検証を怠ると
  - 同様の成りすまし攻撃が可能になる
- したがって、Opaque トークンであっても
  - リソースサーバは
    - 発行元
    - 対象者
  - に該当する情報の
  - 検証を必ず行う必要がある




以下の文章について、

```
そしてこの構成は、OAuth の仕様を正しく理解していない状態で実装すると
脆弱性の温床になりやすいです。
その代わり、
**バックエンドで発行するクッキーや JWT を用いたセッション管理**を推奨したいと思います。
```


このセクションに続くように、

React + Hono で開発を行う場合、

- JWT on クッキー でセッションを保持する
  - httponly
  - jwt on クッキー
  - フロント側 -> fetch api でクッキーを送信
  - バックエンド側 -> Hono の cookie ミドルウェアでクッキーを取得

で実装を行う場合のサンプルコードを示してください。
