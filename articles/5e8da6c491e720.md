---
title: "わからないところを解決しながら進めるOAuth/OIDCの理解"
emoji: "🌊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["OAuth", "OIDC", "PKCE"]
published: false
---

# はじめに

こんにちは。calloc134 です。

ここ最近、OAuth と OIDC について調べていました。
その際、なかなか躓くところが多く、学習に苦労したため、個人的に疑問に思ったことをベースに、OAuth と OIDC のフローについて解説していきたいと思います。

この記事を書くにあたり、ritou さん・Auth 屋さんの記事や書籍を参考にさせていただきました。
また、この記事を書くにあたり、ritou さん・Auth 屋さんに加え、Yuki Watanabe さんに疑問点を解決していただきました。
この場を借りて感謝申し上げます。

# ざっくりとした OAuth と OIDC の違い

まずは、OAuth と OIDC について、以下のようにざっくりとした違いを理解しておきましょう。

- OAuth は、ユーザが、所有するリソースへのアクセスを第三者に許可するための仕組み
- OIDC は、ユーザが、第三者に対して自分がどのような人物であるかを示し、これを用いて認証を行うための仕組み

「OAuth は認可・OIDC は認証！」というフレーズについて、よく耳にする方もいらっしゃるのではないでしょうか。
当フレーズについてはある程度正しいものの、このような簡潔な表現だと、本質を少し見失ってしまうかもしれません。
このフレーズに関しては、上記のような表現が適切であると、個人的には考えています。

OAuth は、ユーザが持っているリソースを第三者に認可するための仕組みです。したがって、認可の仕組みとみなされます。
OIDC は、ユーザの識別情報(ユーザがどのような人物であるかを示すプロフィール情報)を第三者に提示し、その情報をもって認証とする仕組みです。したがって、認証の仕組みとみなされます。

つまり、OAuth と OIDC のユースケースは全く別物であるということなんですね。

## OIDC は OAuth に機能を付け足したものなんじゃないの？なんで認証が実現できるの？

:::message alert
この章は、OIDC の誕生の経緯について解説しています。少し複雑な内容になるため、最初に読む場合は読み飛ばしても大丈夫です。
:::

では、OIDC の産まれる前の話から掘り下げていきましょう。

OAuth はリソースへのアクセスを第三者に許可するための仕組みです。

しかし、OAuth の仕組みを用いることで、認証用途にも利用できるのではないかということが考えられました。
簡単に言うと、第三者にプロフィールへのアクセスを許可すれば、そのプロフィールで身分証明ができる。これを認証用途に使えるんじゃないか？という流れです。
プロフィールをリソースとして提供する API を、プロフィール API と呼びます。

:::message alert
この仕組みについて、俗に「OAuth 認証」と呼ばれることがありますが、あまり適切な表現ではないので、避けるようにしましょう。

OAuth は認可の仕組みであり、識別情報を用いた認証への応用は規格として定義されていません。そのため、実装者が独自に拡張しているということになります。
実装者が独自に拡張している実装なので、もちろん実装方法もバラバラで統一されていません。万が一「OAuth 認証」のような言葉を議論に用いてしまうと、「そういう実装が存在するのか！なるほど」と誤解された認識が広まってしまい、混乱を招く可能性があります。
・・・というわけで、できるだけやめようね！というお話でした。
:::

OAuth + プロフィール API の実装について、実装者が独自実装を行うことが多かったため、このような認証の仕組みを規格として定義することが自然と求められました。そこで誕生したものが OIDC です。

「OIDC は OAuth にアイデンティティレイヤーを載せたものである」と言われるのは、このような理由からです。

:::message
実は、OAuth が登場する以前から、OIDC のベースとなる識別情報認証の仕組みとして OpenID というものが存在していました。

しかし OAuth を認証用途として利用する広まりを受け、OAuth2.0 という規格で土台を整えつつ OpenID の要素を統合することにより、認証用途としての仕組みを追加した仕様として、OIDC が誕生しました。
この経緯についてはわかりやすさのための少し省略されていますが、Auth 屋さんの本に詳しい解説があるので、そちらを参照いただけると幸いです。
:::

参考リンク
https://ritou.hatenablog.com/entry/2024/02/11/153633
https://booth.pm/ja/items/1550861
(P. 86)

詳しい実装については、以後の章で解説していきます。

# OAuth の登場人物

前述の通り、OAuth はリソースへのアクセスを第三者に許可するための仕組みです。
リソースのアクセス権を許可するという行為には、以下のような登場人物が関連してくると考えられるでしょう。

- リソースにアクセスしたい第三者のアプリケーション
- リソースを保管しているサーバ
- リソースへのアクセスを認可し
  アクセス権の鍵(アクセストークン)を発行するサーバ
- リソースの所有者(ユーザ)

では、それぞれの役割を詳しく見ていきましょう。

ここで、画像を加工するアプリケーションが、Google Photo にアクセスする場合を例に考えてみます。

## クライアント: リソースにアクセスしたい第三者のアプリケーション

OAuth におけるクライアントは、リソースにアクセスしたい第三者のアプリケーションを指します。
例として、画像を入力してその画像を加工するアプリケーションが考えれられます。

## リソースサーバ: リソースを保管しているサーバ

OAuth におけるリソースサーバは、リソースを保管しているサーバを指します。
実際にリソースを保管しているサーバです。
アクセストークンを受取り、それを検証し、成功すればリソースを返します。
例として、Google Photo で画像を保管しているサーバがリソースサーバに相当します。

## 認可サーバ: リソースへのアクセスを認可し、アクセス権を発行するサーバ

OAuth における認可サーバは、リソースへのアクセスを認可するサーバを指します。
このサーバはリソースを持っていませんが、リソースへアクセスすることを認め、アクセス権の鍵であるアクセストークンを発行する役割を担います。
例として、Google Photo にアクセスするための認可を行う Google OAuth サーバが認可サーバに相当します。

リソースサーバと認可サーバは比較的近い位置にあることが多く、同じサーバであることも多いです。特に小さいサービスでは分ける必要もないため、一緒にしていることがほとんどです。

## リソースオーナー: リソースの所有者(ユーザ)

OAuth におけるリソースオーナーは、リソースの所有者を指します。
サービスの利用者がリソースの所有者となります。
例として、Google Photo に画像をアップロードしているユーザがリソースオーナーに相当します。サービスのお客さんですね。

ここからは、よくある疑問について。

### クライアントって、フロントエンドのこと？

この場合のフロントエンドというのは、サーバ・クライアントモデルにおけるクライアントのことを指します。
つまり、ユーザのパソコンやスマホ上で動作する、Web ブラウザのアプリケーション(SPA)やモバイルアプリのことになります。

OAuth では、クライアントという言葉が登場します。
しかし、クライアントというのは OAuth におけるクライアントのことで、サーバ・クライアントモデルにおけるクライアントのことではありません。
この 2 つは異なる概念であることに注意しましょう。

### クライアントには 2 つのタイプがあるらしいけど、どう違うの？

:::message alert
この章は、クライアントタイプの解説について解説しています。少し複雑な内容になるため、最初に読む場合は読み飛ばしても大丈夫です。
:::

クライアントには、`Confidential Client` と `Public Client` という 2 つの種類が存在します。

この 2 つの違いの判断基準をわかりやすく伝えると、「クライアントが認可サーバからアクセストークンを受け取る際に、クライアントがユーザのフロントエンド側で動作するかどうか」です。

OAuth の RFC である RFC6749 にクライアントタイプの解説があります。
https://openid-foundation-japan.github.io/rfc6749.ja.html#client-types

ここでは、以下のような定義をしています。

- Confidential Client:
  クレデンシャルの機密性を維持することができるクライアント
- Public Client:
  クライアントクレデンシャルの機密性を維持することができず, かつ他の手段を使用したセキュアなクライアント認証もできないクライアント

クライアントクレデンシャルというのは、クライアント ID とクライアントシークレットのことを指します。こちらは後述の章で解説しますが、クライアントが認可サーバとやり取りするときに「自分はこのクライアントである」と証明するための情報です。
つまり、クライアントのソースコードを解析して、内部に埋め込まれているクライアント証明のための情報を不正に取り出すことができるかどうかが、この 2 つの違いの判断基準となります。

このようなことが出来るかどうかは、クライアントがユーザのフロントエンド側で動作するかどうかによって左右されると言えます。
したがって、クライアントが認可サーバからアクセストークンを受け取る際に、ユーザのフロントエンド側で動作するかどうかが、この 2 つの違いの判断基準となります。

# OAuth のフロー

### フローについていくつか種類があるけど、どう違うの？

OAuth には、いくつかのフローが存在します。
最も有名なものとして、認可コードフローがあります。今回解説するフローは、すべて認可コードフローをベースにしています。

また、他のフローとしてインプリシットフローというものが存在します。こちらは認可コードフローを単純にしたものなのですが、原理的にセキュリティ上の問題があります。また、これが提唱された目的について、認可コードフローでに特定の機構を追加することで上位互換として対応できるようになりました。そのため、現在はインプリシットフローは非推奨とされています。

残りの 2 つのフローについては、ほぼ使われていないため、解説を省略します。

## Confidential Client における OAuth のフロー

## Public Client における OAuth のフロー

## 余談: OAuth で認証を実装した場合

# OIDC の登場人物

前述の通り、OIDC は OAuth を拡張して、アイデンティティレイヤーを載せたものであると言われています。
そのため、OIDC における登場人物は、OAuth の登場人物と名称こそ違うものの、同じような役割を担っているものとなります。

OIDC は、第三者に対して自分がどのような人物であるかを示し、これを用いて認証を行うための仕組みです。
以下のような登場人物が関連してくると考えられるでしょう。

- プロフィールを確認したい第三者のアプリケーション
- プロフィール情報の詳細を提供するサーバ
- ユーザのクレデンシャルから認証を行い
  身分証明(ID トークン)とアクセストークンを発行するサーバ
- 認証をするユーザ

では、それぞれの役割を詳しく見ていきましょう。

ここで、Google のアカウントを持っているユーザが、A アプリに Google アカウントでログインする場合を例に考えてみます。

### リライングパーティ: プロフィールを確認したい第三者のアプリケーション

OIDC におけるリライングパーティは、プロフィールを確認したい第三者のアプリケーションを指します。
OAuth におけるクライアントに相当します。
例として、A アプリが Google アカウントでログインするためのアプリケーションがリライングパーティに相当します。

### UserInfo エンドポイント: プロフィール情報の詳細を提供するサーバ

OIDC における UserInfo エンドポイントは、プロフィール情報の詳細を提供するサーバを指します。
OAuth におけるリソースサーバに相当しますが、OIDC においてはあまり活躍することがない存在です。
アクセストークンを受取り、それを検証し、成功すればプロフィール情報を返します。
大抵は、次に説明する ID プロバイダの一機能として提供されることが多いです。

### ID プロバイダ: ユーザのクレデンシャルから認証を行い、身分証明を発行するサーバ

OIDC における ID プロバイダは、ユーザのクレデンシャルから認証を行い、身分証明である ID トークンとアクセストークンを発行するサーバを指します。
なお、アクセストークンについては、OAuth における認可サーバに相当します。前述の Userinfo エンドポイントにアクセスする際には、アクセストークンが必要になります。
OAuth における認可サーバに相当します。
例として、Google アカウントでログインするための Google ID プロバイダが ID プロバイダに相当します。

パスワード認証の場合、ユーザからユーザ名とパスワードを受取り、ユーザ名とパスワードが正しいかどうかを確認し、正しい場合は プロフィール情報の証明書のようなものを発行します。

### エンドユーザー: 認証をするユーザ

OIDC におけるエンドユーザーは、認証をするユーザを指します。
OAuth におけるリソースオーナーに相当します。

例として、Google のアカウントを持っているユーザがエンドユーザーに相当します。

# OIDC のフロー

### フローについていくつか種類があるけど、どう違うの？

ここについては、OAuth と同様の説明となるため、省略します。

:::message alert
最近では、Auth0 のような認証サービス`IDaaS`がよく使われていると思います。
:::

# 質問タイム

## state って何？

## PKCE って何？

##

参考資料
https://zenn.dev/ritou/articles/d26c7861047a2d
