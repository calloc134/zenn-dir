---
title: "わからないところを解決しながら進めるOAuth/OIDCの理解"
emoji: "🌊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["OAuth", "OIDC", "PKCE"]
published: false
---

# はじめに

こんにちは。calloc134 です。

ここ最近、OAuth と OIDC について調べていました。
その際、なかなか躓くところが多く、学習に苦労したため、個人的に疑問に思ったことをベースに、OAuth と OIDC のフローについて解説していきたいと思います。

この記事を書くにあたり、ritou さん・Auth 屋さんの記事や書籍を参考にさせていただきました。
また、この記事を書くにあたり、ritou さん・Auth 屋さんに加え、Yuki Watanabe さんに疑問点を解決していただきました。
この場を借りて感謝申し上げます。

# 進め方のおことわり

この記事では、OAuth と OIDC に関連する多くの概念を解説していきます。
また、自分が疑問に思ったことについて、その都度質問と解答の形式で解説していきます。しかし、疑問に思ったことの内容は最初に読むには少し難しいかもしれません。
初回の読み方としては、まずスキップマーク ⏭️ をつけた章を読み飛ばしながら一通り読んでみることをおすすめします。
その後、スキップした箇所もすべて通して読み直すことで、より理解が深まるかと思います。

:::message alert
OIDC の実装などで Auth0 などの IDaaS を利用することが良くあると思います。
しかし、IDaaS の実装は比較的独自性が強く、学習の妨げとなる場合もあります。ここでは既存の IDaaS の仕様を一旦忘れてから、この記事を読んでみることをおすすめします。

解説の途中で、適時 RFC や仕様書を引用しながら解説していきます。また、参考にしたリンクを章の終わりに記載していますので、必要に応じて参照してみてください。
:::

なお、以下のリンクより、OAuth/OIDC の関連仕様についてまとまったリンク集を参照することができます。
https://qiita.com/TakahikoKawasaki/items/185d34814eb9f7ac7ef3#2-bearer-token-usage-rfc-6750

# ざっくりとした OAuth と OIDC の違い

まずは、OAuth と OIDC について、以下のようにざっくりとした違いを理解しておきましょう。

- OAuth は、ユーザが、所有するリソースへのアクセスを第三者に許可するための仕組み
- OIDC は、ユーザが、第三者に対して自分がどのような人物であるかを示し、これを用いて認証を行うための仕組み

「OAuth は認可・OIDC は認証！」というフレーズについて、よく耳にする方もいらっしゃるのではないでしょうか。
当フレーズについてはある程度正しいものの、このような簡潔な表現だと、本質を少し見失ってしまうかもしれません。
このフレーズに関しては、上記のような表現が適切であると、個人的には考えています。

OAuth は、ユーザが持っているリソースを第三者に認可するための仕組みです。したがって、認可の仕組みとみなされます。
OIDC は、ユーザの識別情報(ユーザがどのような人物であるかを示す情報、つまりプロフィール)を第三者に信頼してもらい、その情報をもって認証とする仕組みです。したがって、認証の仕組みとみなされます。

つまり、OAuth と OIDC のユースケースは全く別物であるということなんですね。

https://ritou.hatenablog.com/entry/2020/12/01/000000
https://booth.pm/ja/items/1550861
(P. 10)

OAuth は、RFC6749 で定義されています。
https://openid-foundation-japan.github.io/rfc6749.ja.html#client-authentication

また、OIDC についても仕様が定義されています。
それぞれ、日本語訳が存在しているので、必要に応じて参照してみてください。
http://openid-foundation-japan.github.io/openid-connect-core-1_0.ja.html

## OIDC は OAuth に機能を付け足したものなんじゃないの？なんで認証が実現できるの？⏩

では、OIDC の産まれる前の話から掘り下げていきましょう。

OAuth はリソースへのアクセスを第三者に許可するための仕組みです。

しかし、OAuth の仕組みを用いることで、認証用途にも利用できるのではないかということが考えられました。
簡単に解説します。
まず、ユーザのプロフィールをリソースとして考えます。
次に、第三者にプロフィールへのアクセスを許可すれば、そのプロフィールで身分証明ができますね。そして、これを認証用途に使えるんじゃないか？という流れです。
プロフィールをリソースとして提供する API はプロフィール API と呼ばれ、このような実装を OAuth + プロフィール API と呼びます。

:::message alert
この仕組みについて、俗に「OAuth 認証」と呼ばれることがありますが、あまり適切な表現ではないので、避けるようにしましょう。

OAuth は認可の仕組みであり、識別情報を用いた認証への応用は規格として定義されていません。そのため、実装者が独自に拡張しているということになります。
実装者が独自に拡張している実装なので、もちろん実装方法もバラバラで統一されていません。万が一「OAuth 認証」のような言葉を議論に用いてしまうと、「そういう実装が存在するのか！なるほど」と誤解された認識が広まってしまい、混乱を招く可能性があります。
・・・というわけで、できるだけやめようね！というお話でした。
:::

OAuth + プロフィール API の実装について、実装者が独自実装を行うことが多かったため、このような認証の仕組みを規格として定義することが自然と求められました。そこで誕生したものが OIDC です。

「OIDC は OAuth にアイデンティティレイヤーを載せたものである」と言われるのは、このような理由からです。

> OpenID Connect 1.0 は, OAuth 2.0 プロトコルの上にシンプルなアイデンティティレイヤーを付与したものである.
> 引用元: http://openid-foundation-japan.github.io/openid-connect-core-1_0.ja.html#Introduction

ただし、OAuth + プロフィール API と OIDC は、内部実装としては結構異なる部分がある気がします。具体的な実装については、以後の章で解説していきます。

:::message
**歴史的な経緯**
OAuth が登場する以前から、OIDC のベースとなる識別情報認証の仕組みとして OpenID というものが存在していました。

しかし OAuth を認証用途として利用する広まりを受け、OAuth2.0 という規格でまず土台を整えつつ 、OpenID の要素を統合することにより認証用途としての仕組みを追加した仕様として、OIDC が誕生しました。
この経緯についてはわかりやすさのための少し省略されています。Auth 屋さんの本に詳しい解説があるので、そちらを参照いただけると幸いです。
:::

参考リンク
https://ritou.hatenablog.com/entry/2020/12/01/000000
https://ritou.hatenablog.com/entry/2024/02/11/153633
https://booth.pm/ja/items/1550861
(P. 86)

詳しい実装については、以後の章で解説していきます。

# OAuth の登場人物

前述の通り、OAuth はリソースへのアクセスを第三者に許可するための仕組みです。
リソースのアクセス権を許可するという行為には、以下のような登場人物が関連してくると考えられるでしょう。

- リソースにアクセスしたい第三者のアプリケーション
- リソースを保管しているサーバ
- リソースへのアクセスを認可し
  アクセス権の鍵(アクセストークン)を発行するサーバ
- リソースの所有者(ユーザ)

では、それぞれの役割を詳しく見ていきましょう。

ここで、画像を印刷するためのアプリケーションが、Google Photo にアクセスする場合を例に考えてみます。
余談ですが、この例は RFC の記載を踏襲しています。

## クライアント: リソースにアクセスしたい第三者のアプリケーション

OAuth におけるクライアントは、リソースにアクセスしたい第三者のアプリケーションを指します。
例として、画像を入力してその画像を印刷するアプリケーションが考えられます。

## リソースサーバ: リソースを保管しているサーバ

OAuth におけるリソースサーバは、実際にユーザの所有するリソースを保管しているサーバを指します。
アクセストークンを受取り、それを検証し、成功すればリソースを返します。
例として、Google Photo で画像を保管しているサーバがリソースサーバに相当します。

## 認可サーバ: リソースへのアクセスを認可し、アクセス権を発行するサーバ

OAuth における認可サーバは、リソースへのアクセスを認可するサーバを指します。
このサーバはリソースを持っていませんが、リソースへアクセスすることを認め、アクセス権の鍵であるアクセストークンを発行する役割を担います。
例として、Google Photo にアクセスするための認可を行う Google OAuth サーバが認可サーバに相当します。

リソースサーバと認可サーバは比較的近い位置にあることが多く、同じサーバであることも多いです。特に小さいサービスでは分ける必要もないため、一緒にしていることがほとんどです。

> 認可サーバーとリソースサーバー間のやりとりについては本仕様書の範囲外である. 認可サーバーはリソースサーバーと同一のサーバーでも異なるサーバーでもよい. 単一の認可サーバーが複数のリソースサーバーにアクセス可能なアクセストークンを発行してもよい.
> 引用元: https://openid-foundation-japan.github.io/rfc6749.ja.html#client-authentication

## リソースオーナー: リソースの所有者(ユーザ)

OAuth におけるリソースオーナーは、リソースの所有者を指します。
サービスの利用者がリソースの所有者となります。
例として、Google Photo に画像をアップロードしているユーザがリソースオーナーに相当します。サービスのお客さんですね。

ここまでで、OAuth における登場人物について解説してきました。

> 例えば, あるユーザー (リソースオーナー) が, 印刷サービス (クライアント) に対して, 写真共有サービス上 (リソースサーバー) に保管されている彼女の保護された写真へのアクセス権を与えることを考える. OAuth では, その際彼女のユーザー名とパスワードを印刷サービスに与える必要はない. そのかわり, 彼女は写真共有サービスの信任を得たサービス (認可サーバー) に対して認証を行い, 印刷サービスへのアクセス権限委譲用クレデンシャル (アクセストークン) を発行させる.
> 引用元: https://openid-foundation-japan.github.io/rfc6749.ja.html#anchor1
> ここからは、よくある疑問について解説していきます。

### クライアントって、フロントエンドのこと？

この場合のフロントエンドというのは、サーバ・クライアントモデルにおけるクライアントのことを指します。
つまり、ユーザのパソコンやスマホ上で動作する、Web ブラウザのアプリケーション(SPA)やモバイルアプリのことになります。

OAuth では、クライアントという言葉が登場します。
しかし、クライアントというのは OAuth におけるクライアントのことで、サーバ・クライアントモデルにおけるクライアントのことではありません。
この 2 つは異なる概念であることに注意しましょう。

### クライアントには 2 つのタイプがあるらしいけど、どう違うの？⏩

クライアントには、`Confidential Client` と `Public Client` という 2 つの種類が存在します。

この 2 つの違いの判断基準をわかりやすく伝えると、「クライアントが認可サーバからアクセストークンを受け取る際に、クライアントがユーザのフロントエンド側で動作するかどうか」です。

OAuth の RFC である RFC6749 にクライアントタイプの解説があります。
https://openid-foundation-japan.github.io/rfc6749.ja.html#client-types

ここでは、以下のような定義をしています。

- Confidential Client:
  クレデンシャルの機密性を維持することができるクライアント
- Public Client:
  クライアントクレデンシャルの機密性を維持することができず, かつ他の手段を使用したセキュアなクライアント認証もできないクライアント

クライアントクレデンシャルというのは、クライアント ID とクライアントシークレットのことを指します。こちらは後述の章で解説しますが、クライアントが認可サーバとやり取りするときに「自分はこのクライアントである」と証明するための情報です。
つまり、クライアントのソースコードを解析して、内部に埋め込まれているクライアント証明のための情報を不正に取り出すことができるかどうかが、この 2 つの違いの判断基準となります。

このようなことが出来るかどうかは、クライアントがユーザのフロントエンド側で動作するかどうかによって左右されると言えます。
したがって、クライアントが認可サーバからアクセストークンを受け取る際に、ユーザのフロントエンド側で動作するかどうかが、この 2 つの違いの判断基準となると解釈して良いでしょう。

参考リンク
https://zenn.dev/ritou/articles/d26c7861047a2d

### アクセストークンって、ランダムな文字列？それとも何かの情報？⏩

「アクセストークンって、JWT 形式になってて、アクセストークンを解読すれば色々な情報が見れるようになってるんだよね？」といった理解の方もいらっしゃるかもしれません。
しかし、OAuth の RFC では、アクセストークンの形式を特に規定していません。

> トークンは認可情報を取り出すための識別子を表したり, 検証可能な方法でそれ自身に認可情報を含んでもよい (データと署名を含むトークン文字列など). クライアントがトークンを使用するために, 本仕様で定めていない追加の認証クレデンシャルを要求することもできる.
> 引用元: https://openid-foundation-japan.github.io/rfc6749.ja.html#anchor8

つまり、JWT のようにアクセストークンに認可情報を含めることもできますし、ランダムな文字列であっても構いません。

OAuth2.0 に関連し、脅威モデルとセキュリティについて解説している RFC である RFC6819 には、アクセストークンの形式を以下のように分類しています。

Handle: ランダム文字列からなるトークンであり、認可サーバ内部のデータを参照するキーとして使用されるもの

> "handle" ("artifact" とも呼ばれる) とは, 認可サーバー内部のデータ構造に対するある種の参照である

Assertion: 解析可能なトークンであり、電子署名を持ち、内部に情報を含むもの

> assertion とはパース可能なトークンである. assertion は典型的には有効期間, 発行対象 (audience) を持ち, 改竄防止および発行者認証のため電子署名が付けられる.

前者はランダムな文字列であり、後者はまさに JWT ですね。
後者だと情報を持たせられる以上に有効期限や発行者認証ができるため、セキュリティ的にも有利です。しかし、情報が変更されたときに、その変更をリアルタイムに反映することが難しいというデメリットもあります。
OAuth 自体はアクセストークンの形式については特に規定していないため、どちらを使うかは実装者の自由ということを覚えておきましょう。

なお、以下の記事では、これらの形式についてより詳しく解説しています。
Handle を識別子型、Assertion を内包型という表現で分類していますが、内容としては同じです。
https://qiita.com/TakahikoKawasaki/items/970548727761f9e02bcd

更に踏み込んで解説してみます。
それぞれのトークン形式の特性を考えると、以下の結論が導かれます。

Handle 型のトークンは、認可サーバ内部のデータを参照するキーとして使用される。
つまり、認可サーバとリソースサーバが同一のサーバである場合には、リソースサーバの機能は認可サーバ内部のデータを参照することが出来るため、常に最新の情報からデータを取得することができる。
しかし、認可サーバとリソースサーバが分離している場合は、リソースサーバが認可サーバに問い合わせる必要があるため、通信コストがかかり、利点が薄れる。
https://qiita.com/TakahikoKawasaki/items/970548727761f9e02bcd#21-%E8%AD%98%E5%88%A5%E5%AD%90%E5%9E%8B%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%83%88%E3%83%BC%E3%82%AF%E3%83%B3%E3%81%AE%E6%83%85%E5%A0%B1%E5%8F%96%E5%BE%97%E6%96%B9%E6%B3%95
なお、このときに認可サーバが問合せを受け付ける API を提供しますが、これはイントロスペクション API と呼ばれます。
これについても仕様で既定されており、RFC7662 で定義されています。
https://tex2e.github.io/rfc-translater/html/rfc7662.html

また、Assertion 型のトークンは、有効期限や発行者認証ができるため、セキュリティ的に有利です。
しかし、情報が変更されたときに、その変更をリアルタイムに反映することが難しいというデメリットもあります。
また、アクセストークンの失効はかなり難しいという問題もあります。
https://qiita.com/TakahikoKawasaki/items/970548727761f9e02bcd#44-%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%83%88%E3%83%BC%E3%82%AF%E3%83%B3%E5%A4%B1%E5%8A%B9
失効という実装自体を完全に諦め、アクセストークンの期限を利便性の保てる範囲で出来るだけ短くすることで、対処を行うというのが現実的な着地点であると言えるでしょう。

ここ以降は OAuth の枠を超え、JWT のセキュリティ問題についての話になってしまいます。そのため、ここでは詳細な解説は省略します。
この議論を見ていると、セッションクッキー(ステートフル)と JWT (ステートレス)の対立の議論と本質的に同じような気がしますね・・・。

参考リンク
https://openid-foundation-japan.github.io/rfc6819.ja.html#section_tokens
https://qiita.com/TakahikoKawasaki/items/970548727761f9e02bcd
https://kiririmode.hatenablog.jp/entry/20170205/1486287614

# OAuth のフロー

### フローについていくつか種類があるけど、どう違うの？

OAuth には、いくつかのフローが存在します。
最も有名なものとして、認可コードフローがあります。今回解説するフローは、すべて認可コードフローをベースにしています。

また、他のフローとしてインプリシットフローというものが存在します。こちらは認可コードフローを単純にしたものなのですが、原理的にセキュリティ上の問題があります。また、これが提唱された目的について、認可コードフローでに特定の機構を追加することで上位互換として対応できるようになりました。そのため、現在はインプリシットフローは非推奨とされています。

残りの 2 つのフローについては、ほぼ使われていないため、解説を省略します。

## フロー開始前の下準備 ⏩

OAuth のフローを開始する前に、クライアントが認可サーバに登録されている必要があります。つまり、事前に認可サーバに対して、「私はこういうクライアントです」という情報を登録しておく必要があります。

クライアントタイプとリダイレクト URI(後述)を登録し、あとはおまけでアプリ名やアイコンなどを登録しておくと、ユーザにとって使いやすい認可画面が表示されます。
クライアントの登録が済むと、認可サーバはクライアントに対して、クライアント ID というものを発行します。クライアント ID はクライアントを識別するための情報であり、いわゆるクライアントのためのマイナンバーのようなものです。

参考リンク
https://openid-foundation-japan.github.io/rfc6749.ja.html#anchor13
https://openid-foundation-japan.github.io/rfc6749.ja.html#client-identifier

では、下ごしらえも終わったところで、実際の OAuth フローについて解説していきます。

## ざっくりとしたフロー

まずはざっくりとした解説です。
クライアントが Confidential か Public かについては、ひとまず考えずにざっくりと見てみます。

### どのようなセキュリティの問題があるの？

## Confidential Client における 具体的な OAuth フロー

## Public Client における 具体的な OAuth フロー

## 余談: OAuth で認証を実装した場合

# OIDC の登場人物

前述の通り、OIDC は OAuth を拡張して、アイデンティティレイヤーを載せたものであると言われています。
そのため、OIDC における登場人物は、OAuth の登場人物と名称こそ違うものの、同じような役割を担っているものとなります。

OIDC は、第三者に対して自分がどのような人物であるかを示し、これを用いて認証を行うための仕組みです。
以下のような登場人物が関連してくると考えられるでしょう。

- プロフィールを確認したい第三者のアプリケーション
- プロフィール情報の詳細を提供するサーバ
- ユーザのクレデンシャルから認証を行い
  身分証明(ID トークン)とアクセストークンを発行するサーバ
- 認証をするユーザ

では、それぞれの役割を詳しく見ていきましょう。

ここで、Google のアカウントを持っているユーザが、A アプリに Google アカウントでログインする場合を例に考えてみます。

### リライングパーティ: プロフィールを確認したい第三者のアプリケーション

OIDC におけるリライングパーティは、プロフィールを確認したい第三者のアプリケーションを指します。
OAuth におけるクライアントに相当します。
例として、A アプリが Google アカウントでログインするためのアプリケーションがリライングパーティに相当します。

### UserInfo エンドポイント: プロフィール情報の詳細を提供するサーバ

OIDC における UserInfo エンドポイントは、プロフィール情報の詳細を提供するサーバを指します。
OAuth におけるリソースサーバに相当しますが、OIDC においてはあまり活躍することがない存在です。
アクセストークンを受取り、それを検証し、成功すればプロフィール情報を返します。
大抵は、次に説明する ID プロバイダの一機能として提供されることが多いです。

### ID プロバイダ: ユーザのクレデンシャルから認証を行い、身分証明を発行するサーバ

OIDC における ID プロバイダは、ユーザのクレデンシャルから認証を行い、身分証明である ID トークンとアクセストークンを発行するサーバを指します。
なお、アクセストークンについては、OAuth における認可サーバに相当します。前述の Userinfo エンドポイントにアクセスする際には、アクセストークンが必要になります。
OAuth における認可サーバに相当します。
例として、Google アカウントでログインするための Google ID プロバイダが ID プロバイダに相当します。

パスワード認証の場合、ユーザからユーザ名とパスワードを受取り、ユーザ名とパスワードが正しいかどうかを確認し、正しい場合は プロフィール情報の証明書のようなものを発行します。

### エンドユーザー: 認証をするユーザ

OIDC におけるエンドユーザーは、認証をするユーザを指します。
OAuth におけるリソースオーナーに相当します。

例として、Google のアカウントを持っているユーザがエンドユーザーに相当します。

# OIDC のフロー

### フローについていくつか種類があるけど、どう違うの？

ここについては、OAuth と同様の説明となるため、省略します。

:::message alert
最近では、Auth0 のような認証サービス`IDaaS`がよく使われていると思います。
:::

# 質問タイム

## state って何？

## PKCE って何？

##

参考資料
https://zenn.dev/ritou/articles/d26c7861047a2d
