`5e8da6c491e720.md`
をベースにし、このブログの文章をある程度保持しながら、
books/sikkari-oauth-oidc 以下に zenn のブックとして再構築してください。

なお、目次について、
01~13 は作成済みです。これに続けて作成してください。

- クライアントの種類の違い(confidential/public)

  - oauth におけるクライアントタイプの違い
  - confidential client/public client の解説 (アクセストークン引き換えのリクエストを行う際、ユーザのフロントエンド側で動作するかどうか)
  - フロント/バックエンドによってクライアントタイプは左右される？
  - public client の具体例(モバイルアプリ、SPA)

- public client とクライアント認証の有無

  - public client ではクライアント認証の妥当性がないため、クライアント認証が不要であることの解説
  - その代わり PKCE である程度の脅威に対処可能であるという主張

- public client の場合に起こりうる認可コード奪取攻撃

  - カスタム URI スキームの悪用
  - その対策

- public client における認可コード消費攻撃

  - クライアントの偽装
  - その対策(PKCE の重要性)

- oauth におけるコードフローの違い
  - implicit flow の解説、何故 implicit flow が非推奨となったか
  - フロントチャネルへのアクセストークンの露出・フロントチャネルがクライアントに AT を渡せることの問題点
  - OAuth 2.1 への言及も含める

---

- OIDC に必要な概念
  - ID トークンの解説
    - ID トークンとはプロフィール証明書
  - OIDC では、リソースのアクセスではなく ID トークンを RP が"信用して認証"することが目的である点を強調
- ID トークンについての掘り下げ

  - ID トークンの構造(JWT)
    - 仕様も含めて解説
  - ID トークンとアクセストークンの違い
    - アクセストークンはリソースサーバのために発行される
      - アクセストークンはクライアントが解釈するものではないことを強調
    - ID トークンは Relying Party(RP) のために発行される
    - ID トークンはクレデンシャルだとは考えない
      - フロントチャネルに露出しても問題ない

- OIDC 登場人物

  - OAuth のロールを OIDC にマッピング
    - リソースオーナー -> エンドユーザ
    - クライアント -> Relying Party(RP)
    - 認可サーバ -> OpenID Provider(OP)
    - リソースサーバ -> UserInfo Endpoint
      - ここはほぼ認可の役割であることに留意

- OIDC 簡易フロー
  (ここでは認可コードフロー)

  - プロフィール API との比較
    - プロフィール API の一部分を userinfo/ に切り出し、
    - 信頼できるユーザ情報については ID トークンで提供する

- OAuth + プロフィール API による疑似認証の問題点
- OIDC を活用するマインドセット

  - ID トークンは出来るだけ短命
    - セッションを開始する上での認証バリデーションで利用するのみ
    - サーバサイドセッションで
  - OIDC 内の認証らしさ・認可らしさ
    - ID トークン ⇒ 認証
    - /userinfo ⇒ 認可
    - ID トークンのみで十分なこともある

- 応用編

- OIDC と OAuth 2.0 の策定の歴史的経緯
- 公開鍵暗号を用いたクライアント認証
- sender-constrained token の仕組み
- OIDC における implicit flow/hybrid flow とその安全性評価
  - nonce パラメータ
- OIDC におけるログアウトの仕組み
-
