---
title: "リフレッシュトークンとそのフロー"
---

## 概要

この章では、リフレッシュトークンの概念とそのフローについて解説します。

## リフレッシュトークンとは

**リフレッシュトークン**は、アクセストークンを再発行するためのトークンです。

RFC 6749 では、以下のように説明されています。

> リフレッシュトークンは, アクセストークンを取得するために使用されるクレデンシャルである. リフレッシュトークンは認可サーバーによってクライアントに対して発行され, 現在のアクセストークンが無効化されたり期限が切れた場合に, 新しいアクセストークンを取得するために使用される
>
> — [RFC 6749 Section 1.5](https://www.rfc-editor.org/rfc/rfc6749#section-1.5)

## なぜリフレッシュトークンが必要か

アクセストークンとはリソースへの鍵であり、漏洩すると第三者にリソースを不正利用されるリスクがあります。
そのため、アクセストークンにはできるだけ短い有効期限を設定することが推奨されます。

- 漏洩した場合の被害を最小限に抑えられる
- Assertion 式トークンの場合、即時失効が難しいため有効期限で対処

しかし、有効期限が短いと、ユーザは頻繁に認可フローを実行しなければならず、利便性が低下します。

そこで、リフレッシュトークンを用いた運用が考案されました。

- **アクセストークン**：有効期限は短い（例：1 時間）
- **リフレッシュトークン**：有効期限は長い（例：30 日）

アクセストークンが期限切れになった場合、クライアントはリフレッシュトークンを使って新しいアクセストークンを取得します。
これにより、ユーザは頻繁に再認可を行う必要がなく、セキュリティも確保できるようになります。

## リフレッシュトークンの取得

リフレッシュトークンの発行に対応している場合、認可コードフローのトークンレスポンスでリフレッシュトークンが返されます。

```json
{
  "access_token": "2YotnFZFEjr1zCsicMWpAA",
  "token_type": "Bearer",
  "expires_in": 3600,
  "refresh_token": "tGzv3JOkF0XG5Qx2TlKWIA", // これがリフレッシュトークン
  "scope": "read write"
}
```

:::message

OAuth 2.0 の仕様にはありませんが、
一般的に `offline_access` スコープを要求して OAuth フローを開始することで、
リフレッシュトークンの発行を明示的に要求できます。

:::

## リフレッシュトークンを使ったアクセストークンの再取得

リフレッシュトークンを使って新しいアクセストークンを取得するフローを見てみましょう。

```mermaid
sequenceDiagram
    participant C as クライアント
    participant AS as 認可サーバ

    C->>AS: リフレッシュリクエスト
    Note right of C: grant_type=refresh_token<br>refresh_token=xxx<br>+ クライアント認証
    AS->>AS: クライアント認証
    AS->>AS: リフレッシュトークンを検証
    AS->>AS: 新しいアクセストークンを発行
    AS->>C: 新しいアクセストークン<br>(+新しいリフレッシュトークン)
```

### リフレッシュリクエスト

リフレッシュトークンを使ってアクセストークンを再取得するためのリクエスト例を示します。

```http
POST /oauth2/token HTTP/1.1
Host: authorization-server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token
&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
```

| パラメータ      | 説明                                               |
| --------------- | -------------------------------------------------- |
| `grant_type`    | `refresh_token`（リフレッシュフローを示す）        |
| `refresh_token` | リフレッシュトークン                               |
| `scope`         | 新しいアクセストークンに要求するスコープ（省略可） |

`scope` パラメータを省略した場合、新しいアクセストークンには元のアクセストークンと同じスコープが付与されます。
ここで指定するスコープは、元のスコープと同じ範囲かそれ以下でなければなりません。
元のスコープより広いスコープを要求した場合、認可サーバがエラーを返します。

リフレッシュトークンフローを指定し、リフレッシュトークンを送信します。
Confidential Client の場合、クライアントの正当性を証明するため、クライアント認証も必要です。
クライアント認証のやり方は認可コードフローの場合と同様です。

### リフレッシュレスポンス

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "access_token": "new_access_token",
  "token_type": "Bearer",
  "expires_in": 3600,
  "refresh_token": "new_refresh_token", // リフレッシュトークンローテーションが有効な場合
  "scope": "read write" // 省略されることもある
}
```

レスポンスで、新しいアクセストークンとスコープ情報、有効期限が返されます。
認可サーバの設定により、リフレッシュトークンローテーションが有効な場合、
新しいリフレッシュトークンが返され、過去のリフレッシュトークンは無効化されます。

## リフレッシュトークンのセキュリティ

リフレッシュトークンはアクセストークンよりも有効期限が長いため、漏洩した場合のリスクが高くなります。
そのため、以下のようなセキュリティ対策が推奨されます。

### 1. 安全な保管

リフレッシュトークンは、アクセストークン以上に安全に保管する必要があります。

### 2. リフレッシュトークンローテーション

リフレッシュトークンローテーションとは、
リフレッシュトークンを使うたびに、新しいリフレッシュトークンを発行し、古いリフレッシュトークンを無効化するという方法です。
これにより、以下の利点があります。

- リフレッシュトークンは一度きり有効の使い捨てトークンになるため
  漏洩リスクが低減される
- 古いリフレッシュトークンが使われたことを検知し
  不正利用の兆候を察知して対応できる

ただし、リフレッシュトークンローテーションを導入するデメリットも存在します。

- 実装が複雑になる
- 同時に複数のリクエストが同じリフレッシュトークンを利用した場合、
  どちらかが「古いリフレッシュトークンの使用」となり失敗する可能性がある
- リクエストのみ成功しレスポンスが届かない場合、
  クライアント側で新しいリフレッシュトークンを受け取れず
  手持ちの古いトークンが無効化されてしまうリスクがある

このように、リフレッシュトークンローテーションはユーザ体験が悪化する可能性を伴います。

Public Client の場合、リフレッシュトークンローテーションの採用は強く推奨されています。
一方、Confidential Client の場合、リフレッシュトークンローテーションを採用しないという判断が行われることが多いです。

### 3. スコープの制限

リフレッシュ時に、元のスコープと同じかそれ以下のスコープのみを要求できるようにする。

## まとめ

- **リフレッシュトークン**はアクセストークンを再発行するためのトークン
- アクセストークンの有効期限を短く保ちつつ、ユーザの利便性を確保できる
- リフレッシュトークンは長命なため、セキュリティに注意が必要
