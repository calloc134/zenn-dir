---
title: "OAuthまとめとOAuth 2.1の紹介"
---

## OAuth まとめ

ここまでの章で、OAuth 2.0 の基本的な仕組みとセキュリティ対策について学びました。

### 学んだこと

学んだことについて、軽く振り返りましょう。

#### 基本概念

- **OAuth とは**: リソースの所有者がリソースへのアクセス権を第三者に与える仕組み
- **アクセストークン**: リソースにアクセスするための鍵。漏洩したら非常に危険
- **認可コード**: アクセストークンと引き換えるための一時的なトークン
- **スコープ**: アクセス権の範囲を指定する仕組み

#### 登場人物

| ロール           | 役割                           |
| ---------------- | ------------------------------ |
| リソースオーナー | リソースの持ち主               |
| クライアント     | リソースにアクセスしたい第三者 |
| 認可サーバ       | アクセストークンを発行する     |
| リソースサーバ   | リソースを管理する             |

#### 認可コードフローと攻撃・防御

| 攻撃                                  | 防御機構                  | 検証主体     |
| ------------------------------------- | ------------------------- | ------------ |
| 認可コード奪取（redirect_uri 改ざん） | redirect_uri 完全一致検証 | 認可サーバ   |
| 認可コードすり替え                    | PKCE                      | 認可サーバ   |
| CSRF（認可コード押し付け）            | state パラメータ          | クライアント |

#### クライアントの種類

| 種類                | 特徴                                       | クライアント認証 |
| ------------------- | ------------------------------------------ | ---------------- |
| Confidential Client | クライアントシークレットを安全に保管可能   | ○                |
| Public Client       | クライアントシークレットを安全に保管不可能 | ×                |

### 完全版認可コードフロー

```mermaid
sequenceDiagram
    participant RO as リソースオーナー
    participant C as クライアント
    participant AS as 認可サーバ
    participant RS as リソースサーバ

    RO->>C: リソースにアクセスしてほしい
    C->>C: code_verifier, state を生成<br>セッションに保存
    C->>RO: 認可サーバにリダイレクト
    RO->>AS: 認可リクエスト
    AS->>AS: redirect_uri 検証
    AS->>AS: リソースオーナー認証
    AS->>AS: 認可コード発行
    AS->>RO: クライアントにリダイレクト
    RO->>C: 認可コード + state
    C->>C: state 検証
    C->>AS: トークンリクエスト + code_verifier
    AS->>AS: クライアント認証（Confidential のみ）
    AS->>AS: PKCE 検証
    AS->>AS: アクセストークン発行
    AS->>C: アクセストークン
    C->>RS: リソースリクエスト
    RS->>RS: アクセストークン検証
    RS->>C: リソース
```

## OAuth 2.1 の紹介

### OAuth 2.1 とは

OAuth 2.1 は、IETF OAuth WG が策定中の仕様です。
OAuth 2.0 は、本体である RFC6749 以外にも多数の拡張仕様が存在し、全体として複雑化していました。OAuth 2.1 は、これらを**統合**し、最新の**ベストプラクティス**を反映した仕様です。

また、**危険な選択肢を削除**し、安全なやり方を必須化することで、実装者が安全な OAuth を実装しやすくすることを目的としています。

### 主な変更点

| 項目                                       | OAuth 2.0          | OAuth 2.1                                       |
| ------------------------------------------ | ------------------ | ----------------------------------------------- |
| インプリシットフロー                       | 使用可能（非推奨） | **削除**                                        |
| Resource Owner Password Credentials フロー | 使用可能           | **削除**                                        |
| PKCE                                       | 任意               | **必須**                                        |
| redirect_uri 完全一致検証                  | 推奨               | **必須**                                        |
| トークンリクエスト時の redirect_uri        | 必須               | **削除**（PKCE で代替）                         |
| Public Client のリフレッシュトークン       | 制約なし           | **Sender-Constrained またはローテーション必須** |

### PKCE の必須化

OAuth 2.0 では PKCE は拡張仕様（RFC 7636）でしたが、OAuth 2.1 では**必須**となりました。

つまり、Confidential / Public を問わず、すべてのクライアントで PKCE を実装する必要があります。
これにより、すべてのクライアントで認可コードすり替え攻撃を防止できるようになります。

### インプリシットフローの削除

OAuth 2.1 では、インプリシットフローが仕様から**完全に削除**されました。
セキュリティ上の問題が多すぎることに加え、CORS の普及により技術的な必要性がなくなり、
古い仕様として切り捨てられた形です。

### その他のフローの削除

OAuth に関連する以下のフローも削除されています。

- **Resource Owner Password Credentials Grant**:
  ユーザーのパスワードをクライアントに渡す必要があり、セキュリティ上問題
- **その他**: 認可コードフローと Client Credentials フローのみが残存

### トークンリクエスト時の redirect_uri 削除

OAuth 2.0 では、トークンリクエスト時に redirect_uri を再送信し、
認可リクエスト時の値と一致するか検証することで、認可コードすり替え攻撃を防止するという仕様がありました。

OAuth 2.1 では PKCE が必須化されたため、この検証は**冗長**となり、削除されました。

### Public Client のリフレッシュトークン制約

OAuth 2.1 では、Public Client に対してリフレッシュトークンの利用に制約が加えられました。
Public Client がリフレッシュトークンを利用する場合、以下のいずれかを満たす必要があります。

- **Sender-Constrained トークン**:
  リフレッシュトークンが特定のクライアントにのみ使用可能であることを保証
- **リフレッシュトークンのローテーション**:
  リフレッシュトークンを使うたびに新しいリフレッシュトークンを発行し
  古いトークンを無効化

Sender-Constrained トークンについては応用編で解説します。

Public Client でリフレッシュトークンを発行する要件があり、
かつ Sender-Constrained トークンを利用できない場合、リフレッシュトークンのローテーションを実装する必要があります。

多くの場合、Public Client ではリフレッシュトークンローテーションの採用が現実的です。

## まとめ

ここまで、OAuth 2.0 の全体のまとめ、および OAuth 2.1 の紹介を行いました。

- OAuth の基本的な仕組みとフローを理解した
- 認可コードフローの詳細な流れとセキュリティ対策を理解した
- OAuth 2.1 は OAuth 2.0 の最新のベストプラクティスを反映した仕様
- 新規実装や既存実装の更新時には OAuth 2.1 を参考にすることを推奨

次の章からは、いよいよ満を持して、
OAuth の上に構築された **OIDC（OpenID Connect）** について解説します。

とはいえ、OIDC は OAuth 2.0 をベースとしているため、
多くの部分で OAuth 2.0 の知識が活かせます。
引き続き頑張りましょう！
