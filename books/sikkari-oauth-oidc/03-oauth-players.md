---
title: "OAuth の登場人物"
---

# OAuth の登場人物

前述の通り、OAuth はリソースへのアクセスを第三者に許可するための仕組みです。
リソースのアクセスを許可するという行為には、以下のような登場人物が関連してくると考えられるでしょう。

- リソースにアクセスしたい第三者のアプリケーション
- リソースを保管しているサーバ
- リソースへのアクセスを認可し、アクセス権の鍵（アクセストークン）を発行するサーバ
- リソースの所有者（ユーザ）

OAuth の仕様である RFC6749 には、以下のように説明されています。

> 例えば, あるユーザー (リソースオーナー) が, 印刷サービス (クライアント) に対して, 写真共有サービス上 (リソースサーバー) に保管されている彼女の保護された写真へのアクセス権を与えることを考える.
> OAuth では, その際彼女のユーザー名とパスワードを印刷サービスに与える必要はない. そのかわり, 彼女は写真共有サービスの信任を得たサービス (認可サーバー) に対して認証を行い, 印刷サービスへのアクセス権限委譲用クレデンシャル (アクセストークン) を発行させる^[https://openid-foundation-japan.github.io/rfc6749.ja.html#anchor1].

この例に沿って、OAuth における登場人物について解説していきます。
画像を印刷するためのアプリケーションが、Google Photo にアクセスする場合を例に考えてみます。

![](/images/5e8da6c491e720/2025-02-05-15-51-32.png)

## クライアント

**クライアント**は、リソースにアクセスしたい第三者のアプリケーションを指します。

例として、画像を入力してその画像を印刷するアプリケーションが考えられます。

## リソースサーバ

**リソースサーバ**は、実際にユーザの所有するリソースを保管しているサーバを指します。

アクセストークンを受取り、それを検証し、成功すればリソースを返します。

例として、Google Photo で画像を保管しているサーバがリソースサーバに相当します。

## 認可サーバ

**認可サーバ**は、リソースへのアクセスを認可するサーバを指します。

このサーバはリソースを持っていませんが、リソースへアクセスすることを認め、アクセス権の鍵であるアクセストークンや、アクセストークンに引き換えることのできる認可コードを発行する役割を担います。

例として、Google Photo にアクセスするための認可を行う Google OAuth サーバが認可サーバに相当します。

:::message
リソースサーバと認可サーバは比較的近い位置にあることが多く、同じサーバであることも多いです。

> 認可サーバーとリソースサーバー間のやりとりについては本仕様書の範囲外である. 認可サーバーはリソースサーバーと同一のサーバーでも異なるサーバーでもよい. 単一の認可サーバーが複数のリソースサーバーにアクセス可能なアクセストークンを発行してもよい^[https://openid-foundation-japan.github.io/rfc6749.ja.html#client-authentication].

:::

## リソースオーナー

**リソースオーナー**は、リソースの所有者を指します。

サービスの利用者がリソースの所有者となります。

例として、Google Photo に画像をアップロードしているユーザがリソースオーナーに相当します。サービスのお客さんですね。

# よくある疑問

## クライアントって、スマホとかパソコンで動作するもの？

OAuth では、クライアントという言葉が登場します。
しかし、クライアントというのは OAuth におけるクライアントのことで、サーバ・クライアントモデルにおけるクライアントのことではありません。

この 2 つは異なる概念であることに注意しましょう。

![](/images/5e8da6c491e720/2025-02-05-15-54-41.png)

# 余談: クライアントタイプ（Confidential / Public）

:::message
この節は少し発展的な内容です。最初は読み飛ばしても構いません。後述の章で再度触れることになります。
:::

クライアントには、`Confidential Client` と `Public Client` という 2 つの種類が存在します。

この 2 つの違いの判断基準を一言で伝えると、

**「アクセストークン引き換えのリクエストを行う際に、クライアントがユーザのフロントエンド側で動作するかどうか」** であると考えていいと思われます。

OAuth の RFC である RFC6749 にクライアントタイプの解説があります。
RFC によると、以下のように定義されています^[https://openid-foundation-japan.github.io/rfc6749.ja.html#client-types]。

| クライアントタイプ  | 説明                                                                                                                             |
| ------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| Confidential Client | クレデンシャルの機密性を維持することができるクライアント                                                                         |
| Public Client       | クライアントクレデンシャルの機密性を維持することができず、かつ他の手段を使用したセキュアなクライアント認証もできないクライアント |

クライアントクレデンシャルというのは、クライアント ID とクライアントシークレットのことを指します。こちらは後述の章で解説しますが、クライアントが認可サーバとやり取りするときに「自分はこのクライアントである」と証明するための情報です。

つまり、第三者がクライアントのソースコードを解析して、内部に埋め込まれているクライアント証明のための機密情報を不正に取り出すことができるかどうかが、この 2 つの違いの判断基準となります。

![](/images/5e8da6c491e720/2025-02-05-15-57-38.png)

**この本では、簡単のため、まずは Confidential Client を前提として解説を進めていきます。**
Public Client については、後述の章で改めて触れることにします。

参考リンク
https://zenn.dev/ritou/articles/d26c7861047a2d
