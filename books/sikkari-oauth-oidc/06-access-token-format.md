---
title: "アクセストークンの形式"
free: true
---

## 概要

この章では、OAuth におけるアクセストークンの形式について解説します。

重要なのは、**OAuth 自体はアクセストークンの形式を規定していない**ということです。[^rfc6749-token-format]
そのため、サービスによってアクセストークンの形式が異なります。

[^rfc6749-token-format]: RFC 6749 Section 1.4 において「トークンは認可情報を取り出すための識別子を表したり, 検証可能な方法でそれ自身に認可情報を含んでもよい」と説明されています。https://www.rfc-editor.org/rfc/rfc6749.html#section-1.4

## アクセストークンの形式の種類

RFC 6819（OAuth 2.0 Threat Model and Security Considerations）では、アクセストークンを大きく 2 種類に分類しています。

| 形式             | 特徴                                                                                           | 別名                 |
| ---------------- | ---------------------------------------------------------------------------------------------- | -------------------- |
| **Handle 式**    | ランダム文字列からなる不透明なトークン。<br>認可サーバの内部データを参照するキーとして機能する | Opaque Token         |
| **Assertion 式** | トークンそのものに意味があり、解析が可能。<br>JWT が代表例                                     | Self-contained Token |

### Handle 式トークン

Handle 式トークンは、ランダムな文字列で構成されます。

```
a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
```

このトークンを見ても、どのような情報が含まれているかはわかりません。
リソースサーバがトークンの詳細を知るためには、認可サーバに問い合わせる必要があります。

### Assertion 式トークン

Assertion 式トークンは、JWT（JSON Web Token）のように解析可能なトークンです。

```
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwic2NvcGUiOiJyZWFkIHdyaXRlIiwiZXhwIjoxNjE2MjM5MDIyfQ.signature
```

このトークンをデコードすると、発行者、有効期限、スコープなどの情報を取得できます。
また、電子署名を持つため、改ざん検知が可能です。

![](/images/06-access-token-format/2025-12-02-13-01-02.png)

:::message

JWT の詳細については [24 章 JWT と JWS/JWE の概要](/calloc134/books/sikkari-oauth-oidc/viewer/24-jwt-jws-jwe-overview) で詳しく解説します。

:::

## それぞれのメリットとデメリット

### Handle 式トークンのメリット・デメリット

**メリット**

- トークンが漏洩しても、認可サーバ側で無効化が容易
- データが認可サーバ側で一元管理されるため、サーバ側のデータ変更を即座に反映できる

**デメリット**

- リソースサーバがアクセストークンの詳細を取得するために
  認可サーバに問い合わせる必要がある
- 認可サーバへの問い合わせが発生するため、パフォーマンスに影響が出る可能性がある

Handle 式トークンの場合、認可サーバのデータベースで情報を一元管理しているため、サーバ側のデータ変更は即時に反映されます。
その一方で、毎回認可サーバに問い合わせる必要があるため、パフォーマンスに影響が出る可能性があります。
Web の用語を借りると、**ステートフル** なトークン形式と言えます。

![](/images/06-access-token-format/2025-12-02-13-12-10.png)

:::message
Handle 式トークンを採用する場合、トークンの詳細を認可サーバに問い合わせるための API が必要です。
これは**イントロスペクション API** と呼ばれ、[RFC 7662](https://www.rfc-editor.org/rfc/rfc7662) で定義されています。
:::

### Assertion 式トークンのメリット・デメリット

**メリット**

- リソースサーバが認可サーバに問い合わせることなく、トークンの詳細情報を取得できる
- パフォーマンスが良い

**デメリット**

- トークンが漏洩した場合、認可サーバ側で即座に無効化することが難しい
- トークンに含まれる情報が古くなる可能性がある
- 失効の実装が難しいため
  アクセストークンの有効期限を短く設定することで対処することが多い

Assertion 式トークンは、トークン自体に情報が含まれているため、認可サーバに問い合わせる必要がありません。
そのため、パフォーマンスに優れています。
しかし、トークンの無効化が難しいため、アクセストークンの有効期限を短く設定することが一般的です。
Web の用語を借りると、**ステートレス** なトークン形式と言えます。

![](/images/06-access-token-format/2025-12-02-13-25-27.png)

## アクセストークンに含まれるメタデータ

Handle 式・Assertion 式のどちらの形式であっても、
アクセストークンには共通して**メタデータ**が紐づいています。

Handle 式の場合はこれらの情報が認可サーバのデータベースに保存されます。
一方 Assertion 式の場合は、トークン自体にこれらの情報が含まれます。

### 基本的なメタデータ

アクセストークンに紐づく代表的なメタデータは以下の通りです。

| フィールド  | 説明                                   |
| ----------- | -------------------------------------- |
| `issuer`    | トークンの発行者（認可サーバ）         |
| `audience`  | トークンの受信者（リソースサーバ）     |
| `scope`     | トークンに付与された権限の範囲         |
| `exp`       | トークンの有効期限                     |
| `iat`       | トークンの発行時間                     |
| `client_id` | トークンを要求したクライアントの識別子 |

### 各フィールドの詳細

#### `issuer`（発行者）

`issuer` は、トークンを発行した認可サーバを識別するための値です。
通常は認可サーバの URL が設定されます。

```json
{
  "issuer": "https://auth.example.com"
}
```

リソースサーバはアクセストークンを受け取ったときにこの値を検証し、
信頼できる認可サーバから発行されたトークンかどうかを確認できます。

詳細な検証方法については、[7 章 アクセストークンの検証手順](/calloc134/books/sikkari-oauth-oidc/viewer/07-access-token-validation) で解説します。

#### `audience`（受信者）

`audience` は、トークンの受信者（リソースサーバ）を識別するための値です。
トークンがどのリソースサーバに対して有効かを示します。

```json
{
  "audience": "https://api.example.com"
}
```

リソースサーバはアクセストークンを受け取ったときにこの値を検証し、
他のリソースサーバ向けに発行されたトークンの誤用を防ぐことができます。

これも詳細については [7 章 アクセストークンの検証手順](/calloc134/books/sikkari-oauth-oidc/viewer/07-access-token-validation) で解説します。

#### `scope`（スコープ）

`scope` は、トークンに付与された権限の範囲を示します。
クライアントがどのような操作を許可されているかを表現します。

```json
{
  "scope": "read write"
}
```

例えば、`read` スコープのみを持つトークンでは読み取り操作のみが許可され、
書き込み操作は拒否されます。
スコープの詳細な仕組みについては、[7 章 アクセストークンの検証手順](/calloc134/books/sikkari-oauth-oidc/viewer/07-access-token-validation) で解説します。

#### `exp`（有効期限）

`exp`（expiration time）は、トークンの有効期限を示します。
この時刻を過ぎたトークンは無効とみなされ、リソースサーバはリクエストを拒否します。

値は Unix タイムスタンプ（1970 年 1 月 1 日からの経過秒数）で表現されます。

```json
{
  "exp": 1704067200
}
```

上記の例では、2024 年 1 月 1 日 00:00:00 UTC に有効期限が切れることを意味します。

#### `iat`（発行時間）

`iat`（issued at）は、トークンが発行された時刻を示します。
`exp` と同様に Unix タイムスタンプで表現されます。

```json
{
  "iat": 1704063600
}
```

トークンがいつ発行されたかを確認したり、トークンの鮮度を判断したりするために使用されます。

#### `client_id`（クライアント識別子）

`client_id` は、トークンを要求したクライアント（アプリケーション）を識別するための値です。
クライアント ID については [8 章 クライアント登録と認証](/calloc134/books/sikkari-oauth-oidc/viewer/08-client-registration) で解説します。

```json
{
  "client_id": "my-web-app"
}
```

## まとめ

OAuth 自体はアクセストークンの形式を規定していないため、
どちらの形式を採用するかは実装者の自由です。

それぞれの特性を理解した上で、サービスの要件に合った形式を選択しましょう。

| 観点           | Handle 式                           | Assertion 式        |
| -------------- | ----------------------------------- | ------------------- |
| パフォーマンス | △（認可サーバへの問い合わせが必要） | ○（問い合わせ不要） |
| 即時失効       | ○（容易）                           | △（難しい）         |
| データ鮮度     | ○（常に最新）                       | △（古くなる可能性） |
