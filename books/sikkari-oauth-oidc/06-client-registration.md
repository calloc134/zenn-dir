---
title: "クライアント登録と認証"
---

# クライアント登録の必要性

ここまでの章で、OAuth のフローについて学んできました。

しかし、ここで一つ疑問が生まれます。

**「認可サーバは、リクエストを送ってきたのが正しいクライアントであるかを、どうやって確認するのでしょうか？」**

もし誰でも自由にアクセストークンを取得できてしまったら、悪意のあるアプリケーションがリソースにアクセスできてしまいますね。

そこで必要となるのが、**クライアント登録**と**クライアント認証**です。

# クライアント登録

OAuth のフローを開始する前に、クライアントが認可サーバに登録されている必要があります。つまり、事前に認可サーバに対して、「私はこういうクライアントです」という情報を登録しておく必要があります。

![](/images/5e8da6c491e720/2025-02-05-16-18-28.png)

## 登録する情報

クライアント登録時には、以下の情報を登録します。

- **クライアントタイプ**（Confidential / Public）
- **リダイレクト URI**（認可後にリダイレクトする先）
- アプリ名やアイコンなど（認可画面に表示される情報）

> クライアントを登録する場合, クライアント開発者は以下を満たすものとする (SHALL).
> Section 2.1 で説明されているようなクライアントタイプを指定し,
> Section 3.1.2 で説明されているようなリダイレクト URI を提供し,
> 認可サーバーが要求するその他の情報 (例えばアプリケーション名, Web サイト, 説明, ロゴイメージ, 利用規則など) を提供する.

## クライアント ID の発行

クライアントの登録が済むと、認可サーバはクライアントに対して、**クライアント ID** を発行します。

クライアント ID はクライアントを識別するための情報であり、いわゆるクライアントのためのマイナンバーのようなものです。

![](/images/5e8da6c491e720/2025-02-05-16-19-26.png)

> 認可サーバーは登録済みのクライアントにクライアント識別子 (クライアントが提供した登録情報を表すユニーク文字列) を発行する

## クライアントシークレットの発行

**Confidential Client** の場合、クライアント ID に加えて**クライアントシークレット**も発行されます。

クライアントシークレットは、クライアントが認可サーバに対して「自分はこのクライアントである」と証明するための秘密情報です。パスワードのようなものですね。

参考リンク
https://openid-foundation-japan.github.io/rfc6749.ja.html#anchor13
https://openid-foundation-japan.github.io/rfc6749.ja.html#client-identifier

# クライアント認証

クライアント認証とは、**クライアントが自身を正しいクライアントであることを認可サーバに証明すること**です。

![](/images/5e8da6c491e720/2024-09-26-21-10-40.png)

## なぜクライアント認証が必要なのか

認可コードをリソースオーナーから受け取ったクライアントは、認可サーバに対してアクセストークンとの交換をリクエストします。

この時クライアントは、自身が正しいクライアントであることを認可サーバに証明する必要があります。

この証明がない場合、クライアントがなりすまされ、意図していないクライアントにアクセストークンを取得されてしまう可能性があるため、この仕様は必要事項となっています。

![](/images/5e8da6c491e720/2024-09-26-21-15-38.png)

## クライアント認証の方法

Confidential Client の場合、クライアント認証を行うことが可能です。

クライアント認証についての仕様は、RFC7591 で定義されています。クライアント認証は、大きく以下の方法が存在します。

- シークレットを用いた認証
- 署名を用いた認証

この本では、シークレットを用いた認証について解説します。

### client_secret_basic

**client_secret_basic** は、クライアント認証のために、クライアントがリクエストヘッダにシークレットを含める方法です。

まずクライアントは、`client_id` と `client_secret` をコロンで連結し、Base64 エンコードします。その後、リクエストの `Authorization` ヘッダに `Basic {Base64エンコードしたclient_idとclient_secret}` を含めることで、認可サーバにクライアントのシークレットを伝え、クライアント認証を行います。

![](/images/5e8da6c491e720/2024-09-26-21-21-51.png)

基本的には、こちらの方法が推奨されています。また、認可サーバはこの方式をサポートしないといけないことが規定されています。

> 認可サーバーは, クライアントパスワードを発行されたクライアントの認証の為に HTTP Basic 認証スキームをサポートしなければならない (MUST). ^[http://openid-foundation-japan.github.io/rfc6749.ja.html#client-password]

### client_secret_post

**client_secret_post** は、クライアント認証のために、クライアントがリクエストボディにシークレットを含める方法です。

アクセストークンをリクエストする際に、リクエストパラメータに `client_id` と `client_secret` を含めることで、認可サーバにクライアントのシークレットを伝え、クライアント認証を行います。

こちらの方法は非推奨となっており、HTTP Basic 認証が利用できないクライアントである場合に限り使用することができると規定されています。

> 2 つのパラメーターを使ってクライアントクレデンシャルをリクエストボディーに含めることは推奨されていない (NOT RECOMMENDED). この方法は HTTP Basic 認証スキーム (もしくは他のパスワードベースの HTTP 認証スキーム) が直接利用できないクライアントに限定すべきである (SHOULD). ^[http://openid-foundation-japan.github.io/rfc6749.ja.html#client-password]

# Public Client の場合

先ほど言及した Public Client の場合は、どうなるのでしょうか？

Public Client では原理上、クライアントしか知り得ない情報を安全に保存できないため、クライアント認証を安全に行うことができません。

リバースエンジニアリングでクライアントを解析し、クライアントしか知り得ないはずの情報を解析してしまえば、なりすましが簡単に行えてしまいます。

![](/images/5e8da6c491e720/2024-09-26-21-19-30.png)

Public Client の場合はそもそもクライアント認証の信用性がなく意味がないので、クライアント認証を行わないことが一般的です。

その代わり、後述する **PKCE** を用いることで、ある程度ではありますが、脅威への対処が可能です。

参考リンク
https://qiita.com/TakahikoKawasaki/items/63ed4a9d8d6e5109e401
