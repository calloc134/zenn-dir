---
title: "クライアントの種類の違い"
---

# クライアントの種類の違い

この章では、OAuth クライアントの種類である **Confidential Client** と **Public Client** の違いについて詳しく解説します。

## 概要

OAuth クライアントには、大きく分けて 2 つの種類があります。

| 種類                    | 説明                                                     |
| ----------------------- | -------------------------------------------------------- |
| **Confidential Client** | クライアントシークレットを安全に保管できるクライアント   |
| **Public Client**       | クライアントシークレットを安全に保管できないクライアント |

> 認可サーバーと安全に認証でき, その登録済みクライアントクレデンシャルの機密性を維持できるクライアント (例えば, クライアントクレデンシャルへのアクセスが制限されたセキュアサーバー上に実装されたクライアント) は "confidential" クライアントである.
>
> — [RFC 6749](https://www.rfc-editor.org/rfc/rfc6749)

## Confidential Client と Public Client の違い

### 本質的な違い

両者の違いを一言で表すと：

> **アクセストークン引き換えリクエストを行う際に、サーバサイドで動作しているかどうか**

技術的に言えば：

| 種類                | アクセストークン引き換えの実行場所 | クライアント認証 |
| ------------------- | ---------------------------------- | ---------------- |
| Confidential Client | サーバサイド                       | 可能             |
| Public Client       | ユーザデバイス上                   | 不可能           |

### なぜ Public Client はクライアント認証ができないのか

Public Client では、クライアントのソースコードがユーザのデバイス上で動作します。

- ブラウザの開発者ツールでソースコードを確認できる
- モバイルアプリをリバースエンジニアリングできる
- 埋め込まれた `client_secret` を取得できてしまう

そのため、Public Client では `client_secret` による認証に意味がなく、クライアント認証は行いません。

## どのようなアプリケーションが該当するか

### Confidential Client の例

- **サーバサイドで動作する Web アプリケーション**

  - Rails、Django、Express などで構築された従来型の Web アプリ
  - アクセストークンの取得処理がサーバサイドで行われる

- **サーバサイドで動作する API サーバ**
  - バックエンド API サーバがトークン取得を担当する場合

### Public Client の例

- **サーバ API のないシングルページアプリケーション（SPA）**

  - フロントエンドのみで動作する SPA
  - バックエンド API が存在しない、または OAuth 処理に関与しない

- **サーバ API のないネイティブモバイルアプリケーション**

  - iOS、Android のネイティブアプリ
  - バックエンド API が存在しない場合

- **サーバ API のないデスクトップアプリケーション**
  - Electron アプリなど

## サーバ API がある場合の判断

**SPA + バックエンド API サーバ**の構成は、少し判断が複雑です。

ポイントは「**アクセストークンリクエストがどこで行われるか**」です。

### パターン 1：SPA がトークンを取得（Public Client）

```
SPA ─(認可コード)→ 認可サーバ ─(アクセストークン)→ SPA
```

- SPA がアクセストークンリクエストを行う
- **Public Client** として扱う

### パターン 2：バックエンド API がトークンを取得（Confidential Client）

```
SPA ─(認可コード)→ バックエンド API ─(認可コード)→ 認可サーバ ─(アクセストークン)→ バックエンド API
```

- バックエンド API がアクセストークンリクエストを行う
- **Confidential Client** として扱う
- アクセストークンはバックエンド API が保持し、SPA には露出しない

### 推奨されるパターン

可能な限り、**パターン 2（Confidential Client）** を採用することが推奨されます。

理由：

- アクセストークンがユーザデバイス上（フロントチャネル）に露出しない
- アクセストークンはサーバ間通信（バックチャネル）でのみやり取りされる
- クライアント認証により、セキュリティが向上する

## Public Client のセキュリティ対策

Public Client ではクライアント認証ができないため、他の方法でセキュリティを確保する必要があります。

### PKCE の必須化

Public Client では、**PKCE は必須**と考えるべきです。

- クライアント認証の代わりに、フローの一貫性を保証
- 認可コードが漏洩しても、アクセストークンの取得を防止

### リダイレクト URI の厳格な管理

- 完全一致検証を徹底
- ネイティブアプリでは HTTP URL スキームの利用を検討

### アクセストークンの有効期限を短く

- 漏洩のリスクを軽減
- リフレッシュトークンを活用

## まとめ

| 項目             | Confidential Client         | Public Client         |
| ---------------- | --------------------------- | --------------------- |
| トークン取得場所 | サーバサイド                | ユーザデバイス上      |
| クライアント認証 | ✅ 可能                     | ❌ 不可能             |
| client_secret    | 使用する                    | 使用しない            |
| PKCE             | 推奨                        | **必須**              |
| 例               | Rails アプリ、Django アプリ | SPA、ネイティブアプリ |

- OAuth クライアントには **Confidential Client** と **Public Client** の 2 種類がある
- クライアントの種類は「**アクセストークン取得がどこで行われるか**」で決まる
- 可能な限り **Confidential Client** として実装することを推奨
- Public Client では **PKCE が必須**

---

## おわりに

このブックでは、OAuth 2.0 の基礎から実践的なセキュリティ対策までを解説しました。

OAuth/OIDC は、現代の Web サービスやアプリケーションにおいて欠かせない技術です。「なんとなく」ではなく、仕組みを理解した上で実装することで、より安全なサービスを構築できます。

さらに学習を深めたい方は、以下の仕様書を参照してください：

- [RFC 6749 - The OAuth 2.0 Authorization Framework](https://www.rfc-editor.org/rfc/rfc6749)
- [RFC 7636 - PKCE](https://www.rfc-editor.org/rfc/rfc7636)
- [RFC 9700 - OAuth 2.0 Security Best Current Practice](https://www.rfc-editor.org/rfc/rfc9700)
- [OpenID Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html)

OAuth/OIDC の世界は奥深く、このブックで扱えなかった応用的なトピックもたくさんあります。

- OIDC の ID トークンと認証フロー
- Sender-Constrained Token（DPoP、mTLS）
- 公開鍵暗号を用いたクライアント認証
- など

これらについては、また別の機会に解説できればと思います。

お読みいただき、ありがとうございました。
