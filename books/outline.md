おおよその目次と、解説したいポイントを箇条書きでまとめたもの。

## 1. はじめに

- このブックについて
  - OAuth 2.0/2.1 と OIDC(OpenID Connect)の基礎をしっかり学ぶことを目的とした書籍
  - OAuth/OIDC の基本概念、フロー、セキュリティ対策などを丁寧に解説
  - OAuth/OIDC をなんとなく理解している人が、しっかり理解できるようになることを目指す
- このブックで学べること
  - OAuth 2.0/2.1 と OIDC の基本概念と目的の違い
  - OAuth フローに必要となる主要な概念と登場人物
  - OAuth 認可コードフローの詳細な仕組み
  - OAuth フローに対する代表的な攻撃手法とその防御方法
  - OIDC の基本的な仕組みと特徴
  - OIDC フローに対する代表的な攻撃手法とその防御方法
- 対象読者
  - OAuth/OIDC の基礎をしっかり学びたいエンジニア、セキュリティ担当者
  - OAuth/OIDC を利用するサービスの開発者、運用者
  - OAuth/OIDC のセキュリティ対策に関心のある人
- このブックの進め方
  - OAuth/OIDC には、多くの前提が登場する
  - 最初からすべてを理解することは不可能であると強調
  - 簡単な例をしっかり踏み固めて理解してから、理解を広げていく方法に尽きる
  - 最初は認可コードフロー + confidential client を前提に解説
  - その後、Public Client や PKCE などの防御機構を追加していく
  - また、他のフローに関しても十分な準備が整ってから解説する
  - OAuth が万全になってから OIDC に進むことをご了承いただきたい
- 参考にする仕様
  - (省略)

## 2. OAuth と OIDC の概要と目的の違い

- OAuth とは
  - OAuth とはリソースの所有者がリソースへのアクセス権を第三者に与える仕組みであることを説明
  - 具体例 → アルバムサービス(Google Photo)
- OIDC とは
  - OIDC とは、ユーザの本人確認とプロフィール情報の取得を行うための仕組みであることを説明
  - 具体例 → Google アカウントでのログイン
  - OIDC は OAuth の上に構築されていることを説明
- 目的の違い

  - 目的は全く異なるユースケース
  - OAuth → リソースに対する認可 を目的とする
  - OIDC → ユーザの本人確認(認証) を目的とする
  - 余談: OAuth をそのまま認証に転用してはいけない OAuth 認証の禁止 (理由は後述)

- しかし技術的には"追加レイヤ"であることを説明

  - OIDC とは OAuth の上に構築された追加レイヤであることを説明
  - OIDC の仕様だからといってすべて認可である、とははっきりと切り分けられないことに言及
    (後述するが、/userinfo エンドポイントは明らかに認可の役割を持つ)
  - OIDC 側で発祥した仕様が OAuth 側に逆輸入されることもあることに言及
  - OIDC を理解するためには OAuth の理解が必要であると主張

## 3. OAuth に必要な概念

- 概要
  - リソース認可とは、リソースの所有者が、リソースへのアクセスを第三者に許可することであることを説明
  - 必要な概念を順に説明していくことを明示
- リソースにアクセスするために必要なクレデンシャル(アクセストークン)の概念

  - アクセストークンとは、リソースアクセスのための鍵
  - この鍵を持っていれば、誰でもリソースにアクセスできる
    - 一般的なアクセストークンでは、鍵の利用者を検証はしない
    - 一度漏洩すると、誰でもリソースにアクセスできてしまう
    - だからこそ、鍵の管理は非常に重要
    - 鍵の有効期限は短い方が良い
  - 余談: アクセストークンの形式には二種類あることを説明 (後述)
  - 余談 2: 近年ではアクセストークンの利用者を検証する仕組みが増えてきていることに言及 (MTLS, DPoP)
    - この場合、一般的なアクセストークンはベアラートークンと呼ばれる
    - それに対し、アクセストークンの利用者を検証する仕組みを持つアクセストークンは
      sender-constrained token と呼ばれる
      詳しくは応用編で後述

- スコープとは何か

  - リソースのアクセス権の範囲を指定する仕組み
    - スペース区切りの文字列で複数指定可能
    - 具体例 → Google Photos API のスコープ例
  - もし自分でスコープを設計するときに考えておきたいこと
    - 各サービスのドメイン知識に依存
    - 最小責任の原則
    - 単純リソースであれば、読み取り/書き込み での分離
    - 複雑なリソースであれば、リソース × 操作 での分離

## 4. OAuth の登場人物

- 概要

  - OAuth の登場人物(ロール)を説明することを明示
  - リソース認可に関連する人物をとりあえず列挙

    - リソースの持ち主
    - リソースを管理している保管庫
    - 保管庫へのアクセスを管理している認可局
    - リソースにアクセスする第三者

  - ここでは Google Photos を例に説明することを明示

    - リソースの持ち主は Google Photos に画像を保存しているユーザ
    - 第三者である印刷サービスに、保管庫上にある自分の写真へアクセスできるよう、
      Google 認可局に許可を与える

  - リソースオーナー

    - リソースの持ち主
    - Google Photos に画像を保存しているユーザ
    - 認可局に許可を与える主体

  - リソースサーバ

    - リソースオーナーの持つリソースを管理している保管庫
    - アクセストークンを検証し、アクセストークンが有効であればリソースへのアクセスを許可する

  - 認可サーバ
    - 保管庫へのアクセスを管理している認可局
    - リソースオーナーからの許可を得て、アクセストークンを発行する
  - クライアント

    - リソースにアクセスする第三者
    - 印刷サービスなど、リソースオーナーに代わってリソースにアクセスするアプリケーション
    - リソースオーナーから許可を得て、認可サーバからアクセストークンを取得し
      保管庫のリソースにアクセス

  - まとめ

    - 4 つの登場人物の関係性を図示して説明

  - ※余談: OAuth クライアント の種類

    - OAuth "クライアント" という名前が付いているが、
    - OAuth クライアント であってもサーバサイドで動作することはある
    - (むしろそちらの方が好ましい) ことを説明
    - 「クライアント」という呼称で混同されがちだが、
    - OAuth クライアント はあくまで OAuth フローにおける役割(ロール)であることを強調

    - OAuth には confidential/public が存在することを明示
    - とりあえず簡単のため confidential で進めることを明言
    - public client については後述として伏線とする
    - confidential client の場合、サーバサイドで動作
    - Rails のような昔ながらの MPA を想定する

## 5. OAuth コードフローの簡易的解説

- 概要
  - OAuth の代表的なフローである認可コードフローについて簡易的に解説することを明示
  - confidential client を前提とすることを再度明示
- フローに登場するクレデンシャル

  - アクセストークン
    - 解説済みなので飛ばす
  - 認可コード
    - アクセストークンを引き換えるための一時的なトークン
    - 一度使うと無効になる
    - 多くの場合、有効期限の短い方が好ましい
    - 直接アクセストークンを受け取るのではなく
      認可コードを経由してアクセストークンを受け取ることで
      セキュリティを向上させることができる

- フローの流れ
  - (元記事を参照)
- まとめ
  - 最終的にクライアントがアクセストークンを取得して、フローは終了することを説明
  - 認可コードを挟むことで煩雑になってると感じるかもしれないが
  - セキュリティ向上のために必要なステップであることを強調
- 余談: 認可コードフロー以外のフロー

  - インプリシットフローが存在することを説明
    - セキュリティ上の理由で非推奨となったことに言及
    - とりあえず簡単のため、ここからの解説は認可コードフローで進行
    - implicit flow の詳細と非推奨理由については後述
    - インプリシットフローの非推奨化の話を通して
    - 認可コードを挟むことの重要性もわかるようになることを説明

## 6. アクセストークンの形式

- 概要

  - OAuth におけるアクセストークンの形式について解説することを明示
  - OAuth 自体はアクセストークンの形式を規定していないことを説明
  - そのため、サービスによってアクセストークンの形式が異なることを説明

- アクセストークンの形式の種類

  - アクセストークンには大きく分けて二種類の形式が存在することを説明 (RFC6819 セクション 3.1)
    - Handle 式 トークン
      - ランダム文字列からなる不透明 (opaque) なトークン
      - 認可サーバの内部データを参照するキーとして機能する
      - opaque トークンとも呼ばれる
      - ランダム文字列であるため、トークンから情報を読み取ることはできない
    - Assertion 式 トークン
      - トークンそのものに意味があり、解析が可能なトークン
      - JWT(JSON Web Token) が代表例
      - トークンを解析することで、トークンの発行者、有効期限、スコープなどの情報を取得できる
      - 電子署名を持ち、改ざん検知が可能
  - それぞれのメリットとデメリット

    - Handle 式 トークン

      - メリット

        - トークンが漏洩しても、認可サーバ側で無効化が容易い
        - データは認可サーバ側で一元管理されるため
        - サーバ側のデータ変更を即座に反映できる

      - デメリット
        - リソースサーバがアクセストークンの詳細を取得するために
        - 認可サーバに問い合わせる必要があり、パフォーマンスに影響が出る可能性

    - Assertion 式 トークン

      - メリット

        - リソースサーバが認可サーバに問い合わせることなく
          トークンの詳細情報を取得できるため、パフォーマンスが良い

      - デメリット
        - トークンが漏洩した場合、認可サーバ側で無効化が難しい
        - トークンに含まれる情報が古くなる可能性がある
        - 失効の実装が難しいため
        - アクセストークンの有効期限を短く設定することで対処することが多い

- まとめ

  - OAuth 自体はアクセストークンの形式を規定していないため、
    どちらの形式を採用するかは実装者の自由であることを強調

## 7. クライアント登録と認証

- 概要

  - OAuth におけるクライアント登録と認証について解説することを明示
  - 簡易フローにおいて、一つ抜けている点が
  - トークン引き換えリクエストの際に、
  - リクエスト元が正当なクライアントであるかを認可サーバが確認しないといけない点
  - そのために、クライアント登録と認証が必要であることを説明
  - ここでは confidential client を前提とすることを再度明示

- クライアント認証の手法の種類
  - クライアント認証には大きく分けて 2 つの方法が存在
  - 共有シークレット方式・公開鍵暗号方式
    - 公開鍵暗号方式については応用編として後述
    - とりあえずここでは共有シークレット方式を説明
- クライアント登録の流れ
  - OAuth のベースとなる仕様では、特にクライアント登録の方法を規定していないことを説明
  - クライアントアプリケーションの開発者が
    認可サーバのダッシュボード画面などから登録を行うことが一般的である
    - 余談だが、RFC7591/RFC7592 でクライアント登録の仕様が定義されていることにも言及
  - 何らかの手段でクライアント登録を行うと、
    認可サーバからクライアント ID とクライアントシークレットが発行される (confidential client の場合)
    - client_id: クライアントを一意に識別するための ID
    - client_secret: クライアント認証のための秘密情報
- クライアント認証の流れ
  - リソースオーナーは、認可リクエスト時に、クライアント ID をリクエストパラメータとして渡す
  - クライアントは、トークン引き換えリクエスト時に、クライアント認証情報として
  - 何らかの方法で以下の情報を認可サーバに渡す
    - client_id: クライアント ID
    - client_secret: クライアントシークレット
  - 渡し方について二種類
    - HTTP Basic 認証方式 (推奨) `client_secret_basic`
    - リクエストボディ方式 (非推奨) `client_secret_post`
    - 前者のみ解説
  - `client_secret_basic` の場合
    - client_id と client_secret をコロン`:`で連結し、Base64 エンコードする
    - HTTP の Authorization ヘッダに `Basic {Base64エンコードした文字列}` を設定する
    - 認可サーバはこれをデコードし、クライアント認証を行う
- まとめ
  - クライアント登録と認証は、OAuth フローにおいて重要なステップであることを強調
  - クライアント認証を適切に実装することで
  - 不正なクライアントによるアクセストークンの取得を防止できることを説明
- 余談: 共有シークレットでの認証のリスク

  - 共有シークレットは漏洩リスクがあることを説明
  - そのため、公開鍵暗号を用いたクライアント認証方式の需要が高まっている
  - 公開鍵暗号方式については応用編として後述することを明示

- 余談: Public Client の場合

  - Public Client ではクライアント認証を行わないことを軽く明記

## 8. ここまでの詳細フロー 解説 (confidential client)

- 概要
  - ここまでの知識を元に、詳細なコードフロー解説を行うことを明示
  - (つまり、防御機構は抜きのフロー)
  - ここでは confidential client を前提とすることを再度明示
- フローの流れ
  - (省略)
- まとめ
  - ここまでの内容を踏まえ、詳細なコードフローを理解できたことを強調

## 9. OAuth フローに対する攻撃と防御

- 概要
  - OAuth 認可コードフローに対する代表的な攻撃手法とその防御方法について解説することを明示
- 認可コードフローに対する攻撃にはどのようなものがあるか
  - OAuth 認可コードフローでは
    - 認可コードリクエスト
    - アクセストークンリクエスト
  - の 2 箇所で攻撃が発生しうることを説明
  - そのため
    - 認可コードを不正に取得する攻撃
    - 認可コードを用いてアクセストークンを不正に取得する攻撃
  - の 2 つのカテゴリに分類できることを説明
  - その他、認可コードを押し付ける攻撃も存在することに言及
  - 次のセクション以降で、具体的な攻撃手法と防御方法を解説することを明示
- まとめ
  - OAuth フローに対する攻撃手法と防御方法を理解することで
    より安全な OAuth 実装が可能になることを強調

## 10. 認可コードを不正に取得する攻撃と防御

- 概要
  - 認可コードを不正に取得する攻撃手法とその防御方法について解説することを明示
- redirect_uri オープンリダイレクトによる認可コード奪取攻撃
  - 攻撃の概要
    - リダイレクト URI の値を書き換えることで
    - 攻撃者が用意したリダイレクト先に認可コードを送らせる
    - 認可コードを奪取する攻撃手法であることを説明
    - 攻撃の流れを提示
      - (省略)
  - 攻撃の対策
    - redirect_uri 完全一致による防御方法を説明
      - クライアント登録時に登録された redirect_uri に
      - 完全に一致するものしか受け付けないようにする
    - 解釈の余地のある部分を排除することで悪用を禁止することを強調
    - この対策によって、攻撃を防止できることを流れで提示
      - (省略)
- まとめ
  - redirect_uri オープンリダイレクトにより認可コードを奪取する攻撃の例と、その防御方法を理解した
- 余談
  - public client では他にも認可コードを奪取する攻撃手法が存在することに言及

## 11. 認可コードを用いてアクセストークンを不正に取得する攻撃と防御

- 概要
  - 認可コードを用いてアクセストークンを不正に取得する攻撃手法とその防御方法について解説することを明示
- 認可コードすり替え攻撃
  - 攻撃の概要
    - 攻撃者が認可コードを奪取した後に行う攻撃
    - 攻撃者が正規クライアントのフロー中に
    - 認可コードを事前に奪取した認可コードにすり替えることで
    - 正規クライアントに攻撃者の持つ認可コードを用いて
    - アクセストークンを取得させる攻撃
    - 攻撃の流れを提示
      - (省略)
  - 攻撃の対策
    - PKCE (Proof Key for Code Exchange) による防御方法
      - リソースオーナーに認可コードを取得させるよう指示したクライアントと
      - アクセストークンを取得しようとするクライアントに
      - 一貫性があることを
      - 認可サーバが検証する仕組み
    - OAuth フロー開始時に
      - クライアントが code_verifier を生成し、セッションに保存
        - ここで言うセッションとは OAuth 特有の単語ではなく、
        - 一般的な Web アプリケーションにおけるセッションのコンテキストを指すことを明示
        - confidential client を前提としているため、サーバサイドセッション領域を想定
      - code_verifier をハッシュ化して code_challenge を生成
        - SHA-256 ハッシュ化を用いることが推奨される
        - 平文は非推奨
      - リソースオーナーを認可サーバにリダイレクトする際に code_challenge を渡す
      - リソースオーナーが認可コードリクエストを行う部分で
        - 認可サーバは発行した認可コードと code_challenge を紐付けて保存
      - クライアントは、リソースオーナーから認可コードを受け取った後に
        - セッションから code_verifier を取り出す
        - 認可サーバにアクセストークン引き換えリクエストを行う際に code_verifier を渡す
        - 認可サーバは code_verifier をハッシュ化し、紐付けられた code_challenge と比較検証
        - 一致した場合、アクセストークンを発行
        - 一致しない場合、アクセストークンの発行を拒否
      - この方式で何故攻撃を防止できるか？
        - PKCE はクライアントの一貫性を保証するもの
        - ハッシュ前の平文を知っているのは、フローを開始したクライアントのみである
        - よって、検証に成功した場合は
        - フローにおいてクライアントの一貫性を保証できる
        - 認可コードをすり替えた場合、
        - 実質的に別のクライアントセッションの認可コードを流用することになるため
        - 正当なフローの code_verifier を知らない
        - そのためクライアントの一貫性が保証できず、検証が失敗する
  - PKCE によって、攻撃を防止できることを流れで提示
    - (省略)
- まとめ
  - 認可コードを用いてアクセストークンを不正に取得する攻撃の例を理解した
  - PKCE とは フローにおけるクライアントの一貫性を検証する仕組みである
  - PKCE を導入することで、認可コードすり替え攻撃を防止できることを強調
  - PKCE パラメータを検証する主体は認可サーバであることを再度強調
- 余談
  - public client では他にも認可コードを用いてアクセストークンを不正に取得する攻撃手法が存在することに言及
- 余談 2
  - PKCE ではなく、トークンリクエスト時の`redirect_uri` 検証でも防御可能であることに言及
  - OAuth 2.0 では`redirect_uri` 検証も必須
  - しかし PKCE の方がより本質的な防御策である
  - より最新である OAuth 2.1 では PKCE が必須化されたため`redirect_uri` 検証は省略されている

## 12. 認可コードを押し付ける攻撃 (CSRF) と防御

- 概要
  - 認可コードを押し付ける攻撃手法(CSRF) とその防御方法について解説することを明示
- 認可コード押し付け攻撃(CSRF) 攻撃の概要
  - 一言でいうと「リソース押し付け攻撃」
  - 攻撃者が被害者のリソースオーナーに対して
  - 攻撃者が用意した認可コードを用いてフローを再開させることで
  - 被害者が攻撃者の持つリソースにアクセスできるアクセストークンを取得してしまう攻撃手法であることを説明
  - 何が問題？
    - 被害者は攻撃者のリソースにアクセスできるアクセストークンを取得してしまう
    - 攻撃者は被害者のリソースにアクセスできるわけではない
    - 被害者が攻撃者の持つリソースにアクセスしてしまう
    - 被害者が気が付かない場合、攻撃者のリソースにファイルをアップロードしてしまうことがある
      - その中に機密性の高い情報が含まれている場合、攻撃者に情報が漏洩してしまう可能性がある
      - (例: 攻撃者の Google Photos アルバムに、被害者が自分の免許証の写真をアップロードしてしまう)
  - 攻撃の流れを提示
    - (省略)
- 対策: state パラメータによる防御方法

  - state パラメータとは
    - クライアントが任意に設定できるランダム文字列
    - リソースオーナーに認可コードを取得させるよう指示したクライアントのセッションと
    - 認可コードを受け取ったクライアントのセッションに一貫性があることを
    - クライアント自身が検証するための仕組み
  - OAuth フロー開始時に

    - クライアントがランダム文字列を生成し、セッションに保存
      - ここで言うセッションとは OAuth 特有の単語ではなく、
      - 一般的な Web アプリケーションにおけるセッションのコンテキストを指すことを明示
      - confidential client を前提としているため、サーバサイドセッション領域を想定
    - リソースオーナーを認可サーバにリダイレクトする際に state パラメータを渡す
    - クライアントは、リソースオーナーから認可コードを受け取った後に
      - セッションから state パラメータを取り出す
      - 認可サーバから返された state パラメータと比較検証
      - 一致した場合、フローを継続
      - 一致しない場合、フローを中断
    - この方式で何故攻撃を防止できるか？

      - 被害者のフローは、クライアントが state パラメータを生成せずに
      - 攻撃者が用意した認可コードを押し付けられる形で開始される
      - よって、被害者のフローにおいて
      - クライアントは state パラメータを生成せず、セッションにも存在しない
      - そのため state パラメータの一致検証に失敗する

  - state パラメータによって、攻撃を防止できることを流れで提示
    - (省略)

- 実は state パラメータは 一般的な CSRF トークンと同じ役割
  - CSRF トークンとは
    - Web アプリケーションにおける CSRF 攻撃を防止するための仕組み
    - フォーム送信や重要な操作を行う際に
    - サーバがランダムなトークンを生成し、セッションに保存
    - サーバはフォームの hidden フィールドなどにトークンを埋め込み、ブラウザに送信
    - ブラウザはフォーム送信時にトークンをサーバに送信
    - サーバは受け取ったトークンとセッションに保存されているトークンを比較検証
    - 一致した場合、リクエストを受け付ける
    - 一致しない場合、リクエストを拒否
  - 一方 state パラメータ は
    - OAuth フローにおける CSRF 攻撃を防止するための仕組み
    - OAuth フロー開始時に
    - クライアントがランダムな文字列を生成し、セッションに保存
    - クライアントはリソースオーナーを認可サーバにリダイレクトする際に
    - リソースオーナーのブラウザに state パラメータを渡す
    - リソースオーナーのブラウザは認可コードリクエスト時に state パラメータを認可サーバに送信
    - クライアントは受け取った state パラメータとセッションに保存されている state パラメータを比較検証
    - 一致した場合、フローを継続
    - 一致しない場合、フローを中断
  - state パラメータと CSRF トークンの類似点
    - どちらもセッションの一貫性を検証する仕組みである
    - ランダムな文字列を生成し、セッションに保存
    - リクエストに含め、その後の処理で検証を行う
    - 一致しない場合、リクエストを拒否する
  - state パラメータは OAuth フローにおける CSRF トークンであることを強調
  - その意図もあり、state の仕様では 「ブラウザセッションに紐づく値」と強調されている
- まとめ
  - 認可コード押し付け攻撃(CSRF) の例を理解した
  - state パラメータとは フローにおけるクライアントの一貫性を検証する仕組みである
  - state パラメータを導入することで、認可コード押し付け攻撃(CSRF)を防止できることを強調
  - state パラメータの検証はクライアントが行うものことを再度強調

## 13. ここまでの完全版コードフロー 解説 (confidential client)

- 概要
  - ここまでの知識を元に、完全版のコードフロー解説を行うことを明示
  - (つまり、防御機構込みのフロー)
  - ここでは confidential client を前提とすることを再度明示
- フローの流れ
  - (省略)
- まとめ
  - ここまでの内容を踏まえ、完全版のコードフローを理解できたことを強調

## 14. リフレッシュトークンとそのフロー

## 15. クライアントの種類の違い

- 概要
  - OAuth クライアントの種類の違いについて解説することを明示
  - confidential client と public client の違いを説明
- confidential client と public client の違い
  - confidential client
    - 本来の定義は、
    - クライアントシークレットを安全に保管できるクライアント
    - 技術的には、アクセストークン引き換えリクエスト時に
    - サーバサイドで動作しているクライアント
    - クライアント認証の意義があり、行うことができる
  - public client
    - 本来の定義は、クライアントシークレットを安全に保管できないクライアント
    - 技術的には、アクセストークン引き換えリクエスト時に
    - ブラウザやモバイルアプリなど、ユーザーデバイス上で動作しているクライアント
    - クライアント認証を行うことができない
- どのようなアプリケーションが該当するか
  - confidential client の例
    - サーバサイドで動作する Web アプリケーション (例: Rails, Django)
    - サーバサイドで動作する API サーバ
  - public client の例
    - サーバ API のないシングルページアプリケーション (SPA)
    - サーバ API のないネイティブモバイルアプリケーション (iOS, Android)
    - サーバ API のないデスクトップアプリケーション
  - サーバ API のあるアプリケーションの場合
    - この場合は少し複雑であることに注意
    - アクセストークンリクエストがサーバサイドで行われる場合は confidential client
    - アクセストークンリクエストがユーザーデバイス上で行われる場合は public client
    - 例えば、SPA + バックエンド API サーバの構成の場合
      - SPA 側でアクセストークンリクエストを行う場合は public client
      - バックエンド API サーバ側でアクセストークンリクエストを行う場合は confidential client
    - confidential client の場合は、
    - アクセストークンがサーバ間通信(バックチャネル)で受け渡され、
    - ユーザーデバイス上(フロントチャネル)に
    - アクセストークンが露出しないことが重要
    - もし SPA やモバイルアプリの開発を行う場合は、
    - 可能な限りアクセストークンリクエストをサーバサイドで行い、
    - confidential client として実装することを推奨
- まとめ
  - OAuth クライアントには confidential client と public client の 2 種類があることを強調
  - クライアントの種類に応じて、実装やセキュリティ対策が異なることを理解することが重要であることを説明
  - ここからは、public client の場合の解説を行うことを明示

## 16. 認可コードを不正に取得する攻撃と防御 (public client 編)

- 概要
  - 認可コードを不正に取得する攻撃手法とその防御方法について解説することを明示
  - 今回は public client を対象とすることを明示
- カスタム URI スキームの悪用
  - 攻撃の概要
    - クライアントが public client でネイティブアプリの場合
    - リダイレクトで開かれるアプリが複数選択できる場合がある
      - 例: ブラウザにおいて、`myapp://`のような文字列から始まる URL を開いた時に
      - どのアプリで開くかを選択できる
    - この仕組みは便利だが、同じ URL であっても開くアプリが一意に決まらない場合がある
    - 攻撃者が悪意のあるアプリを用意し、被害者にインストールさせる
    - 被害者が認可リクエストを行い、認可サーバから認可コードが返される
    - リダイレクト URI が`myapp://callback`のような形式である場合
    - 被害者の端末で、悪意のあるアプリが選択されてしまうと
    - 認可コードが攻撃者に渡ってしまう
    - 余談: そもそもユーザ端末に悪意のあるアプリをインストールされていること自体が問題
      - 悪意あるアプリをインストールできた場合の
      - 横展開による被害拡大の手法のひとつとして考えることができる
  - 攻撃の流れ
    - (省略)
  - 攻撃の対策
    - 認可コードの奪取を防ぐという意味では
    - OAuth のフロー側で特に対策できるものはない
    - ネイティブアプリの場合、カスタム URL スキームの使用を避ける
      - 代わりに app-claimed HTTPS URI を利用
        - OS レベルで、
        - メイン所有者がホワイトリストしたアプリだけが
        - その https URL を受け取れるように検証必須とする仕組み
        - iOS では Universal Links
        - Android では App Links
        - 詳細な OS ごとの設定については
        - OAuth 範囲外なため、詳しくは外部記事を参照
    - ユーザ教育
      - 不審なアプリのインストールを避けるようにユーザに注意喚起する
    - もしくは、さらに後手で防御する
      - "認可コードを奪取する攻撃"が通っても
      - それをアクセストークンに交換できないようにすればいいとする考え
        - PKCE の利用

## 17. 認可コードを用いてアクセストークンを不正に取得する攻撃と防御 (public client 編)

- 概要
  - 認可コードを用いてアクセストークンを不正に取得する攻撃手法とその防御方法について解説することを明示
  - 今回は public client を対象とすることを明示
- 偽装クライアントによるアクセストークン取得攻撃
  - 攻撃の概要
    - 攻撃者が認可コードを奪取した後に行う攻撃
    - 攻撃者がクライアントアプリを偽装し
    - 攻撃者が事前に被害者から奪取した認可コードを用いて
    - アクセストークンを取得する攻撃
    - public client ではクライアントシークレットを安全な形で保持できないため
    - クライアント認証が不可能であり、存在しない
    - クライアント認証がないことにより、
    - クライアント偽装が技術的に可能である点を強調
  - 攻撃の流れを提示
    - (省略)
  - この方式で何故攻撃を防止できるか？
    - PKCE はクライアントの一貫性を保証するもの
    - 攻撃者が認可コードを取得したとしても
    - 認可コードに対応する code_verifier を知らない
    - そのためクライアントの一貫性が保証できず、検証が失敗する
  - PKCE によって、攻撃を防止できることを流れで提示
    - (省略)
- まとめ
  - public client の場合においては、クライアントを偽装して
  - アクセストークンを不正に取得する攻撃が可能であり、例を理解した
  - PKCE の一貫性保証の仕組みにより、この攻撃を防止できることを理解した

## 18. ここまでの完全版コードフロー 解説 (public client)

- 概要
  - ここまでの知識を元に、完全版のコードフロー解説を行うことを明示
  - (つまり、防御機構込みのフロー)
  - ここでは public client を対象とすることを明示
- フローの流れ
  - (省略)
- 実質的な差分
  - 実質的な差分はクライアント認証の有無しかない
  - アクセストークンリクエスト時の
    - Authorization Header の省略 (public client では不要)
    - ボディの client_id (public client では必須)
  - のみ
- まとめ
  - ここまでの内容を踏まえ、完全版のコードフローを理解できたことを強調

## 19. インプリシットフローの解説と非推奨の理由

- 概要
- インプリシットフローの解説と、その非推奨の理由について説明することを明示
- インプリシットフローの解説
  - フローの流れ
    - フローとしては、認可コードを介さず
    - 認可レスポンス部分で直接アクセストークンを受け取る
    - 認可コードは一時トークンのようなものなので
    - それを介さない分、簡略化されたフローといえる
  - 具体的なフロー
    - (省略)
- インプリシットフローの問題点と非推奨の理由
  - 認可コードフローに対する攻撃は、以下の手順を踏む必要がある
    - 認可コードを奪取する
    - 奪取した認可コードを用いてアクセストークンを取得する
  - インプリシットフローでは、アクセストークンが直接フロントチャネルに露出する
  - そのため、以下の手順を踏むだけでアクセストークンを奪取できる
    - アクセストークンを奪取する
  - confidential client の場合、
    - アクセストークンはサーバ間通信でやり取りされるため
    - フロントチャネルに露出しない
    - つまり、ブラウザのようなユーザデバイス上で
    - アクセストークンを盗むことがほぼ不可能
  - そのほか、confidential/public client 問わず
    - アクセストークンに関連する以下の仕様が軒並み
    - インプリシットフローに対応していない
      - リフレッシュトークン (インプリシットフローの場合禁止される)
      - sender-constrained token などのアクセストークン強化仕様 (設計上組み込めない)
      - PKCE などのクライアント一貫性保証仕様 (認可コードフロー専用の機構)
    - フローが簡易的なため、セキュリティ強化機構を埋め込む余地がない
  - 実は、インプリシットフローが誕生したのは歴史的経緯
    - 昔のブラウザ特有は同一オリジン制約が厳しく
    - 認可コードフローを動作させられなかった
    - そのため簡易的なフローとしてインプリシットフローが考案された
    - しかし、現在では CORS の普及により
    - 認可コードフローをブラウザ上で動作させることが可能となった
    - そのため、インプリシットフローを使う必然性がなくなった
- 近年の評価
  - インプリシットフローはセキュリティ上の問題が多いため
  - 近年の多くの仕様で非推奨とされる
    - OAuth 2.0 Security BCP (RFC9700)
    - OAuth 2.1
      - OAuth 2.1 ではそもそも仕様から削除
- まとめ
  - インプリシットフローは簡略化されたフロー
  - フロントチャネルにアクセストークンが露出する問題点
  - そのため、近年の仕様では非推奨・削除されている
  - 余談: OAuth を認証に転用した場合
    - インプリシットフローの被害は更に拡大する
    - 詳細は後述

## 20. OAuth まとめと OAuth 2.1 の紹介

- OAuth まとめ
  - OAuth の基本的な仕組みとフローを理解したことを強調
  - 認可コードフローの詳細な流れとセキュリティ対策を理解したことを強調
- OAuth 2.1 の紹介
  - IETF OAuth WG が策定中のドラフト
  - OAuth 2.0 本体とその拡張仕様群を統合し、最新のベストプラクティスを反映した仕様
  - 危険な選択肢を削ってシンプルにし、安全なやり方を必須化
- 主な変更点
  - インプリシットフロー・その他フローの削除
  - PKCE の必須化
  - リダイレクト URI の完全一致検証の必須化
  - public client におけるリフレッシュトークンの制約
  - トークンリクエスト時の`redirect_uri`パラメータ削除
    - PKCE で認可コードすり替え攻撃を防止できるため不要に
- まとめ
  - OAuth 2.1 は OAuth 2.0 の最新のベストプラクティスを反映した仕様であることを強調
  - 新規実装や既存実装の更新時には OAuth 2.1 を参考にすることを推奨
