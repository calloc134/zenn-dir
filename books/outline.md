おおよその目次と、解説したいポイントを箇条書きでまとめたもの。

## 1. はじめに

-

## 2. OAuth と OIDC の概要と目的の違い

- OAuth とは
  - OAuth とはリソースの所有者がリソースへのアクセス権を第三者に与える仕組みであることを説明
  - 具体例 → アルバムサービス(Google Photo)
- OIDC とは
  - OIDC とは、ユーザの本人確認とプロフィール情報の取得を行うための仕組みであることを説明
  - 具体例 → Google アカウントでのログイン
  - OIDC は OAuth の上に構築されていることを説明
- 目的の違い

  - 目的は全く異なるユースケース
  - OAuth → リソースに対する認可 を目的とする
  - OIDC → ユーザの本人確認(認証) を目的とする
  - 余談: OAuth をそのまま認証に転用してはいけない OAuth 認証の禁止 (理由は後述)

- しかし技術的には"追加レイヤ"であることを説明

  - OIDC とは OAuth の上に構築された追加レイヤであることを説明
  - OIDC の仕様だからといってすべて認可である、とははっきりと切り分けられないことに言及
    (後述するが、/userinfo エンドポイントは明らかに認可の役割を持つ)
  - OIDC 側で発祥した仕様が OAuth 側に逆輸入されることもあることに言及
  - OIDC を理解するためには OAuth の理解が必要であると主張

## 3. OAuth に必要な概念

- 概要
  - リソース認可とは、リソースの所有者が、リソースへのアクセスを第三者に許可することであることを説明
  - 必要な概念を順に説明していくことを明示
- リソースにアクセスするために必要なクレデンシャル(アクセストークン)の概念

  - アクセストークンとは、リソースアクセスのための鍵
  - この鍵を持っていれば、誰でもリソースにアクセスできる
    - つまり、鍵の利用者を検証はしない
    - 一度漏洩すると、誰でもリソースにアクセスできてしまう
    - だからこそ、鍵の管理は非常に重要
    - 鍵の有効期限は短い方が良い
  - 余談: アクセストークンの形式には二種類あることを説明 (後述)
  - 余談 2: 近年ではアクセストークンの利用者を検証する仕組みが増えてきていることに言及 (MTLS, DPoP) (後述)

- スコープとは何か

  - リソースのアクセス権の範囲を指定する仕組み
    - スペース区切りの文字列で複数指定可能
    - 具体例 → Google Photos API のスコープ例
  - もし自分でスコープを設計するときに考えておきたいこと
    - 各サービスのドメイン知識に依存
    - 最小責任の原則
    - 単純リソースであれば、読み取り/書き込み での分離
    - 複雑なリソースであれば、リソース × 操作 での分離

## 4. OAuth の登場人物

- 概要

  - OAuth の登場人物(ロール)を説明することを明示
  - リソース認可に関連する人物をとりあえず列挙

    - リソースの持ち主
    - リソースを管理している保管庫
    - 保管庫へのアクセスを管理している認可局
    - リソースにアクセスする第三者

  - ここでは Google Photos を例に説明することを明示

    - リソースの持ち主は Google Photos に画像を保存しているユーザ
    - 第三者である印刷サービスに、保管庫上にある自分の写真へアクセスできるよう、
      Google 認可局に許可を与える

  - リソースオーナー

    - リソースの持ち主
    - Google Photos に画像を保存しているユーザ
    - 認可局に許可を与える主体

  - リソースサーバ

    - リソースオーナーの持つリソースを管理している保管庫
    - アクセストークンを検証し、アクセストークンが有効であればリソースへのアクセスを許可する

  - 認可サーバ
    - 保管庫へのアクセスを管理している認可局
    - リソースオーナーからの許可を得て、アクセストークンを発行する
  - クライアント

    - リソースにアクセスする第三者
    - 印刷サービスなど、リソースオーナーに代わってリソースにアクセスするアプリケーション
    - リソースオーナーから許可を得て、認可サーバからアクセストークンを取得し
      保管庫のリソースにアクセス

  - まとめ

    - 4 つの登場人物の関係性を図示して説明

  - ※余談: OAuth クライアント の種類

    - OAuth "クライアント" という名前が付いているが、
    - OAuth クライアント であってもサーバサイドで動作することはある
    - (むしろそちらの方が好ましい) ことを説明
    - 「クライアント」という呼称で混同されがちだが、
    - OAuth クライアント はあくまで OAuth フローにおける役割(ロール)であることを強調

    - OAuth には confidential/public が存在することを明示
    - とりあえず簡単のため confidential で進めることを明言
    - public client については後述として伏線とする
    - confidential client の場合、サーバサイドで動作
    - Rails のような昔ながらの MPA を想定する

## 5. OAuth コードフローの簡易的解説

- 概要
  - OAuth の代表的なフローである認可コードフローについて簡易的に解説することを明示
  - confidential client を前提とすることを再度明示
- フローに登場するクレデンシャル

  - アクセストークン
    - 解説済みなので飛ばす
  - 認可コード
    - アクセストークンを引き換えるための一時的なトークン
    - 有効期限は短く、一度使うと無効になる
    - 直接アクセストークンを受け取るのではなく
      認可コードを経由してアクセストークンを受け取ることで
      セキュリティを向上させることができる

- フローの流れ
  - (元記事を参照)
- まとめ
  - 最終的にクライアントがアクセストークンを取得して、フローは終了することを説明
  - 認可コードを挟むことで煩雑になってると感じるかもしれないが
  - セキュリティ向上のために必要なステップであることを強調
- 余談: 認可コードフロー以外のフロー

  - インプリシットフローが存在することを説明
    - セキュリティ上の理由で非推奨となったことに言及
    - とりあえず簡単のため、ここからの解説は認可コードフローで進行
    - implicit flow の詳細と非推奨理由については後述
    - インプリシットフローの非推奨化の話を通して、認可コードを挟むことの重要性もわかるようになることを説明

## 6. アクセストークンの形式

- 概要

  - OAuth におけるアクセストークンの形式について解説することを明示
  - OAuth 自体はアクセストークンの形式を規定していないことを説明
  - そのため、サービスによってアクセストークンの形式が異なることを説明

- アクセストークンの形式の種類

  - アクセストークンには大きく分けて二種類の形式が存在することを説明 (RFC6819 セクション 3.1)
    - Handle 式 トークン
      - ランダム文字列からなる不透明 (opaque) なトークン
      - 認可サーバの内部データを参照するキーとして機能する
      - opaque トークンとも呼ばれる
      - ランダム文字列であるため、トークンから情報を読み取ることはできない
    - Assertion 式 トークン
      - トークンそのものに意味があり、解析が可能なトークン
      - JWT(JSON Web Token) が代表例
      - トークンを解析することで、トークンの発行者、有効期限、スコープなどの情報を取得できる
      - 電子署名を持ち、改ざん検知が可能
  - それぞれのメリットとデメリット

    - Handle 式 トークン

      - メリット

        - トークンが漏洩しても、認可サーバ側で無効化が容易い
        - データは認可サーバ側で一元管理されるため、情報が古くならない

      - デメリット
        - リソースサーバがアクセストークンの詳細を取得するために
          認可サーバに問い合わせる必要があり、パフォーマンスに影響が出る可能性

    - Assertion 式 トークン

      - メリット

        - リソースサーバが認可サーバに問い合わせることなく
          トークンの詳細情報を取得できるため、パフォーマンスが良い

      - デメリット
        - トークンが漏洩した場合、認可サーバ側で無効化が難しい
        - トークンに含まれる情報が古くなる可能性がある
        - 失効の実装が難しいため、アクセストークンの有効期限を短く設定することで対処することが多い

- まとめ

  - OAuth 自体はアクセストークンの形式を規定していないため、
    どちらの形式を採用するかは実装者の自由であることを強調

## 7. クライアント登録と認証

- 概要

  - OAuth におけるクライアント登録と認証について解説することを明示
  - 簡易フローにおいて、一つ抜けている点が
  - トークン引き換えリクエストの際に、
  - リクエスト元が正当なクライアントであるかを認可サーバが確認しないといけない点
  - そのために、クライアント登録と認証が必要であることを説明
  - ここでは confidential client を前提とすることを再度明示

- クライアント認証の手法の種類
  - クライアント認証には大きく分けて 2 つの方法が存在
  - 共有シークレット方式・高鍵鍵暗号方式
    - 公開鍵暗号方式については応用編として後述
    - とりあえずここでは共有シークレット方式を説明
- クライアント登録の流れ
  - OAuth のベースとなる仕様では、特にクライアント登録の方法を規定していないことを説明
  - クライアントアプリケーションの開発者が
    認可サーバのダッシュボード画面などから登録を行うことが一般的である
    - 余談だが、RFC7591/RFC7592 でクライアント登録の仕様が定義されていることにも言及
  - 何らかの手段でクライアント登録を行うと、
    認可サーバからクライアント ID とクライアントシークレットが発行される
    - client_id: クライアントを一意に識別するための ID
    - client_secret: クライアント認証のための秘密情報
- クライアント認証の流れ
  - 認可リクエスト時に、クライアント ID をリクエストパラメータとして渡す
  - トークン引き換えリクエスト時に、クライアント認証情報として以下のパラメータを渡す
    - client_id: クライアント ID
    - client_secret: クライアントシークレット
  - 渡し方について二種類
    - HTTP Basic 認証方式 (推奨) `client_secret_basic`
    - リクエストボディ方式 (非推奨) `client_secret_post`
    - 前者のみ解説
  - `client_secret_basic` の場合
    - client_id と client_secret をコロン`:`で連結し、Base64 エンコードする
    - HTTP の Authorization ヘッダに `Basic {Base64エンコードした文字列}` を設定する
    - 認可サーバはこれを復号し、クライアント認証を行う
- まとめ
  - クライアント登録と認証は、OAuth フローにおいて重要なステップであることを強調
  - クライアント認証を適切に実装することで
  - 不正なクライアントによるアクセストークンの取得を防止できることを説明
- 余談: 共有シークレットでの認証のリスク

  - 共有シークレットは漏洩リスクがあることを説明
  - そのため、公開鍵暗号を用いたクライアント認証方式の需要が高まっている
  - 公開鍵暗号方式については応用編として後述することを明示

- 余談: Public Client の場合

  - Public Client ではクライアント認証を行わないことを軽く明記

## 8. ここまでの詳細フロー 解説 (confidential client)

- 概要
  - ここまでの知識を元に、詳細なコードフロー解説を行うことを明示
  - (つまり、防御機構は抜きのフロー)
  - ここでは confidential client を前提とすることを再度明示
- フローの流れ
  - (省略)
- まとめ
  - ここまでの内容を踏まえ、詳細なコードフローを理解できたことを強調

## 9. OAuth フローに対する攻撃と防御

- 概要
  - OAuth フローに対する代表的な攻撃手法とその防御方法について解説することを明示
- 攻撃にはどのようなものがあるか
  - OAuth フローでは
    - 認可コードリクエスト
    - アクセストークンリクエスト
  - の 2 箇所で攻撃が発生しうることを説明
  - そのため
    - 認可コードを不正に取得する攻撃
    - 認可コードを用いてアクセストークンを不正に取得する攻撃
  - の 2 つのカテゴリに分類できることを説明
  - その他、認可コードを押し付ける攻撃も存在することに言及
  - 次のセクション以降で、具体的な攻撃手法と防御方法を解説することを明示
- まとめ
  - OAuth フローに対する攻撃手法と防御方法を理解することで
    より安全な OAuth 実装が可能になることを強調

## 10. 認可コードを不正に取得する攻撃と防御

- 概要
  - 認可コードを不正に取得する攻撃手法とその防御方法について解説することを明示
- オープンリダイレクトによる認可コード奪取攻撃
  - 攻撃の概要
    - リダイレクト URI の値を書き換えることで
    - 攻撃者が用意したリダイレクト先に認可コードを送らせる
    - 認可コードを奪取する攻撃手法であることを説明
    - 攻撃の流れを提示
      - (省略)
  - 攻撃の対策
    - redirect_uri 完全一致による防御方法を説明
      - クライアント登録時に登録された redirect_uri に
      - 完全に一致するものしか受け付けないようにする
    - 解釈の余地のある部分を排除することで悪用を禁止することを強調
    - この対策によって、攻撃を防止できることを流れで提示
      - (省略)
- まとめ
  - オープンリダイレクトにより認可コードを奪取する攻撃の例と、その防御方法を理解した
- 余談
  - public client では他にも認可コードを奪取する攻撃手法が存在することに言及

## 11. 認可コードを用いてアクセストークンを不正に取得する攻撃と防御

- 概要
  - 認可コードを用いてアクセストークンを不正に取得する攻撃手法とその防御方法について解説することを明示
- 認可コードすり替え攻撃
  - 攻撃の概要
    - 攻撃者が正規クライアントのフロー中に認可コードをすり替えることで
    - 正規クライアントが攻撃者の持つ認可コードを用いてアクセストークンを取得してしまう攻撃手法であることを説明
    - 攻撃の流れを提示
      - (省略)
  - 攻撃の対策
    - PKCE (Proof Key for Code Exchange) による防御方法
      - リソースオーナーに認可コードを取得させるよう指示したクライアントと
      - アクセストークンを取得しようとするクライアントに
      - 一貫性があることを
      - 認可サーバが検証する仕組み
    - OAuth フロー開始時に
      - クライアントが code_verifier を生成し、セッションに保存
        - ここで言うセッションとは OAuth 特有の単語ではなく、
        - 一般的な Web アプリケーションにおけるセッションのコンテキストを指すことを明示
        - confidential client を前提としているため、サーバサイドセッション領域を想定
      - code_verifier をハッシュ化して code_challenge を生成
        - SHA-256 ハッシュ化を用いることが推奨される
        - 平文は非推奨
      - リソースオーナーを認可サーバにリダイレクトする際に code_challenge を渡す
      - リソースオーナーが認可コードリクエストを行う部分で
        - 認可サーバは発行した認可コードと code_challenge を紐付けて保存
      - クライアントは、リソースオーナーから認可コードを受け取った後に
        - セッションから code_verifier を取り出す
        - 認可サーバにアクセストークン引き換えリクエストを行う際に code_verifier を渡す
        - 認可サーバは code_verifier をハッシュ化し、紐付けられた code_challenge と比較検証
        - 一致した場合、アクセストークンを発行
        - 一致しない場合、アクセストークンの発行を拒否
      - この方式で何故攻撃を防止できるか？
        - ハッシュ前の平文を知っているのは、フローを開始したクライアントのみである
        - よって、検証に成功した場合はフローにおいてクライアントの一貫性を保証できるとわかる
        - 認可コードをすり替えるというケースにおいて
        - 実質的に別のクライアントセッションの認可コードを流用することになるため
        - クライアントの一貫性が保証できず、検証に失敗する
  - PKCE によって、攻撃を防止できることを流れで提示
    - (省略)
- まとめ
  - 認可コードを用いてアクセストークンを不正に取得する攻撃の例を理解した
  - PKCE とは フローにおけるクライアントの一貫性を検証する仕組みである
  - PKCE を導入することで、認可コードすり替え攻撃を防止できることを強調
  - PKCE パラメータを検証する主体は認可サーバであることを再度強調
- 余談
  - public client では他にも認可コードを用いてアクセストークンを不正に取得する攻撃手法が存在することに言及

## 12. 認可コードを押し付ける攻撃 (CSRF) と防御

- 概要
  - 認可コードを押し付ける攻撃手法(CSRF) とその防御方法について解説することを明示
- 認可コード押し付け攻撃(CSRF) 攻撃の概要
  - 一言でいうと「リソース押し付け攻撃」
  - 攻撃者が被害者のリソースオーナーに対して
  - 攻撃者が用意した認可コードを用いてフローを再開させることで
  - 被害者が攻撃者の持つリソースにアクセスできるアクセストークンを取得してしまう攻撃手法であることを説明
  - 何が問題？
    - 被害者は攻撃者のリソースにアクセスできるアクセストークンを取得してしまう
    - 攻撃者は被害者のリソースにアクセスできるわけではない
    - 被害者が攻撃者の持つリソースにアクセスしてしまう
    - 被害者が気が付かない場合、攻撃者のリソースにファイルをアップロードしてしまうことがある
      - その中に機密性の高い情報が含まれている場合、攻撃者に情報が漏洩してしまう可能性がある
      - (例: 攻撃者の Google Photos アルバムに、被害者が自分の免許証の写真をアップロードしてしまう)
  - 攻撃の流れを提示
    - (省略)
- 対策: state パラメータによる防御方法

  - state パラメータとは
    - クライアントが任意に設定できるランダム文字列
    - リソースオーナーに認可コードを取得させるよう指示したクライアントのセッションと
    - 認可コードを受け取ったクライアントのセッションに一貫性があることを
    - クライアント自身が検証するための仕組み
  - OAuth フロー開始時に

    - クライアントがランダム文字列を生成し、セッションに保存
      - ここで言うセッションとは OAuth 特有の単語ではなく、
      - 一般的な Web アプリケーションにおけるセッションのコンテキストを指すことを明示
      - confidential client を前提としているため、サーバサイドセッション領域を想定
    - リソースオーナーを認可サーバにリダイレクトする際に state パラメータを渡す
    - クライアントは、リソースオーナーから認可コードを受け取った後に
      - セッションから state パラメータを取り出す
      - 認可サーバから返された state パラメータと比較検証
      - 一致した場合、フローを継続
      - 一致しない場合、フローを中断
    - この方式で何故攻撃を防止できるか？

      - 被害者のフローは、クライアントが state パラメータを生成せずに
      - 攻撃者が用意した認可コードを押し付けられる形で開始される
      - よって、被害者のフローにおいて
      - クライアントは state パラメータを生成せず、セッションにも存在しない
      - そのため state パラメータの一致検証に失敗する

  - state パラメータによって、攻撃を防止できることを流れで提示
    - (省略)

- 実は state パラメータは 一般的な CSRF トークンと同じ役割
  - CSRF トークンとは
    - Web アプリケーションにおける CSRF 攻撃を防止するための仕組み
    - フォーム送信や重要な操作を行う際に
    - サーバがランダムなトークンを生成し、セッションに保存
    - サーバはフォームの hidden フィールドなどにトークンを埋め込み、ブラウザに送信
    - ブラウザはフォーム送信時にトークンをサーバに送信
    - サーバは受け取ったトークンとセッションに保存されているトークンを比較検証
    - 一致した場合、リクエストを受け付ける
    - 一致しない場合、リクエストを拒否
  - 一方 state パラメータ は
    - OAuth フローにおける CSRF 攻撃を防止するための仕組み
    - OAuth フロー開始時に
    - クライアントがランダムな文字列を生成し、セッションに保存
    - クライアントはリソースオーナーを認可サーバにリダイレクトする際に
    - リソースオーナーのブラウザに state パラメータを渡す
    - リソースオーナーのブラウザは認可コードリクエスト時に state パラメータを認可サーバに送信
    - クライアントは受け取った state パラメータとセッションに保存されている state パラメータを比較検証
    - 一致した場合、フローを継続
    - 一致しない場合、フローを中断
  - state パラメータと CSRF トークンの類似点
    - どちらもセッションの一貫性を検証する仕組みである
    - ランダムな文字列を生成し、セッションに保存
    - リクエストに含め、その後の処理で検証を行う
    - 一致しない場合、リクエストを拒否する
  - state パラメータは OAuth フローにおける CSRF トークンであることを強調
  - その意図もあり、state の仕様では 「ブラウザセッションに紐づく値」と強調されている
- まとめ
  - 認可コード押し付け攻撃(CSRF) の例を理解した
  - state パラメータとは フローにおけるクライアントの一貫性を検証する仕組みである
  - state パラメータを導入することで、認可コード押し付け攻撃(CSRF)を防止できることを強調
  - state パラメータの検証はクライアントが行うものことを再度強調

## 13. ここまでの完全版コードフロー 解説 (confidential client)

- 概要
  - ここまでの知識を元に、完全版のコードフロー解説を行うことを明示
  - (つまり、防御機構込みのフロー)
  - ここでは confidential client を前提とすることを再度明示
- フローの流れ
  - (省略)
- まとめ
  - ここまでの内容を踏まえ、完全版のコードフローを理解できたことを強調


- リフレッシュトークンの紹介
- リフレッシュトークンフロー解説
