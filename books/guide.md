`5e8da6c491e720.md`
をベースにし、このブログの文章をある程度保持しながら、
books/sikkari-oauth-oidc 以下に zenn のブックとして再構築してください。

目次は以下の通りとする。

1. はじめに

-

2. OAuth と OIDC の概要と目的の違い

- OAuth とは
  - OAuth とはリソースの所有者がリソースへのアクセス権を第三者に与える仕組みであることを説明
  - 具体例 → アルバムサービス(Google Photo)
- OIDC とは
  - OIDC とは、ユーザの本人確認とプロフィール情報の取得を行うための仕組みであることを説明
  - 具体例 → Google アカウントでのログイン
  - OIDC は OAuth の上に構築されていることを説明
- 目的の違い

  - 目的は全く異なるユースケース
  - OAuth → リソースに対する認可 を目的とする
  - OIDC → ユーザの本人確認(認証) を目的とする
  - 余談: OAuth をそのまま認証に転用してはいけない OAuth 認証の禁止 (理由は後述)

- しかし技術的には"追加レイヤ"であることを説明

  - OIDC とは OAuth の上に構築された追加レイヤであることを説明
  - OIDC の仕様だからといってすべて認可である、とははっきりと切り分けられないことに言及
    (後述するが、/userinfo エンドポイントは明らかに認可の役割を持つ)
  - OIDC 側で発祥した仕様が OAuth 側に逆輸入されることもあることに言及
  - OIDC を理解するためには OAuth の理解が必要であると主張

3. OAuth に必要な概念

- 概要
  - リソース認可とは、リソースの所有者が、リソースへのアクセスを第三者に許可することであることを説明
  - 必要な概念を順に説明していくことを明示
- リソースにアクセスするために必要なクレデンシャル(アクセストークン)の概念

  - アクセストークンとは、リソースアクセスのための鍵
  - この鍵を持っていれば、誰でもリソースにアクセスできる
    - つまり、鍵の利用者を検証はしない
    - 一度漏洩すると、誰でもリソースにアクセスできてしまう
    - だからこそ、鍵の管理は非常に重要
  - 余談: アクセストークンには二種類あることを説明 (後述)

- スコープとは何か

  - リソースのアクセス権の範囲を指定する仕組み
    - スペース区切りの文字列で複数指定可能
    - 具体例 → Google Photos API のスコープ例
  - もし自分でスコープを設計するときに考えておきたいこと
    - 各サービスのドメイン知識に依存
    - 最小責任の原則
    - 単純リソースであれば、読み取り/書き込み での分離
    - 複雑なリソースであれば、リソース × 操作 での分離

4. OAuth 登場人物

- 概要

  - OAuth の登場人物(ロール)を説明することを明示
  - リソース認可に関連する人物をとりあえず列挙

    - リソースの持ち主
    - リソースを管理している保管庫
    - 保管庫へのアクセスを管理している認可局
    - リソースにアクセスする第三者

  - ここでは Google Photos を例に説明することを明示

    - リソースの持ち主は Google Photos に画像を保存しているユーザ
    - 第三者である印刷サービスに、保管庫上にある自分の写真へアクセスできるよう、
      Google 認可局に許可を与える

  - リソースオーナー

    - リソースの持ち主
    - Google Photos に画像を保存しているユーザ
    - 認可局に許可を与える主体

  - リソースサーバ

    - リソースオーナーの持つリソースを管理している保管庫
    - アクセストークンを検証し、アクセストークンが有効であればリソースへのアクセスを許可する

  - 認可サーバ
    - 保管庫へのアクセスを管理している認可局
    - リソースオーナーからの許可を得て、アクセストークンを発行する
  - クライアント

    - リソースにアクセスする第三者
    - 印刷サービスなど、リソースオーナーに代わってリソースにアクセスするアプリケーション
    - リソースオーナーから許可を得て、認可サーバからアクセストークンを取得し
      保管庫のリソースにアクセス

  - まとめ

    - 4 つの登場人物の関係性を図示して説明

  - ※余談: OAuth クライアント の種類

    - OAuth "クライアント" という名前が付いているが、
      OAuth クライアント であってもサーバサイドで動作することはある
      (むしろそちらの方が好ましい) ことを説明
    - 「クライアント」という呼称で混同されがちだが、
      OAuth クライアント はあくまで OAuth フローにおける役割(ロール)であることを強調

    - OAuth には confidential/public が存在することを明示
    - とりあえず簡単のため confidential で進めることを明言
      public client については後述として伏線とする
    - confidential client の場合、サーバサイドで動作
      Rails のような昔ながらの MPA を想定する

- OAuth 簡易フロー
  ここで認可コード/アクセストークンの解説
  ※余談: 認可コードフロー以外の他のフロー(implicit)が存在することを明示
  とりあえず簡単のため、ここからは認可コードフローで進行 implicit flow については後述として伏線とする

- アクセストークンの形式についての解説
  handle(opaque トークン)/assertion(JWT)について解説。
  それぞれの特性についても述べる

- クライアント登録/認証
  簡易フローを見て、リクエスト元が正しいクライアントであるかを認可サーバが確認しないといけないのでは？と気づかせる
  → クライアント登録- 認証の必要性に説得力をもたせる

- ここまでの知識を元に、state 抜き、pkce 抜きの詳細なコードフロー解説
  - 認可コードリクエスト/レスポンス、トークンリクエスト/レスポンス

(攻撃手法はとりあえず confidential でも発生しうるものに限定することに留意)

- 認可コード押し付け攻撃(CSRF) + state での防御
- 認可コード奪取攻撃(cofidential に限定)
  (リダイレクト URI 攻撃 + redirect_uri 完全一致での防御)
- 認可コード消費攻撃 + pkce での防御
  (認可コードインジェクション攻撃)

- リフレッシュトークンの紹介
- リフレッシュトークンフロー解説

- 完全版のコードフロー解説
  - 認可コードリクエスト/レスポンス、トークンリクエスト/レスポンス
