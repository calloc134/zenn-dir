`5e8da6c491e720.md`
をベースにし、このブログの文章をある程度保持しながら、
books/sikkari-oauth-oidc 以下に zenn のブックとして再構築してください。

目次は以下の通りとする。

1. はじめに

-

2. OAuth と OIDC の概要と目的の違い

- OAuth とは
  - OAuth とはリソースの所有者がリソースへのアクセス権を第三者に与える仕組みであることを説明
  - 具体例 → アルバムサービス(Google Photo)
- OIDC とは
  - OIDC とは、ユーザの本人確認とプロフィール情報の取得を行うための仕組みであることを説明
  - 具体例 → Google アカウントでのログイン
  - OIDC は OAuth の上に構築されていることを説明
- 目的の違い

  - 目的は全く異なるユースケース
  - OAuth → リソースに対する認可 を目的とする
  - OIDC → ユーザの本人確認(認証) を目的とする
  - 余談: OAuth をそのまま認証に転用してはいけない OAuth 認証の禁止 (理由は後述)

- しかし技術的には"追加レイヤ"であることを説明

  - OIDC とは OAuth の上に構築された追加レイヤであることを説明
  - OIDC の仕様だからといってすべて認可である、とははっきりと切り分けられないことに言及
    (後述するが、/userinfo エンドポイントは明らかに認可の役割を持つ)
  - OIDC 側で発祥した仕様が OAuth 側に逆輸入されることもあることに言及
  - OIDC を理解するためには OAuth の理解が必要であると主張

3. OAuth に必要な概念

- 概要
  - リソース認可とは、リソースの所有者が、リソースへのアクセスを第三者に許可することであることを説明
  - 必要な概念を順に説明していくことを明示
- リソースにアクセスするために必要なクレデンシャル(アクセストークン)の概念

  - アクセストークンとは、リソースアクセスのための鍵
  - この鍵を持っていれば、誰でもリソースにアクセスできる
    - つまり、鍵の利用者を検証はしない
    - 一度漏洩すると、誰でもリソースにアクセスできてしまう
    - だからこそ、鍵の管理は非常に重要
    - 鍵の有効期限は短い方が良い
  - 余談: アクセストークンの形式には二種類あることを説明 (後述)
  - 余談 2: 近年ではアクセストークンの利用者を検証する仕組みが増えてきていることに言及 (MTLS, DPoP) (後述)

- スコープとは何か

  - リソースのアクセス権の範囲を指定する仕組み
    - スペース区切りの文字列で複数指定可能
    - 具体例 → Google Photos API のスコープ例
  - もし自分でスコープを設計するときに考えておきたいこと
    - 各サービスのドメイン知識に依存
    - 最小責任の原則
    - 単純リソースであれば、読み取り/書き込み での分離
    - 複雑なリソースであれば、リソース × 操作 での分離

1. OAuth 登場人物

- 概要

  - OAuth の登場人物(ロール)を説明することを明示
  - リソース認可に関連する人物をとりあえず列挙

    - リソースの持ち主
    - リソースを管理している保管庫
    - 保管庫へのアクセスを管理している認可局
    - リソースにアクセスする第三者

  - ここでは Google Photos を例に説明することを明示

    - リソースの持ち主は Google Photos に画像を保存しているユーザ
    - 第三者である印刷サービスに、保管庫上にある自分の写真へアクセスできるよう、
      Google 認可局に許可を与える

  - リソースオーナー

    - リソースの持ち主
    - Google Photos に画像を保存しているユーザ
    - 認可局に許可を与える主体

  - リソースサーバ

    - リソースオーナーの持つリソースを管理している保管庫
    - アクセストークンを検証し、アクセストークンが有効であればリソースへのアクセスを許可する

  - 認可サーバ
    - 保管庫へのアクセスを管理している認可局
    - リソースオーナーからの許可を得て、アクセストークンを発行する
  - クライアント

    - リソースにアクセスする第三者
    - 印刷サービスなど、リソースオーナーに代わってリソースにアクセスするアプリケーション
    - リソースオーナーから許可を得て、認可サーバからアクセストークンを取得し
      保管庫のリソースにアクセス

  - まとめ

    - 4 つの登場人物の関係性を図示して説明

  - ※余談: OAuth クライアント の種類

    - OAuth "クライアント" という名前が付いているが、
      OAuth クライアント であってもサーバサイドで動作することはある
      (むしろそちらの方が好ましい) ことを説明
    - 「クライアント」という呼称で混同されがちだが、
      OAuth クライアント はあくまで OAuth フローにおける役割(ロール)であることを強調

    - OAuth には confidential/public が存在することを明示
    - とりあえず簡単のため confidential で進めることを明言
      public client については後述として伏線とする
    - confidential client の場合、サーバサイドで動作
      Rails のような昔ながらの MPA を想定する

5. OAuth コードフローの簡易的解説

- 概要
  - OAuth の代表的なフローである認可コードフローについて簡易的に解説することを明示
- フローに登場するクレデンシャル

  - アクセストークン
    - 解説済みなので飛ばす
  - 認可コード
    - アクセストークンを引き換えるための一時的なトークン
    - 有効期限は短く、一度使うと無効になる
    - 直接アクセストークンを受け取るのではなく
      認可コードを経由してアクセストークンを受け取ることで
      セキュリティを向上させることができる

- フローの流れ
  - (元記事を参照)
- まとめ
  - 最終的にクライアントがアクセストークンを取得して、フローは終了することを説明
  - 認可コードを挟むことで煩雑になってると感じるかもしれないが
    セキュリティ向上のために必要なステップであることを強調
- 余談: 認可コードフロー以外のフロー

  - インプリシットフローが存在することを説明
    - セキュリティ上の理由で非推奨となったことに言及
    - とりあえず簡単のため、ここからの解説は認可コードフローで進行
    - implicit flow の詳細と非推奨理由については後述
    - インプリシットフローの非推奨化の話を通して、認可コードを挟むことの重要性もわかるようになることを説明

6. アクセストークンの形式

- 概要

  - OAuth におけるアクセストークンの形式について解説することを明示
  - OAuth 自体はアクセストークンの形式を規定していないことを説明
  - そのため、サービスによってアクセストークンの形式が異なることを説明

- アクセストークンの形式の種類

  - アクセストークンには大きく分けて二種類の形式が存在することを説明 (RFC6819 セクション 3.1)
    - Handle 式 トークン
      - ランダム文字列からなる不透明 (opaque) なトークン
      - 認可サーバの内部データを参照するキーとして機能する
      - opaque トークンとも呼ばれる
      - ランダム文字列であるため、トークンから情報を読み取ることはできない
    - Assertion 式 トークン
      - トークンそのものに意味があり、解析が可能なトークン
      - JWT(JSON Web Token) が代表例
      - トークンを解析することで、トークンの発行者、有効期限、スコープなどの情報を取得できる
      - 電子署名を持ち、改ざん検知が可能
  - それぞれのメリットとデメリット

    - Handle 式 トークン

      - メリット

        - トークンが漏洩しても、認可サーバ側で無効化が容易い
        - データは認可サーバ側で一元管理されるため、情報が古くならない

      - デメリット
        - リソースサーバがアクセストークンの詳細を取得するために
          認可サーバに問い合わせる必要があり、パフォーマンスに影響が出る可能性

    - Assertion 式 トークン

      - メリット

        - リソースサーバが認可サーバに問い合わせることなく
          トークンの詳細情報を取得できるため、パフォーマンスが良い

      - デメリット
        - トークンが漏洩した場合、認可サーバ側で無効化が難しい
        - トークンに含まれる情報が古くなる可能性がある
        - 失効の実装が難しいため、アクセストークンの有効期限を短く設定することで対処することが多い

- まとめ

  - OAuth 自体はアクセストークンの形式を規定していないため、
    どちらの形式を採用するかは実装者の自由であることを強調

6. クライアント登録と認証

- 概要

  - OAuth におけるクライアント登録と認証について解説することを明示
  - 簡易フローにおいて、一つ抜けている点が、
    トークン引き換えリクエストの際に、
    リクエスト元が正当なクライアントであるかを認可サーバが確認しないといけない点
  - そのために、クライアント登録と認証が必要であることを説明

- クライアント認証の手法の種類
  - クライアント認証には大きく分けて 2 つの方法が存在
  - 共有シークレット方式・高鍵鍵暗号方式
    - 公開鍵暗号方式については応用編として後述
    - とりあえずここでは共有シークレット方式を説明
- クライアント登録の流れ
  - OAuth のベースとなる仕様では、特にクライアント登録の方法を規定していないことを説明
  - クライアントアプリケーションの開発者が
    認可サーバのダッシュボード画面などから登録を行うことが一般的である
    - 余談だが、RFC7591/RFC7592 でクライアント登録の仕様が定義されていることにも言及
  - 何らかの手段でクライアント登録を行うと、
    認可サーバからクライアント ID とクライアントシークレットが発行される
    - client_id: クライアントを一意に識別するための ID
    - client_secret: クライアント認証のための秘密情報
- クライアント認証の流れ
  - 認可リクエスト時に、クライアント ID をリクエストパラメータとして渡す
  - トークン引き換えリクエスト時に、クライアント認証情報として以下のパラメータを渡す
    - client_id: クライアント ID
    - client_secret: クライアントシークレット
  - 渡し方について二種類
    - HTTP Basic 認証方式 (推奨) `client_secret_basic`
    - リクエストボディ方式 (非推奨) `client_secret_post`
    - 前者のみ解説
  - `client_secret_basic` の場合
    - client_id と client_secret をコロン`:`で連結し、Base64 エンコードする
    - HTTP の Authorization ヘッダに `Basic {Base64エンコードした文字列}` を設定する
    - 認可サーバはこれを復号し、クライアント認証を行う
- まとめ
  - クライアント登録と認証は、OAuth フローにおいて重要なステップであることを強調
  - クライアント認証を適切に実装することで、
    不正なクライアントによるアクセストークンの取得を防止できることを説明
- 余談: 共有シークレットでの認証のリスク

  - 共有シークレットは漏洩リスクがあることを説明
  - そのため、公開鍵暗号を用いたクライアント認証方式の需要が高まっている
  - 公開鍵暗号方式については応用編として後述することを明示

- ここまでの知識を元に、state 抜き、pkce 抜きの詳細なコードフロー解説
  - 認可コードリクエスト/レスポンス、トークンリクエスト/レスポンス

(攻撃手法はとりあえず confidential でも発生しうるものに限定することに留意)

- 認可コード押し付け攻撃(CSRF) + state での防御
- 認可コード奪取攻撃(cofidential に限定)
  (リダイレクト URI 攻撃 + redirect_uri 完全一致での防御)
- 認可コード消費攻撃 + pkce での防御
  (認可コードインジェクション攻撃)

- リフレッシュトークンの紹介
- リフレッシュトークンフロー解説

- 完全版のコードフロー解説
  - 認可コードリクエスト/レスポンス、トークンリクエスト/レスポンス
