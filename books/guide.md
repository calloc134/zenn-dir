`5e8da6c491e720.md`
をベースにし、このブログの文章をある程度保持しながら、
books/sikkari-oauth-oidc 以下に zenn のブックとして再構築してください。

目次は以下の通りとする。

- OAuth とは
- OIDC とは
- 2 つの目的の違い
  目的は全く異なるユースケースだが、
  技術的には差分というより"追加レイヤ"であることを明言

- OAuth に必要な概念
  リソース認可とは何をすべきか
  スコープとは何か、どう設計されているか

- OAuth 登場人物
  ※余談: OAuth クライアントには confidential/public が存在することを明示
  とりあえず簡単のため confidential で進めることを明言、public client については後述として伏線とする

- OAuth 簡易フロー
  ここで認可コード/アクセストークンの解説
  ※余談: 認可コードフロー以外の他のフロー(implicit)が存在することを明示
  とりあえず簡単のため、ここからは認可コードフローで進行 implicit flow については後述として伏線とする

- アクセストークンの形式についての解説
  handle(opaque トークン)/assertion(JWT)について解説。
  それぞれの特性についても述べる

- クライアント登録/認証
  簡易フローを見て、リクエスト元が正しいクライアントであるかを認可サーバが確認しないといけないのでは？と気づかせる
  → クライアント登録- 認証の必要性に説得力をもたせる

- ここまでの知識を元に、state 抜き、pkce 抜きの詳細なコードフロー解説
  - 認可コードリクエスト/レスポンス、トークンリクエスト/レスポンス

(攻撃手法はとりあえず confidential でも発生しうるものに限定することに留意)

- 認可コード押し付け攻撃(CSRF) + state での防御
- 認可コード奪取攻撃(cofidential に限定)
  (リダイレクト URI 攻撃 + redirect_uri 完全一致での防御)
- 認可コード消費攻撃 + pkce での防御
  (認可コードインジェクション攻撃)

- リフレッシュトークンの紹介
- リフレッシュトークンフロー解説

- 完全版のコードフロー解説
  - 認可コードリクエスト/レスポンス、トークンリクエスト/レスポンス
