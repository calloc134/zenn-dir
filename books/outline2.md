## 16. 認可コードを不正に取得する攻撃と防御 (public client 編)

- 概要
  - 認可コードを不正に取得する攻撃手法とその防御方法について解説することを明示
  - 今回は public client を対象とすることを明示
- カスタム URI スキームの悪用
  - 攻撃の概要
    - クライアントが public client でネイティブアプリの場合
    - リダイレクトで開かれるアプリが複数選択できる場合がある
      - 例: ブラウザにおいて、`myapp://`のような文字列から始まる URL を開いた時に
      - どのアプリで開くかを選択できる
    - この仕組みは便利だが、同じ URL であっても開くアプリが一意に決まらない場合がある
    - 攻撃者が悪意のあるアプリを用意し、被害者にインストールさせる
    - 被害者が認可リクエストを行い、認可サーバから認可コードが返される
    - リダイレクト URI が`myapp://callback`のような形式である場合
    - 被害者の端末で、悪意のあるアプリが選択されてしまうと
    - 認可コードが攻撃者に渡ってしまう
    - 余談: そもそもユーザ端末に悪意のあるアプリをインストールされていること自体が問題
      - 悪意あるアプリをインストールできた場合の
      - 横展開による被害拡大の手法のひとつとして考えることができる
  - 攻撃の流れ
    - (省略)
  - 攻撃の対策
    - 認可コードの奪取を防ぐという意味では
    - OAuth のフロー側で特に対策できるものはない
    - ネイティブアプリの場合、カスタム URL スキームの使用を避ける
      - 代わりに app-claimed HTTPS URI を利用
        - OS レベルで、
        - メイン所有者がホワイトリストしたアプリだけが
        - その https URL を受け取れるように検証必須とする仕組み
        - iOS では Universal Links
        - Android では App Links
        - 詳細な OS ごとの設定については
        - OAuth 範囲外なため、詳しくは外部記事を参照
    - ユーザ教育
      - 不審なアプリのインストールを避けるようにユーザに注意喚起する
    - もしくは、さらに後手で防御する
      - "認可コードを奪取する攻撃"が通っても
      - それをアクセストークンに交換できないようにすればいいとする考え
        - PKCE の利用

## 17. 認可コードを用いてアクセストークンを不正に取得する攻撃と防御 (public client 編)

- 概要
  - 認可コードを用いてアクセストークンを不正に取得する攻撃手法とその防御方法について解説することを明示
  - 今回は public client を対象とすることを明示
- 偽装クライアントによるアクセストークン取得攻撃
  - 攻撃の概要
    - 攻撃者が認可コードを奪取した後に行う攻撃
    - 攻撃者がクライアントアプリを偽装し
    - 攻撃者が事前に被害者から奪取した認可コードを用いて
    - アクセストークンを取得する攻撃
    - public client ではクライアントシークレットを安全な形で保持できないため
    - クライアント認証が不可能であり、存在しない
    - クライアント認証がないことにより、
    - クライアント偽装が技術的に可能である点を強調
  - 攻撃の流れを提示
    - (省略)
  - この方式で何故攻撃を防止できるか？
    - PKCE はクライアントの一貫性を保証するもの
    - 攻撃者が認可コードを取得したとしても
    - 認可コードに対応する code_verifier を知らない
    - そのためクライアントの一貫性が保証できず、検証が失敗する
  - PKCE によって、攻撃を防止できることを流れで提示
    - (省略)
- まとめ
  - public client の場合においては、クライアントを偽装して
  - アクセストークンを不正に取得する攻撃が可能であり、例を理解した
  - PKCE の一貫性保証の仕組みにより、この攻撃を防止できることを理解した

## 18. ここまでの完全版コードフロー 解説 (public client)

- 概要
  - ここまでの知識を元に、完全版のコードフロー解説を行うことを明示
  - (つまり、防御機構込みのフロー)
  - ここでは public client を対象とすることを明示
- フローの流れ
  - (省略)
- 実質的な差分
  - 実質的な差分はクライアント認証の有無しかない
  - アクセストークンリクエスト時の
    - Authorization Header の省略 (public client では不要)
    - ボディの client_id (public client では必須)
  - のみ
- まとめ
  - ここまでの内容を踏まえ、完全版のコードフローを理解できたことを強調

## 19. インプリシットフローの解説と非推奨の理由

- 概要
- インプリシットフローの解説と、その非推奨の理由について説明することを明示
- インプリシットフローの解説
  - フローの流れ
    - フローとしては、認可コードを介さず
    - 認可レスポンス部分で直接アクセストークンを受け取る
    - 認可コードは一時トークンのようなものなので
    - それを介さない分、簡略化されたフローといえる
  - 具体的なフロー
    - (省略)
- インプリシットフローの問題点と非推奨の理由
  - 認可コードフローに対する攻撃は、以下の手順を踏む必要がある
    - 認可コードを奪取する
    - 奪取した認可コードを用いてアクセストークンを取得する
  - インプリシットフローでは、アクセストークンが直接フロントチャネルに露出する
  - そのため、以下の手順を踏むだけでアクセストークンを奪取できる
    - アクセストークンを奪取する
  - confidential client の場合、
    - アクセストークンはサーバ間通信でやり取りされるため
    - フロントチャネルに露出しない
    - つまり、ブラウザのようなユーザデバイス上で
    - アクセストークンを盗むことが原理上不可能
  - そのほか、confidential/public client 問わず
    - アクセストークンに関連する以下の仕様が軒並み
    - インプリシットフローのサポートを打ち切っている
      - リフレッシュトークン
      - sender-constrained token などのアクセストークン強化仕様
      - PKCE などのクライアント一貫性保証仕様
    - フローが簡易的なため、セキュリティ強化機構を埋め込む余地がない
  - 実は、インプリシットフローが誕生したのは歴史的経緯
    - 昔のブラウザ特有は同一オリジン制約が厳しく
    - 認可コードフローを動作させられなかった
    - そのため簡易的なフローとしてインプリシットフローが考案された
    - しかし、現在では CORS の普及により
    - 認可コードフローをブラウザ上で動作させることが可能となった
    - そのため、インプリシットフローを使う必然性がなくなった
- 近年の評価
  - インプリシットフローはセキュリティ上の問題が多いため
  - 近年の多くの仕様で非推奨とされる
    - OAuth 2.0 Security BCP (RFC9700)
    - OAuth 2.1
      - OAuth 2.1 ではそもそも仕様から削除
- まとめ
  - インプリシットフローは簡略化されたフロー
  - フロントチャネルにアクセストークンが露出する問題点
  - そのため、近年の仕様では非推奨・削除されている
  - 余談: OAuth を認証に転用した場合
    - インプリシットフローの被害は更に拡大する
    - 詳細は後述

## 20. OAuth まとめと OAuth 2.1 の紹介

## 21. OIDC に必要な概念

## 22. ID トークンの詳細

## 23. OIDC の登場人物

## 24. OIDC 簡易フロー 解説 (認可コードフロー)

## 25. OAuth + プロフィール API による疑似認証の問題点

## 26. OIDC を活用するマインドセット

## 27. ここまでの OIDC 完全コードフロー 解説
