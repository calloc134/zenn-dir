## 16. 認可コードを不正に取得する攻撃と防御 (public client 編)

- 概要
  - 認可コードを不正に取得する攻撃手法とその防御方法について解説することを明示
  - 今回は public client を対象とすることを明示
- カスタム URI スキームの悪用
  - 攻撃の概要
    - クライアントが public client でネイティブアプリの場合
    - リダイレクトで開かれるアプリが複数選択できる場合がある
      - 例: ブラウザにおいて、`myapp://`のような文字列から始まる URL を開いた時に
      - どのアプリで開くかを選択できる
    - この仕組みは便利だが、同じ URL であっても開くアプリが一意に決まらない場合がある
    - 攻撃者が悪意のあるアプリを用意し、被害者にインストールさせる
    - 被害者が認可リクエストを行い、認可サーバから認可コードが返される
    - リダイレクト URI が`myapp://callback`のような形式である場合
    - 被害者の端末で、悪意のあるアプリが選択されてしまうと
    - 認可コードが攻撃者に渡ってしまう
    - 余談: そもそもユーザ端末に悪意のあるアプリをインストールされていること自体が問題
      - 悪意あるアプリをインストールできた場合の
      - 横展開による被害拡大の手法のひとつとして考えることができる
  - 攻撃の流れ
    - (省略)
  - 攻撃の対策
    - OAuth のフロー側で特に対策できるものはない
    - ネイティブアプリの場合、カスタム URL スキームの使用を避ける
      - 代わりに app-claimed HTTPS URI を利用
        - OS レベルで、
        - メイン所有者がホワイトリストしたアプリだけが
        - その https URL を受け取れるように検証必須とする仕組み
        - iOS では Universal Links
        - Android では App Links
        - OAuth の仕様とは外れるため詳しくは外部記事を参照
    - ユーザ教育
      - 不審なアプリのインストールを避けるようにユーザに注意喚起する
    - もしくは、さらに後手で防御する
      - "認可コードを奪取する攻撃"が通っても
      - それをアクセストークンに交換できないようにすればいいとする考え
        - PKCE の利用

## 17. 認可コードを用いてアクセストークンを不正に取得する攻撃と防御 (public client 編)

- 概要
  - 認可コードを用いてアクセストークンを不正に取得する攻撃手法とその防御方法について解説することを明示
  - 今回は public client を対象とすることを明示
- 偽装クライアントによるアクセストークン取得攻撃
  - 攻撃の概要
    - 攻撃者がクライアントアプリを偽装し
    - 攻撃者が事前に被害者から奪取した認可コードを用いて
    - アクセストークンを取得する攻撃
    - public clientにはクライアント認証がないため
    - クライアント偽装が技術的に可能である点を強調
  - 攻撃の流れを提示
    - (省略)
  - 攻撃の対策：PKCE の重要性
    - PKCE を利用することで、攻撃者が認可コードを用いてアクセストークンを取得することを防止できる
    - PKCE でなぜ攻撃を防止できるか？
      - PKCE はクライアントの一貫性を保証するもの
      - PKCE を利用することで、攻撃者が認可コードを取得したとしても
      - その認可コードに対応する code_verifier を知らないため
      - アクセストークンを取得できないことを強調
  - PKCEによって、攻撃を防止できることを流れで提示
    - (省略)
- まとめ
  - public clientの場合においては、クライアントを偽装して
  - アクセストークンを不正に取得する攻撃が可能であり、例を理解した
  - PKCE の一貫性保証の仕組みにより、この攻撃を防止できることを理解した

## 18. ここまでの完全版コードフロー 解説 (public client)

- 概要
  - ここまでの知識を元に、完全版のコードフロー解説を行うことを明示
  - (つまり、防御機構込みのフロー)
  - ここでは public client を対象とすることを明示
- フローの流れ
  - (省略)
- 実質的な差分
  - 実質的な差分はクライアント認証の有無しかない
  - アクセストークンリクエスト時の
    - Authorization Header の省略 (public client では不要)
    - ボディのclient_id (public client では必須)
  - のみ
- まとめ
  - ここまでの内容を踏まえ、完全版のコードフローを理解できたことを強調


## 19. インプリシットフローの解説と非推奨の理由

## 20. OAuth まとめと OAuth 2.1 の紹介

## 21. OIDC に必要な概念

## 22. ID トークンの詳細

## 23. OIDC の登場人物

## 24. OIDC 簡易フロー 解説 (認可コードフロー)

## 25. OAuth + プロフィール API による疑似認証の問題点

## 26. OIDC を活用するマインドセット

## 27. ここまでの OIDC 完全コードフロー 解説
